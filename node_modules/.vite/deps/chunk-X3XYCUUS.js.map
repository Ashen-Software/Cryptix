{
  "version": 3,
  "sources": ["../../@passwordless-id/webauthn/dist/esm/client.js", "../../@passwordless-id/webauthn/dist/esm/utils.js", "../../@passwordless-id/webauthn/dist/esm/parsers.js", "../../thirdweb/src/wallets/in-app/web/lib/auth/passkeys.ts"],
  "sourcesContent": ["import * as utils from './utils.js';\n/**\n * Returns whether passwordless authentication is available on this browser/platform or not.\n */\nexport function isAvailable() {\n    return !!window.PublicKeyCredential;\n}\n/**\n * Returns whether the device itself can be used as authenticator.\n */\nexport async function isLocalAuthenticator() {\n    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\nasync function getAuthAttachment(authType) {\n    if (authType === \"local\")\n        return \"platform\";\n    if (authType === \"roaming\" || authType === \"extern\")\n        return \"cross-platform\";\n    if (authType === \"both\")\n        return undefined; // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n    // the default case: \"auto\", depending on device capabilities\n    try {\n        if (await isLocalAuthenticator())\n            return \"platform\";\n        else\n            return \"cross-platform\";\n    }\n    catch (e) {\n        // might happen due to some security policies\n        // see https://w3c.github.io/webauthn/#sctn-isUserVerifyingPlatformAuthenticatorAvailable\n        return undefined; // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n    }\n}\nfunction getAlgoName(num) {\n    switch (num) {\n        case -7: return \"ES256\";\n        // case -8 ignored to to its rarity\n        case -257: return \"RS256\";\n        default: throw new Error(`Unknown algorithm code: ${num}`);\n    }\n}\n/**\n * Creates a cryptographic key pair, in order to register the public key for later passwordless authentication.\n *\n * @param {string} username\n * @param {string} challenge A server-side randomly generated string.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'auto'|'local'|'roaming'|'both'}       [options.authenticatorType='auto'] Which device to use as authenticator.\n *          'auto': if the local device can be used as authenticator it will be preferred. Otherwise it will prompt for a roaming device.\n *          'local': use the local device (using TouchID, FaceID, Windows Hello or PIN)\n *          'roaming': use a roaming device (security key or connected phone)\n *          'both': prompt the user to choose between local or roaming device. The UI and user interaction in this case is platform specific.\n * @param {boolean} [options.attestation=false] If enabled, the device attestation and clientData will be provided as Base64url encoded binary data.\n *                                Note that this is not available on some platforms.\n * @param {'discouraged'|'preferred'|'required'} [options.discoverable] A \"discoverable\" credential can be selected using `authenticate(...)` without providing credential IDs.\n *              Instead, a native pop-up will appear for user selection.\n *              This may have an impact on the \"passkeys\" user experience and syncing behavior of the key.\n */\nexport async function register(username, challenge, options) {\n    options = options ?? {};\n    if (!utils.isBase64url(challenge))\n        throw new Error('Provided challenge is not properly encoded in Base64url');\n    const creationOptions = {\n        challenge: utils.parseBase64url(challenge),\n        rp: {\n            id: options.domain ?? window.location.hostname,\n            name: options.domain ?? window.location.hostname\n        },\n        user: {\n            id: options.userHandle ? utils.toBuffer(options.userHandle) : await utils.sha256(new TextEncoder().encode('passwordless.id-user:' + username)),\n            name: username,\n            displayName: username,\n        },\n        pubKeyCredParams: [\n            { alg: -7, type: \"public-key\" },\n            { alg: -257, type: \"public-key\" }, // RS256 (for Windows Hello and others)\n        ],\n        timeout: options.timeout ?? 60000,\n        authenticatorSelection: {\n            userVerification: options.userVerification ?? \"required\",\n            authenticatorAttachment: await getAuthAttachment(options.authenticatorType ?? \"auto\"),\n            residentKey: options.discoverable ?? 'preferred',\n            requireResidentKey: (options.discoverable === 'required') // mainly for backwards compatibility, see https://www.w3.org/TR/webauthn/#dictionary-authenticatorSelection\n        },\n        attestation: \"direct\"\n    };\n    if (options.debug)\n        console.debug(creationOptions);\n    const credential = await navigator.credentials.create({ publicKey: creationOptions }); //PublicKeyCredential\n    if (options.debug)\n        console.debug(credential);\n    const response = credential.response; // AuthenticatorAttestationResponse\n    let registration = {\n        username: username,\n        credential: {\n            id: credential.id,\n            publicKey: utils.toBase64url(response.getPublicKey()),\n            algorithm: getAlgoName(credential.response.getPublicKeyAlgorithm())\n        },\n        authenticatorData: utils.toBase64url(response.getAuthenticatorData()),\n        clientData: utils.toBase64url(response.clientDataJSON),\n    };\n    if (options.attestation) {\n        registration.attestationData = utils.toBase64url(response.attestationObject);\n    }\n    return registration;\n}\nasync function getTransports(authType) {\n    const local = ['internal'];\n    // 'hybrid' was added mid-2022 in the specs and currently not yet available in the official dom types\n    // @ts-ignore\n    const roaming = ['hybrid', 'usb', 'ble', 'nfc'];\n    if (authType === \"local\")\n        return local;\n    if (authType == \"roaming\" || authType === \"extern\")\n        return roaming;\n    if (authType === \"both\")\n        return [...local, ...roaming];\n    // the default case: \"auto\", depending on device capabilities\n    try {\n        if (await isLocalAuthenticator())\n            return local;\n        else\n            return roaming;\n    }\n    catch (e) {\n        return [...local, ...roaming];\n    }\n}\n/**\n * Signs a challenge using one of the provided credentials IDs in order to authenticate the user.\n *\n * @param {string[]} credentialIds The list of credential IDs that can be used for signing.\n * @param {string} challenge A server-side randomly generated string, the base64 encoded version will be signed.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'optional'|'conditional'|'required'|'silent'} [options.mediation='optional'] https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get#mediation\n */\nexport async function authenticate(credentialIds, challenge, options) {\n    options = options ?? {};\n    if (!utils.isBase64url(challenge))\n        throw new Error('Provided challenge is not properly encoded in Base64url');\n    const transports = await getTransports(options.authenticatorType ?? \"auto\");\n    let authOptions = {\n        challenge: utils.parseBase64url(challenge),\n        rpId: options.domain ?? window.location.hostname,\n        allowCredentials: credentialIds.map(id => {\n            return {\n                id: utils.parseBase64url(id),\n                type: 'public-key',\n                transports: transports,\n            };\n        }),\n        userVerification: options.userVerification ?? \"required\",\n        timeout: options.timeout ?? 60000,\n    };\n    if (options.debug)\n        console.debug(authOptions);\n    let auth = await navigator.credentials.get({ publicKey: authOptions, mediation: options.mediation });\n    if (options.debug)\n        console.debug(auth);\n    const response = auth.response;\n    const authentication = {\n        credentialId: auth.id,\n        authenticatorData: utils.toBase64url(response.authenticatorData),\n        clientData: utils.toBase64url(response.clientDataJSON),\n        signature: utils.toBase64url(response.signature),\n        userHandle: response.userHandle ? utils.toBase64url(response.userHandle) : undefined // may not be returned by every authenticator\n    };\n    return authentication;\n}\n", "/********************************\n     Encoding/Decoding Utils\n********************************/\nexport function randomChallenge() {\n    return crypto.randomUUID();\n}\nexport function toBuffer(txt) {\n    return Uint8Array.from(txt, c => c.charCodeAt(0)).buffer;\n}\nexport function parseBuffer(buffer) {\n    return String.fromCharCode(...new Uint8Array(buffer));\n}\nexport function isBase64url(txt) {\n    return txt.match(/^[a-zA-Z0-9\\-_]+=*$/) !== null;\n}\nexport function toBase64url(buffer) {\n    const txt = btoa(parseBuffer(buffer)); // base64\n    return txt.replaceAll('+', '-').replaceAll('/', '_');\n}\nexport function parseBase64url(txt) {\n    txt = txt.replaceAll('-', '+').replaceAll('_', '/'); // base64url -> base64\n    return toBuffer(atob(txt));\n}\nexport async function sha256(buffer) {\n    return await crypto.subtle.digest('SHA-256', buffer);\n}\nexport function bufferToHex(buffer) {\n    return [...new Uint8Array(buffer)]\n        .map(b => b.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n}\nexport function concatenateBuffers(buffer1, buffer2) {\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp;\n}\n;\n", "import * as authenticators from './authenticators.js';\nimport * as utils from './utils.js';\nconst utf8Decoder = new TextDecoder('utf-8');\nexport function parseClient(data) {\n    if (typeof data == 'string')\n        data = utils.parseBase64url(data);\n    return JSON.parse(utf8Decoder.decode(data));\n}\nexport function parseAuthenticator(data) {\n    if (typeof data == 'string')\n        data = utils.parseBase64url(data);\n    return authenticators.parseAuthBuffer(data);\n}\nexport function parseAttestation(data) {\n    //if(typeof data == 'string')\n    //    data = utils.parseBase64url(data)\n    // Useless comment, let's at least provide the raw value \n    // return \"The device attestation proves the authenticity of the device model / aaguid. It's not guaranteed to be included and really complex to parse / verify. Good luck with that one!\"\n    return data;\n}\nexport function parseRegistration(registration) {\n    return {\n        username: registration.username,\n        credential: registration.credential,\n        client: parseClient(registration.clientData),\n        authenticator: parseAuthenticator(registration.authenticatorData),\n        attestation: registration.attestationData ? parseAttestation(registration.attestationData) : null\n    };\n}\nexport function parseAuthentication(authentication) {\n    return {\n        credentialId: authentication.credentialId,\n        client: parseClient(authentication.clientData),\n        authenticator: parseAuthenticator(authentication.authenticatorData),\n        signature: authentication.signature\n    };\n}\n", "import { client } from \"@passwordless-id/webauthn\";\nimport type { AuthType } from \"@passwordless-id/webauthn/dist/esm/types.js\";\nimport type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../../utils/fetch.js\";\nimport type { EcosystemWalletId } from \"../../../../wallet-types.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"../../../core/authentication/type.js\";\nimport type { Ecosystem } from \"../../types.js\";\nimport { LocalStorage } from \"../../utils/Storage/LocalStorage.js\";\n\nfunction getVerificationPath() {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey/callback`;\n}\nfunction getChallengePath(type: \"sign-in\" | \"sign-up\", username?: string) {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey?type=${type}${\n    username ? `&username=${username}` : \"\"\n  }`;\n}\n\nexport async function registerPasskey(options: {\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  authenticatorType?: AuthType;\n  username?: string;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!client.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  // TODO inject this\n  const storage = new LocalStorage({\n    clientId: options.client.clientId,\n    ecosystemId: options.ecosystem?.id,\n  });\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  const generatedName = options.username ?? generateUsername(options.ecosystem);\n  // 1. request challenge from  server\n  const res = await fetchWithId(getChallengePath(\"sign-up\", generatedName));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 2. initiate registration\n  const registration = await client.register(generatedName, challenge, {\n    authenticatorType: options.authenticatorType ?? \"auto\",\n    userVerification: \"required\",\n    attestation: true,\n    debug: false,\n  });\n  // 3. store the credentialId in local storage\n  await storage.savePasskeyCredentialId(registration.credential.id);\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  // 4. send the registration object to the server\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    body: JSON.stringify({\n      type: \"sign-up\",\n      authenticatorData: registration.authenticatorData,\n      credentialId: registration.credential.id,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: registration.clientData,\n      username: generatedName,\n      credential: {\n        publicKey: registration.credential.publicKey,\n        algorithm: registration.credential.algorithm,\n      },\n    }),\n  });\n  const verifData = await verifRes.json();\n\n  if (!verifData) {\n    throw new Error(\"No token received\");\n  }\n  // 5. returns back the IAW authentication token\n  return verifData;\n}\n\nexport async function loginWithPasskey(options: {\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  authenticatorType?: AuthType;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!client.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  // TODO inject this\n  const storage = new LocalStorage({\n    clientId: options.client.clientId,\n    ecosystemId: options.ecosystem?.id,\n  });\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  // 1. request challenge from  server/iframe\n  const res = await fetchWithId(getChallengePath(\"sign-in\"));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 1.2. find the user's credentialId in local storage\n  const credentialId = await storage.getPasskeyCredentialId();\n  const credentials = credentialId ? [credentialId] : [];\n  // 2. initiate login\n  const authentication = await client.authenticate(credentials, challenge, {\n    authenticatorType: options.authenticatorType ?? \"auto\",\n    userVerification: \"required\",\n  });\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  // 3. send the authentication object to the server/iframe\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    body: JSON.stringify({\n      type: \"sign-in\",\n      authenticatorData: authentication.authenticatorData,\n      credentialId: authentication.credentialId,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: authentication.clientData,\n      signature: authentication.signature,\n    }),\n  });\n  // 5. store the credentialId in local storage\n  await storage.savePasskeyCredentialId(authentication.credentialId);\n\n  const verifData = await verifRes.json();\n\n  if (!verifData) {\n    throw new Error(\"No token received\");\n  }\n  // 6. return the auth'd user type\n  return verifData;\n}\n\n/**\n * Returns whether this device has a stored passkey ready to be used for sign-in\n * @param client - the thirdweb client\n * @returns whether the device has a stored passkey\n * @walletUtils\n */\nexport async function hasStoredPasskey(\n  client: ThirdwebClient,\n  ecosystemId?: EcosystemWalletId,\n) {\n  const storage = new LocalStorage({\n    clientId: client.clientId,\n    ecosystemId: ecosystemId,\n  });\n  const credId = await storage.getPasskeyCredentialId();\n  return !!credId;\n}\n\nfunction generateUsername(ecosystem?: Ecosystem) {\n  return `${ecosystem?.id ?? \"wallet\"}-${new Date().toISOString()}`;\n}\n"],
  "mappings": "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",
  "names": []
}
