{
  "version": 3,
  "sources": ["../../thirdweb/src/wallets/injected/index.ts"],
  "sourcesContent": ["import type { Address } from \"abitype\";\nimport {\n  type SignTypedDataParameters,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport type { Ethereum } from \"../interfaces/ethereum.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { InjectedConnectOptions, WalletId } from \"../wallet-types.js\";\nimport { injectedProvider } from \"./mipdStore.js\";\n\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { InjectedSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\n\n/**\n * Checks if the provided wallet is an injected wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an injected wallet, false otherwise.\n */\nexport function isInjectedWallet(wallet: Wallet<WalletId>) {\n  return !!injectedProvider(wallet.id);\n}\n\n// TODO: save the provider in data\nexport function getInjectedProvider(walletId: WalletId) {\n  const provider = injectedProvider(walletId);\n  if (!provider) {\n    throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n  }\n\n  return provider;\n}\n\n/**\n * @internal\n */\nexport async function connectInjectedWallet(\n  id: InjectedSupportedWalletIds,\n  options: InjectedConnectOptions,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = getInjectedProvider(id);\n  const addresses = await provider.request({\n    method: \"eth_requestAccounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  let connectedChain =\n    options.chain && options.chain.id === chainId\n      ? options.chain\n      : getCachedChain(chainId);\n\n  // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n  if (options.chain && options.chain.id !== chainId) {\n    await switchChain(provider, options.chain);\n    connectedChain = options.chain;\n  }\n\n  return onConnect(provider, address, connectedChain, emitter);\n}\n\n/**\n * @internal\n */\nexport async function autoConnectInjectedWallet(\n  id: InjectedSupportedWalletIds,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n  chain?: Chain,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = getInjectedProvider(id);\n\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  const connectedChain =\n    chain && chain.id === chainId ? chain : getCachedChain(chainId);\n\n  return onConnect(provider, address, connectedChain, emitter);\n}\n\nfunction createAccount(provider: Ethereum, address: string) {\n  const account: Account = {\n    address,\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            accessList: tx.accessList,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            from: this.address,\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n\n      return await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address],\n      });\n    },\n    async signTypedData(typedData) {\n      if (!provider || !account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const parsedTypedData = parseTypedData(typedData);\n\n      const { domain, message, primaryType } =\n        parsedTypedData as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parsedTypedData.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const stringifiedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData],\n      });\n    },\n    async watchAsset(asset) {\n      const result = await provider.request(\n        {\n          method: \"wallet_watchAsset\",\n          params: asset,\n        },\n        { retryCount: 0 },\n      );\n      return result;\n    },\n  };\n\n  return account;\n}\n\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect(\n  provider: Ethereum,\n  address: string,\n  chain: Chain,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n): Promise<[Account, Chain, DisconnectFn, SwitchChainFn]> {\n  const account = createAccount(provider, address);\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n  }\n\n  function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount(provider, getAddress(accounts[0]));\n\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n\n  if (provider.on) {\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n  }\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChain(provider, newChain),\n  ] as const;\n}\n\n/**\n * @internal\n */\nasync function switchChain(provider: Ethereum, chain: Chain) {\n  const hexChainId = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: hexChainId }],\n    });\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  } catch (e: any) {\n    // if chain does not exist, add the chain\n    if (e?.code === 4902 || e?.data?.originalError?.code === 4902) {\n      const apiChain = await getChainMetadata(chain);\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            chainId: hexChainId,\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no client id on purpose here\n            blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n          },\n        ],\n      });\n    } else {\n      throw e;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
