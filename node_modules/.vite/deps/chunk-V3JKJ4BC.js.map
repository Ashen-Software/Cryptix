{
  "version": 3,
  "sources": ["../../thirdweb/src/wallets/in-app/core/wallet/ecosystem-core.ts", "../../thirdweb/src/wallets/in-app/web/ecosystem.ts", "../../thirdweb/src/wallets/in-app/web/in-app.ts", "../../thirdweb/src/utils/web/openWindow.ts", "../../thirdweb/src/wallets/coinbase/coinbase-wallet.ts", "../../thirdweb/src/wallets/create-wallet.ts"],
  "sourcesContent": ["import { trackConnect } from \"../../../../analytics/track.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../../../wallet-emitter.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n} from \"../../../wallet-types.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\nimport { getOrCreateInAppWalletConnector } from \"./in-app-core.js\";\n\n/**\n * @internal\n */\nexport function createEcosystemWallet(args: {\n  id: EcosystemWalletId;\n  createOptions: CreateWalletArgs<EcosystemWalletId>[1];\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>;\n}): Wallet<EcosystemWalletId> {\n  // Under the hood, an ecosystem wallet wraps an in-app wallet\n  const { id, createOptions, connectorFactory } = args;\n  const emitter = createWalletEmitter<EcosystemWalletId>();\n  let account: Account | undefined = undefined;\n  let chain: Chain | undefined = undefined;\n  let client: ThirdwebClient | undefined;\n\n  return {\n    id,\n    subscribe: emitter.subscribe,\n    getChain: () => chain,\n    getConfig: () => createOptions,\n    getAccount: () => account,\n    autoConnect: async (options) => {\n      const { autoConnectInAppWallet } = await import(\"./index.js\");\n\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        {\n          id,\n          partnerId: createOptions?.partnerId,\n        },\n      );\n\n      const [connectedAccount, connectedChain] = await autoConnectInAppWallet(\n        options,\n        createOptions,\n        connector,\n      );\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        client: options.client,\n        walletType: id,\n        walletAddress: account.address,\n      });\n      // return only the account\n      return account;\n    },\n    connect: async (options) => {\n      const { connectInAppWallet } = await import(\"./index.js\");\n\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        {\n          id,\n          partnerId: createOptions?.partnerId,\n        },\n      );\n\n      const [connectedAccount, connectedChain] = await connectInAppWallet(\n        options,\n        createOptions,\n        connector,\n      );\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        client: options.client,\n        walletType: id,\n        walletAddress: account.address,\n      });\n      // return only the account\n      return account;\n    },\n    disconnect: async () => {\n      // If no client is assigned, we should be fine just unsetting the states\n      if (client) {\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n          {\n            id,\n            partnerId: createOptions?.partnerId,\n          },\n        );\n        const result = await connector.logout();\n        if (!result.success) {\n          throw new Error(\"Failed to logout\");\n        }\n      }\n      account = undefined;\n      chain = undefined;\n      emitter.emit(\"disconnect\", undefined);\n    },\n    switchChain: async (newChain) => {\n      chain = newChain;\n      emitter.emit(\"chainChanged\", newChain);\n    },\n  };\n}\n", "import type { ThirdwebClient } from \"../../../client/client.js\";\nimport type { Wallet } from \"../../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n} from \"../../wallet-types.js\";\nimport { createEcosystemWallet } from \"../core/wallet/ecosystem-core.js\";\n\n/**\n * Creates an ecosystem wallet.\n * @param createOptions - configuration options\n * @returns The created ecosystem wallet.\n * @example\n * ```ts\n * import { ecosystemWallet } from \"thirdweb/wallets\";\n *\n * const wallet = ecosystemWallet(\"ecosystem.hooli\");\n *\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"google\",\n * });\n * ```\n *\n * Enable smart accounts and sponsor gas for your users:\n * ```ts\n * import { ecosystemWallet } from \"thirdweb/wallets\";\n * const wallet = ecosystemWallet(\"ecosystem.hooli\", {\n *  smartAccount: {\n *   chain: sepolia,\n *   sponsorGas: true,\n * },\n * });\n * ```\n *\n * Connect to a restricted ecosystem wallet with your designated integrator ID\n * @note The integrator ID will be provided to you by the ecosystem with which you're integrating.\n * ```ts\n * import { ecosystemWallet } from \"thirdweb/wallets\";\n * const wallet = ecosystemWallet(\"ecosystem.hooli\", {\n *  integratorId: \"...\"\n * });\n * ```\n * @wallet\n */\nexport function ecosystemWallet(\n  ...args: CreateWalletArgs<EcosystemWalletId>\n): Wallet<EcosystemWalletId> {\n  const [ecosystemId, createOptions] = args;\n  return createEcosystemWallet({\n    id: ecosystemId,\n    createOptions,\n    connectorFactory: async (client: ThirdwebClient) => {\n      const { InAppWebConnector } = await import(\"./lib/web-connector.js\");\n      return new InAppWebConnector({\n        client,\n        ecosystem: {\n          id: ecosystemId,\n          partnerId: createOptions?.partnerId,\n        },\n      });\n    },\n  });\n}\n", "import type { ThirdwebClient } from \"../../../client/client.js\";\nimport type { Wallet } from \"../../interfaces/wallet.js\";\nimport type { CreateWalletArgs } from \"../../wallet-types.js\";\nimport { createInAppWallet } from \"../core/wallet/in-app-core.js\";\n\n/**\n * Creates an in-app wallet.\n * @param createOptions - configuration options\n * @returns The created in-app wallet.\n * @example\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"google\",\n * });\n * ```\n *\n * Enable smart accounts and sponsor gas for your users:\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  smartAccount: {\n *   chain: sepolia,\n *   sponsorGas: true,\n * },\n * });\n * ```\n *\n * Specify a logo for your login page\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  metadata: {\n *   image: {\n *    src: \"https://example.com/logo.png\",\n *    alt: \"My logo\",\n *    width: 100,\n *    height: 100,\n *   },\n *  },\n * });\n * ```\n *\n * Hide the ability to export the private key within the Connect Modal\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  hidePrivateKeyExport: true\n * });\n * ```\n * @wallet\n */\nexport function inAppWallet(\n  createOptions?: CreateWalletArgs<\"inApp\">[1],\n): Wallet<\"inApp\"> {\n  return createInAppWallet({\n    createOptions,\n    connectorFactory: async (client: ThirdwebClient) => {\n      const { InAppWebConnector } = await import(\"./lib/web-connector.js\");\n      return new InAppWebConnector({\n        client,\n      });\n    },\n  });\n}\n", "/**\n * @internal\n */\nexport function openWindow(uri: string) {\n  const isInsideIframe = window !== window.top;\n  if (isInsideIframe) {\n    window.open(uri);\n  } else {\n    if (uri.startsWith(\"http\")) {\n      // taken from for https://github.com/rainbow-me/rainbowkit/\n\n      // Using 'window.open' causes issues on iOS in non-Safari browsers and\n      // WebViews where a blank tab is left behind after connecting.\n      // This is especially bad in some WebView scenarios (e.g. following a\n      // link from Twitter) where the user doesn't have any mechanism for\n      // closing the blank tab.\n      // For whatever reason, links with a target of \"_blank\" don't suffer\n      // from this problem, and programmatically clicking a detached link\n      // element with the same attributes also avoids the issue.\n\n      const link = document.createElement(\"a\");\n      link.href = uri;\n      link.target = \"_blank\";\n      link.rel = \"noreferrer noopener\";\n      link.click();\n    } else {\n      window.location.href = uri;\n    }\n  }\n}\n", "/**\n * internal helper functions\n */\n\nimport type { ProviderInterface } from \"@coinbase/wallet-sdk\";\nimport { trackConnect } from \"../../analytics/track.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { COINBASE } from \"../constants.js\";\nimport type { Account, Wallet } from \"../interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../wallet-emitter.js\";\nimport type { CreateWalletArgs } from \"../wallet-types.js\";\n\n/**\n * @internal\n */\nexport function coinbaseWalletSDK(args: {\n  createOptions?: CreateWalletArgs<typeof COINBASE>[1];\n  providerFactory: () => Promise<ProviderInterface>;\n  onConnectRequested?: (provider: ProviderInterface) => Promise<void>;\n}): Wallet<typeof COINBASE> {\n  const { createOptions } = args;\n  const emitter = createWalletEmitter<typeof COINBASE>();\n  let account: Account | undefined = undefined;\n  let chain: Chain | undefined = undefined;\n\n  function reset() {\n    account = undefined;\n    chain = undefined;\n  }\n\n  let handleDisconnect = async () => {};\n\n  let handleSwitchChain = async (newChain: Chain) => {\n    chain = newChain;\n  };\n\n  const unsubscribeChainChanged = emitter.subscribe(\n    \"chainChanged\",\n    (newChain) => {\n      chain = newChain;\n    },\n  );\n\n  const unsubscribeDisconnect = emitter.subscribe(\"disconnect\", () => {\n    reset();\n    unsubscribeChainChanged();\n    unsubscribeDisconnect();\n  });\n\n  emitter.subscribe(\"accountChanged\", (_account) => {\n    account = _account;\n  });\n\n  return {\n    id: COINBASE,\n    subscribe: emitter.subscribe,\n    getChain: () => chain,\n    getConfig: () => createOptions,\n    getAccount: () => account,\n    autoConnect: async (options) => {\n      const { autoConnectCoinbaseWalletSDK } = await import(\n        \"./coinbaseWebSDK.js\"\n      );\n      const provider = await args.providerFactory();\n      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] =\n        await autoConnectCoinbaseWalletSDK(options, emitter, provider);\n      // set the states\n      account = connectedAccount;\n      chain = connectedChain;\n      handleDisconnect = doDisconnect;\n      handleSwitchChain = doSwitchChain;\n      trackConnect({\n        client: options.client,\n        walletType: COINBASE,\n        walletAddress: account.address,\n      });\n      // return account\n      return account;\n    },\n    connect: async (options) => {\n      const { connectCoinbaseWalletSDK } = await import(\"./coinbaseWebSDK.js\");\n      const provider = await args.providerFactory();\n      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] =\n        await connectCoinbaseWalletSDK(options, emitter, provider);\n\n      // set the states\n      account = connectedAccount;\n      chain = connectedChain;\n      handleDisconnect = doDisconnect;\n      handleSwitchChain = doSwitchChain;\n      trackConnect({\n        client: options.client,\n        walletType: COINBASE,\n        walletAddress: account.address,\n      });\n      // return account\n      return account;\n    },\n    disconnect: async () => {\n      reset();\n      await handleDisconnect();\n    },\n    switchChain: async (newChain) => {\n      await handleSwitchChain(newChain);\n    },\n    onConnectRequested: async () => {\n      if (args.onConnectRequested) {\n        const provider = await args.providerFactory();\n        return args.onConnectRequested?.(provider);\n      }\n    },\n  };\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type {\n  InjectedSupportedWalletIds,\n  WCSupportedWalletIds,\n} from \"./__generated__/wallet-ids.js\";\nimport type { Account, Wallet } from \"./interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n  InjectedConnectOptions,\n  WalletAutoConnectionOption,\n  WalletId,\n} from \"./wallet-types.js\";\n\nimport { trackConnect } from \"../analytics/track.js\";\nimport { webLocalStorage } from \"../utils/storage/webStorage.js\";\nimport { isMobile } from \"../utils/web/isMobile.js\";\nimport { openWindow } from \"../utils/web/openWindow.js\";\nimport { coinbaseWalletSDK } from \"./coinbase/coinbase-wallet.js\";\nimport { getCoinbaseWebProvider } from \"./coinbase/coinbaseWebSDK.js\";\nimport { COINBASE } from \"./constants.js\";\nimport { isEcosystemWallet } from \"./ecosystem/is-ecosystem-wallet.js\";\nimport { ecosystemWallet } from \"./in-app/web/ecosystem.js\";\nimport { inAppWallet } from \"./in-app/web/in-app.js\";\nimport { smartWallet } from \"./smart/smart-wallet.js\";\nimport type { WCConnectOptions } from \"./wallet-connect/types.js\";\nimport { createWalletEmitter } from \"./wallet-emitter.js\";\n\n// TODO: figure out how to define the type without tuple args type and using function overloads\n\n/**\n * Creates a wallet based on the provided ID and arguments.\n * @param args - The arguments for creating the wallet.\n * @returns - The created wallet.\n * @example\n * ```ts\n * import { createWallet } from \"thirdweb/wallets\";\n *\n * const metamaskWallet = createWallet(\"io.metamask\");\n *\n * const account = await metamaskWallet.connect({\n *  client,\n * });\n * ```\n * @wallet\n */\nexport function createWallet<const ID extends WalletId>(\n  ...args: CreateWalletArgs<ID>\n): Wallet<ID> {\n  const [id, creationOptions] = args;\n\n  switch (true) {\n    /**\n     * SMART WALLET\n     */\n    case id === \"smart\": {\n      return smartWallet(\n        creationOptions as CreateWalletArgs<\"smart\">[1],\n      ) as Wallet<ID>;\n    }\n    /**\n     * IN-APP WALLET\n     */\n    case id === \"embedded\" || id === \"inApp\": {\n      return inAppWallet(\n        creationOptions as CreateWalletArgs<\"inApp\">[1],\n      ) as Wallet<ID>;\n    }\n\n    /**\n     * COINBASE WALLET VIA SDK\n     * -> if no injected coinbase found, we'll use the coinbase SDK\n     */\n    case id === COINBASE: {\n      const options = creationOptions as CreateWalletArgs<typeof COINBASE>[1];\n      return coinbaseWalletSDK({\n        createOptions: options,\n        providerFactory: () => getCoinbaseWebProvider(options),\n        onConnectRequested: async (provider) => {\n          // on the web, make sure to show the coinbase popup IMMEDIATELY on connection requested\n          // otherwise the popup might get blocked in safari\n          // TODO awaiting the provider is fast only thanks to preloading that happens in our components\n          // these probably need to actually imported / created synchronously to be used headless properly\n          const { showCoinbasePopup } = await import(\"./coinbase/utils.js\");\n          return showCoinbasePopup(provider);\n        },\n      }) as Wallet<ID>;\n    }\n    case isEcosystemWallet(id):\n      return ecosystemWallet(\n        ...(args as CreateWalletArgs<EcosystemWalletId>),\n      ) as Wallet<ID>;\n\n    /**\n     * WALLET CONNECT AND INJECTED WALLETS + walletConnect standalone\n     */\n    default: {\n      const emitter = createWalletEmitter<ID>();\n      let account: Account | undefined = undefined;\n      let chain: Chain | undefined = undefined;\n\n      const unsubscribeChain = emitter.subscribe(\"chainChanged\", (newChain) => {\n        chain = newChain;\n      });\n\n      function reset() {\n        account = undefined;\n        chain = undefined;\n      }\n\n      let handleDisconnect = async () => {};\n\n      const unsubscribeDisconnect = emitter.subscribe(\"disconnect\", () => {\n        reset();\n        unsubscribeChain();\n        unsubscribeDisconnect();\n      });\n\n      emitter.subscribe(\"accountChanged\", (_account) => {\n        account = _account;\n      });\n\n      let handleSwitchChain: (chain: Chain) => Promise<void> = async () => {\n        throw new Error(\"Not implemented yet\");\n      };\n\n      // on mobile, deeplink to the wallet app for session handling\n      const sessionHandler = isMobile()\n        ? (uri: string) => openWindow(uri)\n        : undefined;\n\n      const wallet: Wallet<ID> = {\n        id,\n        subscribe: emitter.subscribe,\n        getConfig: () => args[1],\n        getChain: () => chain,\n        getAccount: () => account,\n        autoConnect: async (\n          options: WalletAutoConnectionOption<\n            WCSupportedWalletIds | InjectedSupportedWalletIds\n          >,\n        ) => {\n          const { injectedProvider } = await import(\"./injected/mipdStore.js\");\n          // injected wallet priority for autoConnect\n          if (id !== \"walletConnect\" && injectedProvider(id)) {\n            const { autoConnectInjectedWallet } = await import(\n              \"./injected/index.js\"\n            );\n\n            const [\n              connectedAccount,\n              connectedChain,\n              doDisconnect,\n              doSwitchChain,\n            ] = await autoConnectInjectedWallet(\n              id as InjectedSupportedWalletIds,\n              emitter,\n              options.chain,\n            );\n            // set the states\n            account = connectedAccount;\n            chain = connectedChain;\n            handleDisconnect = doDisconnect;\n            handleSwitchChain = doSwitchChain;\n            trackConnect({\n              client: options.client,\n              walletType: id,\n              walletAddress: account.address,\n            });\n            // return account\n            return account;\n          }\n\n          if (options && \"client\" in options) {\n            const { autoConnectWC } = await import(\n              \"./wallet-connect/controller.js\"\n            );\n\n            const [\n              connectedAccount,\n              connectedChain,\n              doDisconnect,\n              doSwitchChain,\n            ] = await autoConnectWC(\n              options,\n              emitter,\n              wallet.id as WCSupportedWalletIds,\n              webLocalStorage,\n              sessionHandler,\n            );\n            // set the states\n            account = connectedAccount;\n            chain = connectedChain;\n            handleDisconnect = doDisconnect;\n            handleSwitchChain = doSwitchChain;\n            trackConnect({\n              client: options.client,\n              walletType: id,\n              walletAddress: account.address,\n            });\n            // return account\n            return account;\n          }\n          throw new Error(\"Failed to auto connect\");\n        },\n        connect: async (options) => {\n          async function wcConnect(wcOptions: WCConnectOptions) {\n            const { connectWC } = await import(\n              \"./wallet-connect/controller.js\"\n            );\n\n            const [\n              connectedAccount,\n              connectedChain,\n              doDisconnect,\n              doSwitchChain,\n            ] = await connectWC(\n              wcOptions,\n              emitter,\n              wallet.id as WCSupportedWalletIds | \"walletConnect\",\n              webLocalStorage,\n              sessionHandler,\n            );\n            // set the states\n            account = connectedAccount;\n            chain = connectedChain;\n            handleDisconnect = doDisconnect;\n            handleSwitchChain = doSwitchChain;\n            trackConnect({\n              client: wcOptions.client,\n              walletType: id,\n              walletAddress: account.address,\n            });\n            return account;\n          }\n\n          if (id === \"walletConnect\") {\n            const { client, chain: _chain, ...walletConnectOptions } = options;\n\n            return wcConnect({\n              client,\n              chain: _chain,\n              walletConnect: {\n                ...walletConnectOptions,\n              },\n            });\n          }\n\n          // prefer walletconnect over injected if explicitely passing walletConnect options\n          const forceWalletConnectOption =\n            options && \"walletConnect\" in options;\n\n          const { injectedProvider } = await import(\"./injected/mipdStore.js\");\n          if (injectedProvider(id) && !forceWalletConnectOption) {\n            const { connectInjectedWallet } = await import(\n              \"./injected/index.js\"\n            );\n\n            const [\n              connectedAccount,\n              connectedChain,\n              doDisconnect,\n              doSwitchChain,\n            ] = await connectInjectedWallet(\n              id as InjectedSupportedWalletIds,\n              options as InjectedConnectOptions,\n              emitter,\n            );\n            // set the states\n            account = connectedAccount;\n            chain = connectedChain;\n            handleDisconnect = doDisconnect;\n            handleSwitchChain = doSwitchChain;\n            trackConnect({\n              client: options.client,\n              walletType: id,\n              walletAddress: account.address,\n            });\n            // return account\n            return account;\n          }\n\n          if (options && \"client\" in options) {\n            return wcConnect(options);\n          }\n          throw new Error(\"Failed to connect\");\n        },\n        // these get overridden in connect and autoConnect\n        disconnect: async () => {\n          reset();\n          await handleDisconnect();\n        },\n        switchChain: (c) => handleSwitchChain(c),\n      };\n      return wallet;\n    }\n  }\n}\n\n/**\n * Creates a wallet that allows connecting to any wallet that supports the WalletConnect protocol.\n * @returns The created smart wallet.\n * @example\n * ```ts\n * import { walletConnect } from \"thirdweb/wallets\";\n *\n * const wallet = walletConnect();\n *\n * const account = await wallet.connect({\n *  client\n * });\n * ```\n * @wallet\n */\nexport function walletConnect() {\n  return createWallet(\"walletConnect\");\n}\n"],
  "mappings": "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",
  "names": []
}
