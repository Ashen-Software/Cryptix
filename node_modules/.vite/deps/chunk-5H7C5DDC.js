import {
  prepareContractCall
} from "./chunk-J6SGVPAD.js";
import {
  getDefaultGasOverrides,
  resolvePromisedValue,
  toSerializableTransaction
} from "./chunk-JRJTWVCA.js";
import {
  DEBUG,
  DEFAULT_ACCOUNT_FACTORY,
  DUMMY_SIGNATURE,
  ENTRYPOINT_ADDRESS_v0_6,
  MANAGED_ACCOUNT_GAS_BUFFER,
  getDefaultBundlerUrl,
  getDefaultPaymasterUrl
} from "./chunk-5E5FQUOC.js";
import {
  parseTypedData
} from "./chunk-NPZ6GJMS.js";
import {
  getContract
} from "./chunk-AOWXXJZS.js";
import {
  readContract
} from "./chunk-OEOA3HT2.js";
import {
  encodeAbiParameters
} from "./chunk-3NAETAKT.js";
import {
  encodeEventTopics,
  hashTypedData,
  parseEventLogs,
  toRlp
} from "./chunk-BSASUUNP.js";
import {
  hexToBytes,
  keccak256
} from "./chunk-MQIGPFEC.js";
import {
  hexToBigInt,
  isHex,
  numberToHex,
  stringToHex,
  toHex,
  uint8ArrayToHex
} from "./chunk-3JG4JMZX.js";
import {
  isContractDeployed
} from "./chunk-3A6EJQH3.js";
import {
  getRpcClient
} from "./chunk-HGWZNQ5H.js";
import {
  stringify
} from "./chunk-TRL57KBW.js";
import {
  getCachedChain
} from "./chunk-NMVKDFRL.js";
import {
  getClientFetch,
  isThirdwebUrl
} from "./chunk-CVWITOXT.js";
import {
  concat,
  decodeErrorResult,
  parseAbiItem,
  toSignatureHash
} from "./chunk-ZAXCNZIK.js";
import {
  encode
} from "./chunk-NCXSBGTZ.js";

// node_modules/thirdweb/dist/esm/utils/bigint.js
function toBigInt(value) {
  if (["string", "number"].includes(typeof value) && !Number.isInteger(Number(value))) {
    throw new Error(`Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`);
  }
  if (value instanceof Uint8Array) {
    return BigInt(uint8ArrayToHex(value));
  }
  return BigInt(value);
}

// node_modules/thirdweb/dist/esm/utils/encoding/helpers/concat-hex.js
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}

// node_modules/thirdweb/dist/esm/transaction/actions/zksync/getEip721Domain.js
var gasPerPubdataDefault = 50000n;
var getEip712Domain = (transaction) => {
  const message = transactionToMessage(transaction);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: transaction.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message
  };
};
function transactionToMessage(transaction) {
  const { gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  return {
    txType: 113n,
    from: BigInt(from),
    to: to ? BigInt(to) : 0n,
    gasLimit: gas ?? 0n,
    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,
    maxFeePerGas: maxFeePerGas ?? 0n,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
    paymaster: paymaster ? BigInt(paymaster) : 0n,
    nonce: nonce ? BigInt(nonce) : 0n,
    value: value ?? 0n,
    data: data ? data : "0x0",
    // TODO suport factoryDeps
    factoryDeps: [],
    paymasterInput: paymasterInput ? paymasterInput : "0x"
  };
}

// node_modules/thirdweb/dist/esm/transaction/actions/zksync/send-eip712-transaction.js
async function signEip712Transaction(options) {
  const { account, eip712Transaction, chainId } = options;
  const eip712Domain = getEip712Domain(eip712Transaction);
  const customSignature = await account.signTypedData({
    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly
    ...eip712Domain
  });
  return serializeTransactionEIP712({
    ...eip712Transaction,
    chainId,
    customSignature
  });
}
async function populateEip712Transaction(options) {
  const { account, transaction } = options;
  let [data, to, value, gas, maxFeePerGas, maxPriorityFeePerGas, gasPerPubdata] = await Promise.all([
    encode(transaction),
    resolvePromisedValue(transaction.to),
    resolvePromisedValue(transaction.value),
    resolvePromisedValue(transaction.gas),
    resolvePromisedValue(transaction.maxFeePerGas),
    resolvePromisedValue(transaction.maxPriorityFeePerGas),
    resolvePromisedValue(transaction.eip712).then((eip712) => eip712 == null ? void 0 : eip712.gasPerPubdata)
  ]);
  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {
    const rpc = getRpcClient(transaction);
    const result = await rpc({
      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types
      method: "zks_estimateFee",
      params: [
        {
          from: account.address,
          to,
          data,
          value: value ? numberToHex(value) : void 0
          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types
        }
      ]
    });
    gas = toBigInt(result.gas_limit);
    const baseFee = toBigInt(result.max_fee_per_gas);
    maxFeePerGas = baseFee * 2n;
    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;
    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit);
  }
  const serializableTransaction = await toSerializableTransaction({
    transaction: {
      ...transaction,
      gas,
      maxFeePerGas,
      maxPriorityFeePerGas
    },
    from: account.address
  });
  return {
    ...serializableTransaction,
    ...transaction.eip712,
    gasPerPubdata,
    from: account.address
  };
}
function serializeTransactionEIP712(transaction) {
  const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  const serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x0",
    toHex(chainId),
    toHex(""),
    toHex(""),
    toHex(chainId),
    from ?? "0x",
    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),
    factoryDeps ?? [],
    customSignature ?? "0x",
    // EIP712 signature
    paymaster && paymasterInput ? [paymaster, paymasterInput] : []
  ];
  return concatHex(["0x71", toRlp(serializedTransaction)]);
}

// node_modules/thirdweb/dist/esm/event/actions/parse-logs.js
function parseEventLogs2(options) {
  const { logs, events, strict } = options;
  return parseEventLogs({
    logs,
    abi: events.map((e) => e.abiEvent),
    strict
  });
}

// node_modules/thirdweb/dist/esm/event/utils.js
function isAbiEvent(item) {
  return !!(item && typeof item === "object" && "type" in item && item.type === "event");
}

// node_modules/thirdweb/dist/esm/event/prepare-event.js
function prepareEvent(options) {
  const { signature } = options;
  let resolvedSignature;
  if (isAbiEvent(signature)) {
    resolvedSignature = signature;
  } else {
    resolvedSignature = parseAbiItem(signature);
  }
  return {
    abiEvent: resolvedSignature,
    hash: toSignatureHash(resolvedSignature),
    // @ts-expect-error - TODO: investiagte why this complains, it works fine however
    topics: encodeEventTopics({
      abi: [resolvedSignature],
      args: options.filters
    })
  };
}

// node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js
function userOperationRevertReasonEvent(filters = {}) {
  return prepareEvent({
    signature: "event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)",
    filters
  });
}

// node_modules/thirdweb/dist/esm/wallets/smart/lib/utils.js
var generateRandomUint192 = () => {
  const rand1 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand2 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand3 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand4 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand5 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand6 = BigInt(Math.floor(Math.random() * 4294967296));
  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;
};
var randomNonce = () => {
  return BigInt(concat([numberToHex(generateRandomUint192()), "0x0000000000000000"]));
};
function hexlifyUserOp(userOp) {
  return Object.fromEntries(Object.entries(userOp).map(([key, val]) => [
    key,
    // turn any value that's not hex into hex
    isHex(val) ? val : toHex(val)
  ]));
}
function isNativeAAChain(chain) {
  return chain.id === 324 || chain.id === 300 || chain.id === 302;
}

// node_modules/thirdweb/dist/esm/wallets/smart/lib/bundler.js
async function bundleUserOp(args) {
  var _a;
  return sendBundlerRequest({
    ...args,
    operation: "eth_sendUserOperation",
    params: [
      hexlifyUserOp(args.userOp),
      ((_a = args.options.overrides) == null ? void 0 : _a.entrypointAddress) ?? ENTRYPOINT_ADDRESS_v0_6
    ]
  });
}
async function estimateUserOpGas(args) {
  var _a;
  const res = await sendBundlerRequest({
    ...args,
    operation: "eth_estimateUserOperationGas",
    params: [
      hexlifyUserOp(args.userOp),
      ((_a = args.options.overrides) == null ? void 0 : _a.entrypointAddress) ?? ENTRYPOINT_ADDRESS_v0_6
    ]
  });
  return {
    preVerificationGas: hexToBigInt(res.preVerificationGas),
    verificationGas: hexToBigInt(res.verificationGas),
    verificationGasLimit: hexToBigInt(res.verificationGasLimit),
    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER
  };
}
async function getUserOpGasPrice(args) {
  const res = await sendBundlerRequest({
    ...args,
    operation: "thirdweb_getUserOperationGasPrice",
    params: []
  });
  return {
    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),
    maxFeePerGas: hexToBigInt(res.maxFeePerGas)
  };
}
async function getUserOpReceipt(args) {
  var _a, _b;
  const res = await sendBundlerRequest({
    ...args,
    operation: "eth_getUserOperationReceipt",
    params: [args.userOpHash]
  });
  if (!res) {
    return void 0;
  }
  if (res.success === false) {
    const logs = parseEventLogs2({
      events: [userOperationRevertReasonEvent()],
      logs: res.logs
    });
    const revertReason = (_b = (_a = logs[0]) == null ? void 0 : _a.args) == null ? void 0 : _b.revertReason;
    if (!revertReason) {
      throw new Error(`UserOp failed at txHash: ${res.transactionHash}`);
    }
    const revertMsg = decodeErrorResult({
      data: revertReason
    });
    throw new Error(`UserOp failed with reason: '${revertMsg.args.join(",")}' at txHash: ${res.transactionHash}`);
  }
  return res.receipt;
}
async function getZkPaymasterData(args) {
  const res = await sendBundlerRequest({
    options: args.options,
    operation: "zk_paymasterData",
    params: [args.transaction]
  });
  return {
    paymaster: res.paymaster,
    paymasterInput: res.paymasterInput
  };
}
async function broadcastZkTransaction(args) {
  const res = await sendBundlerRequest({
    options: args.options,
    operation: "zk_broadcastTransaction",
    params: [
      {
        ...args.transaction,
        signedTransaction: args.signedTransaction
      }
    ]
  });
  return {
    transactionHash: res.transactionHash
  };
}
async function sendBundlerRequest(args) {
  var _a;
  const { options, operation, params } = args;
  if (DEBUG) {
    console.debug(`>>> sending ${operation} with payload:`, params);
  }
  const bundlerUrl = ((_a = options.overrides) == null ? void 0 : _a.bundlerUrl) ?? getDefaultBundlerUrl(options.chain);
  const fetchWithHeaders = getClientFetch(options.client);
  const response = await fetchWithHeaders(bundlerUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: stringify({
      jsonrpc: "2.0",
      id: 1,
      method: operation,
      params
    })
  });
  const res = await response.json();
  if (!response.ok || res.error) {
    let error = res.error || response.statusText;
    if (typeof error === "object") {
      error = JSON.stringify(error);
    }
    const code = res.code || "UNKNOWN";
    throw new Error(`${operation} error: ${error}
Status: ${response.status}
Code: ${code}`);
  }
  if (DEBUG) {
    console.debug(`<<< ${operation} result:`, res);
  }
  return res.result;
}

// node_modules/thirdweb/dist/esm/wallets/smart/lib/calls.js
async function predictAddress(factoryContract, options) {
  var _a, _b, _c;
  if ((_a = options.overrides) == null ? void 0 : _a.predictAddress) {
    return options.overrides.predictAddress(factoryContract);
  }
  if ((_b = options.overrides) == null ? void 0 : _b.accountAddress) {
    return options.overrides.accountAddress;
  }
  const adminAddress = options.personalAccountAddress;
  if (!adminAddress) {
    throw new Error("Account address is required to predict the smart wallet address.");
  }
  const extraData = stringToHex(((_c = options.overrides) == null ? void 0 : _c.accountSalt) ?? "");
  return readContract({
    contract: factoryContract,
    method: "function getAddress(address, bytes) returns (address)",
    params: [adminAddress, extraData]
  });
}
function prepareCreateAccount(args) {
  var _a, _b;
  const { factoryContract, options } = args;
  if ((_a = options.overrides) == null ? void 0 : _a.createAccount) {
    return options.overrides.createAccount(factoryContract);
  }
  return prepareContractCall({
    contract: factoryContract,
    method: "function createAccount(address, bytes) returns (address)",
    params: [
      options.personalAccount.address,
      stringToHex(((_b = options.overrides) == null ? void 0 : _b.accountSalt) ?? "")
    ]
  });
}
function prepareExecute(args) {
  var _a;
  const { accountContract, options, transaction } = args;
  if ((_a = options.overrides) == null ? void 0 : _a.execute) {
    return options.overrides.execute(accountContract, transaction);
  }
  return prepareContractCall({
    contract: accountContract,
    method: "function execute(address, uint256, bytes)",
    params: [
      transaction.to || "",
      transaction.value || 0n,
      transaction.data || "0x"
    ]
  });
}
function prepareBatchExecute(args) {
  var _a;
  const { accountContract, options, transactions } = args;
  if ((_a = options.overrides) == null ? void 0 : _a.executeBatch) {
    return options.overrides.executeBatch(accountContract, transactions);
  }
  return prepareContractCall({
    contract: accountContract,
    method: "function executeBatch(address[], uint256[], bytes[])",
    params: [
      transactions.map((tx) => tx.to || ""),
      transactions.map((tx) => tx.value || 0n),
      transactions.map((tx) => tx.data || "0x")
    ]
  });
}

// node_modules/thirdweb/dist/esm/wallets/smart/lib/paymaster.js
async function getPaymasterAndData(args) {
  var _a, _b, _c, _d;
  const { userOp, options } = args;
  if ((_a = options.overrides) == null ? void 0 : _a.paymaster) {
    return (_b = options.overrides) == null ? void 0 : _b.paymaster(userOp);
  }
  const headers = {
    "Content-Type": "application/json"
  };
  const client = options.client;
  const paymasterUrl = getDefaultPaymasterUrl(options.chain);
  const entrypoint = ((_c = options.overrides) == null ? void 0 : _c.entrypointAddress) ?? ENTRYPOINT_ADDRESS_v0_6;
  const fetchWithHeaders = getClientFetch(client);
  const response = await fetchWithHeaders(paymasterUrl, {
    method: "POST",
    headers,
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "pm_sponsorUserOperation",
      params: [hexlifyUserOp(userOp), entrypoint]
    })
  });
  const res = await response.json();
  if (!response.ok) {
    const error2 = res.error || response.statusText;
    const code = res.code || "UNKNOWN";
    throw new Error(`Paymaster error: ${error2}
Status: ${response.status}
Code: ${code}`);
  }
  if (DEBUG) {
    console.debug("Paymaster result:", res);
  }
  if (res.result) {
    if (typeof res.result === "string") {
      return {
        paymasterAndData: res.result
      };
    }
    return {
      paymasterAndData: res.result.paymasterAndData,
      verificationGasLimit: res.result.verificationGasLimit ? hexToBigInt(res.result.verificationGasLimit) : void 0,
      preVerificationGas: res.result.preVerificationGas ? hexToBigInt(res.result.preVerificationGas) : void 0,
      callGasLimit: res.result.callGasLimit ? hexToBigInt(res.result.callGasLimit) : void 0
    };
  }
  const error = ((_d = res.error) == null ? void 0 : _d.message) || res.error || response.statusText || "unknown error";
  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);
}

// node_modules/thirdweb/dist/esm/wallets/smart/lib/userop.js
async function createUnsignedUserOp(args) {
  var _a;
  const { executeTx, options } = args;
  const isDeployed = await isContractDeployed(options.accountContract);
  const initCode = isDeployed ? "0x" : await getAccountInitCode(options);
  const callData = await encode(executeTx);
  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;
  const bundlerUrl = ((_a = options.overrides) == null ? void 0 : _a.bundlerUrl) ?? getDefaultBundlerUrl(options.chain);
  if (isThirdwebUrl(bundlerUrl)) {
    const bundlerGasPrice = await getUserOpGasPrice({
      options
    });
    maxFeePerGas = bundlerGasPrice.maxFeePerGas;
    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;
  } else {
    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] = await Promise.all([
      resolvePromisedValue(maxFeePerGas),
      resolvePromisedValue(maxPriorityFeePerGas)
    ]);
    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {
      maxFeePerGas = resolvedMaxFeePerGas;
      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;
    } else {
      const feeData = await getDefaultGasOverrides(options.client, options.chain);
      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;
      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;
    }
  }
  const nonce = randomNonce();
  const partialOp = {
    sender: options.accountContract.address,
    nonce,
    initCode,
    callData,
    maxFeePerGas,
    maxPriorityFeePerGas,
    callGasLimit: 0n,
    verificationGasLimit: 0n,
    preVerificationGas: 0n,
    paymasterAndData: "0x",
    signature: DUMMY_SIGNATURE
  };
  if (options.sponsorGas) {
    const paymasterResult = await getPaymasterAndData({
      userOp: partialOp,
      options
    });
    const paymasterAndData = paymasterResult.paymasterAndData;
    if (paymasterAndData && paymasterAndData !== "0x") {
      partialOp.paymasterAndData = paymasterAndData;
    }
    if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {
      partialOp.callGasLimit = paymasterResult.callGasLimit;
      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;
      partialOp.preVerificationGas = paymasterResult.preVerificationGas;
    } else {
      const estimates = await estimateUserOpGas({
        userOp: partialOp,
        options
      });
      partialOp.callGasLimit = estimates.callGasLimit;
      partialOp.verificationGasLimit = estimates.verificationGasLimit;
      partialOp.preVerificationGas = estimates.preVerificationGas;
      if (paymasterAndData && paymasterAndData !== "0x") {
        const paymasterResult2 = await getPaymasterAndData({
          userOp: partialOp,
          options
        });
        if (paymasterResult2.paymasterAndData && paymasterResult2.paymasterAndData !== "0x") {
          partialOp.paymasterAndData = paymasterResult2.paymasterAndData;
        }
      }
    }
  } else {
    const estimates = await estimateUserOpGas({
      userOp: partialOp,
      options
    });
    partialOp.callGasLimit = estimates.callGasLimit;
    partialOp.verificationGasLimit = estimates.verificationGasLimit;
    partialOp.preVerificationGas = estimates.preVerificationGas;
  }
  return {
    ...partialOp,
    signature: "0x"
  };
}
async function signUserOp(args) {
  var _a;
  const { userOp, options } = args;
  const userOpHash = getUserOpHash({
    userOp,
    entryPoint: ((_a = options.overrides) == null ? void 0 : _a.entrypointAddress) || ENTRYPOINT_ADDRESS_v0_6,
    chainId: options.chain.id
  });
  if (options.personalAccount.signMessage) {
    const signature = await options.personalAccount.signMessage({
      message: {
        raw: hexToBytes(userOpHash)
      }
    });
    return {
      ...userOp,
      signature
    };
  }
  throw new Error("signMessage not implemented in signingAccount");
}
async function getAccountInitCode(options) {
  const { factoryContract } = options;
  const deployTx = prepareCreateAccount({
    factoryContract,
    options
  });
  return concat([factoryContract.address, await encode(deployTx)]);
}
function getUserOpHash(args) {
  const { userOp, entryPoint, chainId } = args;
  const hashedInitCode = keccak256(userOp.initCode);
  const hashedCallData = keccak256(userOp.callData);
  const hashedPaymasterAndData = keccak256(userOp.paymasterAndData);
  const packedUserOp = encodeAbiParameters([
    { type: "address" },
    { type: "uint256" },
    { type: "bytes32" },
    { type: "bytes32" },
    { type: "uint256" },
    { type: "uint256" },
    { type: "uint256" },
    { type: "uint256" },
    { type: "uint256" },
    { type: "bytes32" }
  ], [
    userOp.sender,
    userOp.nonce,
    hashedInitCode,
    hashedCallData,
    userOp.callGasLimit,
    userOp.verificationGasLimit,
    userOp.preVerificationGas,
    userOp.maxFeePerGas,
    userOp.maxPriorityFeePerGas,
    hashedPaymasterAndData
  ]);
  const encoded = encodeAbiParameters([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [keccak256(packedUserOp), entryPoint, BigInt(chainId)]);
  return keccak256(encoded);
}

// node_modules/thirdweb/dist/esm/wallets/smart/index.js
function isSmartWallet(wallet) {
  return wallet.id === "smart";
}
var personalAccountToSmartAccountMap = /* @__PURE__ */ new WeakMap();
var smartWalletToPersonalAccountMap = /* @__PURE__ */ new WeakMap();
async function connectSmartWallet(wallet, connectionOptions, creationOptions) {
  const { personalAccount, client, chain: connectChain } = connectionOptions;
  if (!personalAccount) {
    throw new Error("Personal wallet does not have an account");
  }
  const options = creationOptions;
  const factoryAddress = options.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY;
  const chain = connectChain ?? options.chain;
  const sponsorGas = "gasless" in options ? options.gasless : options.sponsorGas;
  if (isNativeAAChain(chain)) {
    return [
      createZkSyncAccount({
        creationOptions,
        connectionOptions,
        chain,
        sponsorGas
      }),
      chain
    ];
  }
  const factoryContract = getContract({
    client,
    address: factoryAddress,
    chain
  });
  const accountAddress = await predictAddress(factoryContract, {
    personalAccountAddress: personalAccount.address,
    ...options
  }).then((address) => address).catch((err) => {
    throw new Error(`Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}. Are you on the right chain?`, { cause: err });
  });
  const accountContract = getContract({
    client,
    address: accountAddress,
    chain
  });
  const account = await createSmartAccount({
    ...options,
    chain,
    sponsorGas,
    personalAccount,
    accountContract,
    factoryContract,
    client
  });
  personalAccountToSmartAccountMap.set(personalAccount, wallet);
  smartWalletToPersonalAccountMap.set(wallet, personalAccount);
  return [account, chain];
}
async function disconnectSmartWallet(wallet) {
  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);
  if (personalAccount) {
    personalAccountToSmartAccountMap.delete(personalAccount);
    smartWalletToPersonalAccountMap.delete(wallet);
  }
}
async function createSmartAccount(options) {
  const { accountContract } = options;
  const account = {
    address: accountContract.address,
    async sendTransaction(transaction) {
      const executeTx = prepareExecute({
        accountContract,
        options,
        transaction
      });
      return _sendUserOp({
        executeTx,
        options
      });
    },
    async sendBatchTransaction(transactions) {
      const executeTx = prepareBatchExecute({
        accountContract,
        options,
        transactions
      });
      return _sendUserOp({
        executeTx,
        options
      });
    },
    async signMessage({ message }) {
      const [{ isContractDeployed: isContractDeployed2 }, { readContract: readContract2 }, { encodeAbiParameters: encodeAbiParameters2 }, { hashMessage }, { checkContractWalletSignature }] = await Promise.all([
        import("./is-contract-deployed-JCKRZQSH.js"),
        import("./read-contract-45JU6MUZ.js"),
        import("./encodeAbiParameters-7LK2QDPK.js"),
        import("./hashMessage-2ZZWIMP3.js"),
        import("./checkContractWalletSignature-ZTI4ISWP.js")
      ]);
      const isDeployed = await isContractDeployed2(accountContract);
      if (!isDeployed) {
        console.log("Account contract not deployed yet. Deploying account before signing message");
        await _deployAccount({
          options,
          account,
          accountContract
        });
      }
      const originalMsgHash = hashMessage(message);
      let factorySupports712 = false;
      try {
        await readContract2({
          contract: accountContract,
          method: "function getMessageHash(bytes32 _hash) public view returns (bytes32)",
          params: [originalMsgHash]
        });
        factorySupports712 = true;
      } catch (e) {
      }
      let sig;
      if (factorySupports712) {
        const wrappedMessageHash = encodeAbiParameters2([{ type: "bytes32" }], [originalMsgHash]);
        sig = await options.personalAccount.signTypedData({
          domain: {
            name: "Account",
            version: "1",
            chainId: options.chain.id,
            verifyingContract: accountContract.address
          },
          primaryType: "AccountMessage",
          types: { AccountMessage: [{ name: "message", type: "bytes" }] },
          message: { message: wrappedMessageHash }
        });
      } else {
        sig = await options.personalAccount.signMessage({ message });
      }
      const isValid = await checkContractWalletSignature({
        contract: accountContract,
        message,
        signature: sig
      });
      if (isValid) {
        return sig;
      }
      throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.");
    },
    async signTypedData(_typedData) {
      var _a, _b, _c;
      const typedData = parseTypedData(_typedData);
      const [{ isContractDeployed: isContractDeployed2 }, { readContract: readContract2 }, { encodeAbiParameters: encodeAbiParameters2 }, { checkContractWalletSignedTypedData }] = await Promise.all([
        import("./is-contract-deployed-JCKRZQSH.js"),
        import("./read-contract-45JU6MUZ.js"),
        import("./encodeAbiParameters-7LK2QDPK.js"),
        import("./checkContractWalletSignedTypedData-OMTPF3HI.js")
      ]);
      const isSelfVerifyingContract = ((_b = (_a = typedData.domain) == null ? void 0 : _a.verifyingContract) == null ? void 0 : _b.toLowerCase()) === ((_c = accountContract.address) == null ? void 0 : _c.toLowerCase());
      if (isSelfVerifyingContract) {
        return options.personalAccount.signTypedData(typedData);
      }
      const isDeployed = await isContractDeployed2(accountContract);
      if (!isDeployed) {
        console.log("Account contract not deployed yet. Deploying account before signing message");
        await _deployAccount({
          options,
          account,
          accountContract
        });
      }
      const originalMsgHash = hashTypedData(typedData);
      let factorySupports712 = false;
      try {
        await readContract2({
          contract: accountContract,
          method: "function getMessageHash(bytes32 _hash) public view returns (bytes32)",
          params: [originalMsgHash]
        });
        factorySupports712 = true;
      } catch (e) {
      }
      let sig;
      if (factorySupports712) {
        const wrappedMessageHash = encodeAbiParameters2([{ type: "bytes32" }], [originalMsgHash]);
        sig = await options.personalAccount.signTypedData({
          domain: {
            name: "Account",
            version: "1",
            chainId: options.chain.id,
            verifyingContract: accountContract.address
          },
          primaryType: "AccountMessage",
          types: { AccountMessage: [{ name: "message", type: "bytes" }] },
          message: { message: wrappedMessageHash }
        });
      } else {
        sig = await options.personalAccount.signTypedData(typedData);
      }
      const isValid = await checkContractWalletSignedTypedData({
        contract: accountContract,
        data: typedData,
        signature: sig
      });
      if (isValid) {
        return sig;
      }
      throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.");
    },
    async onTransactionRequested(transaction) {
      var _a, _b;
      return (_b = (_a = options.personalAccount).onTransactionRequested) == null ? void 0 : _b.call(_a, transaction);
    }
  };
  return account;
}
function createZkSyncAccount(args) {
  const { creationOptions, connectionOptions, chain } = args;
  const account = {
    address: connectionOptions.personalAccount.address,
    async sendTransaction(transaction) {
      const prepTx = {
        data: transaction.data,
        to: transaction.to ?? void 0,
        value: transaction.value ?? 0n,
        chain: getCachedChain(transaction.chainId),
        client: connectionOptions.client
      };
      let serializableTransaction = await populateEip712Transaction({
        account,
        transaction: prepTx
      });
      if (args.sponsorGas) {
        const pmData = await getZkPaymasterData({
          options: {
            client: connectionOptions.client,
            overrides: creationOptions.overrides,
            chain
          },
          transaction: serializableTransaction
        });
        serializableTransaction = {
          ...serializableTransaction,
          ...pmData
        };
      }
      const signedTransaction = await signEip712Transaction({
        account,
        chainId: chain.id,
        eip712Transaction: serializableTransaction
      });
      const txHash = await broadcastZkTransaction({
        options: {
          client: connectionOptions.client,
          overrides: creationOptions.overrides,
          chain
        },
        transaction: serializableTransaction,
        signedTransaction
      });
      return {
        transactionHash: txHash.transactionHash,
        client: connectionOptions.client,
        chain
      };
    },
    async signMessage({ message }) {
      return connectionOptions.personalAccount.signMessage({ message });
    },
    async signTypedData(_typedData) {
      const typedData = parseTypedData(_typedData);
      return connectionOptions.personalAccount.signTypedData(typedData);
    },
    async onTransactionRequested(transaction) {
      var _a, _b;
      return (_b = (_a = connectionOptions.personalAccount).onTransactionRequested) == null ? void 0 : _b.call(_a, transaction);
    }
  };
  return account;
}
async function _deployAccount(args) {
  const { options, account, accountContract } = args;
  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([
    import("./send-transaction-7WFJB6NE.js"),
    import("./prepare-transaction-2PFGYZIU.js")
  ]);
  const dummyTx = prepareTransaction({
    client: options.client,
    chain: options.chain,
    to: accountContract.address,
    value: 0n,
    gas: 50000n
    // force gas to avoid simulation error
  });
  const deployResult = await sendTransaction({
    transaction: dummyTx,
    account
  });
  return deployResult;
}
async function _sendUserOp(args) {
  const { executeTx, options } = args;
  const unsignedUserOp = await createUnsignedUserOp({
    executeTx,
    options
  });
  const signedUserOp = await signUserOp({
    options,
    userOp: unsignedUserOp
  });
  const userOpHash = await bundleUserOp({
    options,
    userOp: signedUserOp
  });
  const receipt = await waitForUserOpReceipt({
    options,
    userOpHash
  });
  return {
    client: options.client,
    chain: options.chain,
    transactionHash: receipt.transactionHash
  };
}
async function waitForUserOpReceipt(args) {
  const { options, userOpHash } = args;
  const timeout = 12e4;
  const interval = 1e3;
  const endtime = Date.now() + timeout;
  while (Date.now() < endtime) {
    const userOpReceipt = await getUserOpReceipt({ options, userOpHash });
    if (userOpReceipt) {
      return userOpReceipt;
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  throw new Error("Timeout waiting for userOp to be mined");
}

export {
  parseEventLogs2 as parseEventLogs,
  isAbiEvent,
  prepareEvent,
  isSmartWallet,
  personalAccountToSmartAccountMap,
  connectSmartWallet,
  disconnectSmartWallet
};
//# sourceMappingURL=chunk-5H7C5DDC.js.map
