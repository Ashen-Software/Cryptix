import {
  hashMessage
} from "./chunk-W6ZKVDX4.js";
import {
  createWallet,
  ecosystemWallet,
  inAppWallet,
  walletConnect
} from "./chunk-V3JKJ4BC.js";
import {
  DefaultWalletConnectRequestHandlers,
  createWalletConnectClient,
  createWalletConnectSession,
  disconnectWalletConnectSession,
  getActiveWalletConnectSessions
} from "./chunk-KDLM3TY7.js";
import "./chunk-ZALTVSMR.js";
import "./chunk-6CUAAARO.js";
import "./chunk-J5MF5TBC.js";
import "./chunk-7JYW3NMA.js";
import {
  getWalletBalance
} from "./chunk-62SMVODG.js";
import "./chunk-57DFWRZ3.js";
import "./chunk-ARW6RUHX.js";
import "./chunk-ZC4AZUFI.js";
import "./chunk-7IWBYC6P.js";
import "./chunk-44BVFM6H.js";
import "./chunk-G2O4Q37X.js";
import {
  getWalletInfo
} from "./chunk-SPFRZDZE.js";
import "./chunk-5R32MHFT.js";
import "./chunk-67YIWUOQ.js";
import "./chunk-D6UC7WRW.js";
import {
  injectedProvider
} from "./chunk-X54FPRZI.js";
import "./chunk-KVTKFUNA.js";
import "./chunk-JRJTWVCA.js";
import "./chunk-3SOZ25XX.js";
import {
  smartWallet
} from "./chunk-ZX3P6DTN.js";
import {
  createWalletEmitter
} from "./chunk-UTSWADTJ.js";
import "./chunk-5E5FQUOC.js";
import "./chunk-6MWCIZWZ.js";
import "./chunk-VDD3Y6TE.js";
import "./chunk-P4YNF73V.js";
import "./chunk-CXUCCAWN.js";
import "./chunk-LZH3KM55.js";
import "./chunk-ID6VDAA3.js";
import "./chunk-SYURM43K.js";
import "./chunk-M7UJHDZW.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  parseTypedData
} from "./chunk-NPZ6GJMS.js";
import "./chunk-DVPPDJAE.js";
import "./chunk-ZDQH37F2.js";
import "./chunk-AOWXXJZS.js";
import "./chunk-7YCMRA2U.js";
import "./chunk-OSZAYZBM.js";
import "./chunk-OEOA3HT2.js";
import "./chunk-2I6BQZFD.js";
import "./chunk-3NAETAKT.js";
import "./chunk-LW7EMTNJ.js";
import {
  assertTransactionEIP1559,
  assertTransactionEIP2930,
  assertTransactionLegacy,
  hashTypedData,
  publicKeyToAddress,
  serializeAccessList,
  serializeTransaction,
  toRlp
} from "./chunk-BSASUUNP.js";
import {
  keccak256
} from "./chunk-MQIGPFEC.js";
import "./chunk-NMJW5RZU.js";
import "./chunk-PZWOPBWI.js";
import {
  hexToBigInt,
  toHex
} from "./chunk-3JG4JMZX.js";
import "./chunk-GDDTQ4UI.js";
import "./chunk-3A6EJQH3.js";
import "./chunk-WF2UJPJG.js";
import {
  getRpcClient
} from "./chunk-HGWZNQ5H.js";
import "./chunk-TRL57KBW.js";
import {
  getCachedChain
} from "./chunk-NMVKDFRL.js";
import "./chunk-MHFR2GDE.js";
import "./chunk-CVWITOXT.js";
import "./chunk-SHWHM7JY.js";
import "./chunk-EZ4JTQAA.js";
import "./chunk-ZAXCNZIK.js";
import "./chunk-Z2F5LG57.js";
import {
  secp256k1
} from "./chunk-HK3KI3RB.js";
import "./chunk-EWAXOTDC.js";
import "./chunk-TEQAYQEZ.js";
import "./chunk-NCXSBGTZ.js";
import "./chunk-SEVZ5PBP.js";

// node_modules/thirdweb/dist/esm/utils/signatures/sign.js
function sign({ hash, privateKey }) {
  const { r, s, recovery } = secp256k1.sign(hash.slice(2), privateKey.slice(2));
  return {
    r: toHex(r),
    s: toHex(s),
    v: recovery ? 28n : 27n,
    yParity: recovery
  };
}

// node_modules/thirdweb/dist/esm/utils/encoding/helpers/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") {
      sliceLength++;
    } else {
      break;
    }
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right") {
      data = `${data}0`;
    }
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

// node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js
function serializeTransaction2(options) {
  const { transaction } = options;
  if (transaction.type === "eip4844" || // explicit type checks required for viem parity
  typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined") {
    return serializeTransaction(transaction);
  }
  if (transaction.type === "eip1559" || typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return serializeEIP1559Transaction({
      transaction
    });
  }
  if (transaction.type === "eip2930" || typeof transaction.gasPrice !== "undefined" && typeof transaction.accessList !== "undefined") {
    return serializeEIP2930Transaction({
      transaction
    });
  }
  if (transaction.type === "legacy" || typeof transaction.gasPrice !== "undefined") {
    return serializeTransactionLegacy({
      transaction
    });
  }
  throw new Error(`Invalid transaction to serialize.

${JSON.stringify(transaction, (_, v) => typeof v === "bigint" ? `${v.toString()}n` : v, 2)}`);
}
function serializeEIP1559Transaction(options) {
  assertTransactionEIP1559(options.transaction);
  const { transaction: { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, r, s, v, yParity } } = options;
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    // To fix when migrating to our own version of TransactionSerializable (the viem type is downgraded from Address to string when importing)
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray({ r, s, v, yParity })
  ];
  return `0x02${toRlp(serializedTransaction).slice(2)}`;
}
function serializeEIP2930Transaction(options) {
  assertTransactionEIP2930(options.transaction);
  const { transaction: { chainId, gas, gasPrice, nonce, to, value, accessList, data, r, s, v, yParity } } = options;
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray({ r, s, v, yParity })
  ];
  return `0x01${toRlp(serializedTransaction).slice(2)}`;
}
function serializeTransactionLegacy(options) {
  assertTransactionLegacy(options.transaction);
  const { chainId = 0, gas, data, nonce, to, value, gasPrice, r, s, v } = options.transaction;
  let serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x"
  ];
  if (typeof v !== "undefined") {
    const v_ = (() => {
      if (v >= 35n) {
        const inferredChainId = (v - 35n) / 2n;
        if (inferredChainId > 0)
          return v;
        return 27n + (v === 35n ? 0n : 1n);
      }
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + v - 27n);
      const v_2 = 27n + (v === 27n ? 0n : 1n);
      if (v !== v_2)
        throw new Error(`Invalid legacy signature value v: ${v}`);
      return v_2;
    })();
    if (typeof r === "undefined")
      throw new Error(`Invalid legacy signature value r: ${r}`);
    if (typeof s === "undefined")
      throw new Error(`Invalid legacy signature value s: ${s}`);
    serializedTransaction = [...serializedTransaction, toHex(v_), r, s];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(signature) {
  const { r, s, v, yParity } = signature;
  if (typeof r === "undefined")
    return [];
  if (typeof s === "undefined")
    return [];
  if (typeof v === "undefined" && typeof yParity === "undefined")
    return [];
  const yParity_ = (() => {
    if (yParity === 1 || yParity === 0)
      return yParity ? toHex(1) : "0x";
    if (typeof yParity !== "undefined")
      throw new Error(`Invalid signature value for yParity: ${yParity}`);
    if (v === 0n || v === 27n)
      return "0x";
    if (v === 1n || v === 28n)
      return toHex(1);
    throw new Error(`Invalid signature value v: ${v}`);
  })();
  return [yParity_, trim(r), trim(s)];
}

// node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
function signTransaction({ transaction, privateKey }) {
  if (transaction.type === "eip4844") {
    transaction = { ...transaction, sidecars: false };
  }
  const serializedTransaction = serializeTransaction2({ transaction });
  const signature = sign({
    hash: keccak256(serializedTransaction),
    privateKey
  });
  return serializeTransaction2({
    transaction: { ...transaction, ...signature }
  });
}

// node_modules/thirdweb/dist/esm/utils/signatures/signature-to-hex.js
function signatureToHex(signature) {
  const { r, s, v } = signature;
  const vHex = (() => {
    if (v === 27n) {
      return "1b";
    }
    if (v === 28n) {
      return "1c";
    }
    throw new Error("Invalid v value");
  })();
  return `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${vHex}`;
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
function signMessage({ message, privateKey }) {
  const signature = sign({ hash: hashMessage(message), privateKey });
  return signatureToHex(signature);
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
function signTypedData(options) {
  const { privateKey, ...typedData } = options;
  const parsedTypeData = parseTypedData(typedData);
  const signature = sign({
    hash: hashTypedData(parsedTypeData),
    // TODO: Implement native hashTypedData
    privateKey
  });
  return signatureToHex(signature);
}

// node_modules/thirdweb/dist/esm/wallets/private-key.js
function privateKeyToAccount(options) {
  const { client } = options;
  const privateKey = `0x${options.privateKey.replace(/^0x/, "")}`;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = {
    address,
    sendTransaction: async (tx) => {
      const rpcRequest = getRpcClient({
        client,
        chain: getCachedChain(tx.chainId)
      });
      const signedTx = signTransaction({
        transaction: tx,
        privateKey
      });
      const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);
      return {
        transactionHash
      };
    },
    signMessage: async ({ message }) => {
      return signMessage({
        message,
        privateKey
      });
    },
    signTypedData: async (_typedData) => {
      return signTypedData({
        ..._typedData,
        privateKey
      });
    },
    signTransaction: async (tx) => {
      return signTransaction({
        transaction: tx,
        privateKey
      });
    }
  };
  return account;
}

// node_modules/thirdweb/dist/esm/wallets/utils/generateAccount.js
async function generateAccount(options) {
  const privateKey = toHex(secp256k1.utils.randomPrivateKey());
  return privateKeyToAccount({ privateKey, client: options.client });
}

// node_modules/thirdweb/dist/esm/wallets/getAllWalletsList.js
async function getAllWalletsList() {
  return (await import("./wallet-infos-2ZJK7CCA.js")).default;
}

// node_modules/thirdweb/dist/esm/adapters/wallet-adapter.js
function createWalletAdapter(options) {
  const emitter = createWalletEmitter();
  let _chain = options.chain;
  return {
    id: "adapter",
    subscribe: emitter.subscribe,
    connect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    autoConnect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    disconnect: async () => {
      await options.onDisconnect();
      emitter.emit("disconnect", void 0);
    },
    getAccount() {
      return options.adaptedAccount;
    },
    getChain() {
      return _chain;
    },
    getConfig() {
      return options;
    },
    switchChain: async (chain) => {
      await options.switchChain(chain);
      _chain = chain;
      emitter.emit("chainChanged", chain);
    }
  };
}
export {
  DefaultWalletConnectRequestHandlers,
  createWallet,
  createWalletAdapter,
  createWalletConnectClient,
  createWalletConnectSession,
  disconnectWalletConnectSession,
  ecosystemWallet,
  inAppWallet as embeddedWallet,
  generateAccount,
  getActiveWalletConnectSessions,
  getAllWalletsList,
  getWalletBalance,
  getWalletInfo,
  inAppWallet,
  injectedProvider,
  privateKeyToAccount as privateKeyAccount,
  privateKeyToAccount,
  smartWallet,
  walletConnect
};
//# sourceMappingURL=thirdweb_wallets.js.map
