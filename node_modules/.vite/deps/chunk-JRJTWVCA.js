import {
  toUnits
} from "./chunk-3SOZ25XX.js";
import {
  readContract
} from "./chunk-OEOA3HT2.js";
import {
  formatBlock
} from "./chunk-BSASUUNP.js";
import {
  hexToBytes
} from "./chunk-MQIGPFEC.js";
import {
  download
} from "./chunk-NMJW5RZU.js";
import {
  hexToBigInt,
  isHex,
  numberToHex
} from "./chunk-3JG4JMZX.js";
import {
  getBytecode
} from "./chunk-WF2UJPJG.js";
import {
  getRpcClient
} from "./chunk-HGWZNQ5H.js";
import {
  getClientFetch
} from "./chunk-CVWITOXT.js";
import {
  decodeErrorResult,
  formatAbi,
  formatTransactionRequest,
  parseAbi
} from "./chunk-ZAXCNZIK.js";
import {
  encode
} from "./chunk-NCXSBGTZ.js";

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByNumber.js
async function eth_getBlockByNumber(request, params) {
  const blockTag = params.blockTag ?? "latest";
  const includeTransactions = params.includeTransactions ?? false;
  const blockNumberHex = params.blockNumber !== void 0 ? numberToHex(params.blockNumber) : void 0;
  const block = await request({
    method: "eth_getBlockByNumber",
    params: [blockNumberHex || blockTag, includeTransactions]
  });
  if (!block) {
    throw new Error("Block not found");
  }
  return formatBlock(block);
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_maxPriorityFeePerGas.js
async function eth_maxPriorityFeePerGas(request) {
  const result = await request({
    method: "eth_maxPriorityFeePerGas"
  });
  return hexToBigInt(result);
}

// node_modules/thirdweb/dist/esm/utils/promise/resolve-promised-value.js
async function resolvePromisedValue(value) {
  return typeof value === "function" ? await value() : value;
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_gasPrice.js
async function eth_gasPrice(request) {
  const result = await request({
    method: "eth_gasPrice"
  });
  return hexToBigInt(result);
}

// node_modules/thirdweb/dist/esm/gas/get-gas-price.js
async function getGasPrice(options) {
  const { client, chain, percentMultiplier } = options;
  const rpcClient = getRpcClient({ client, chain });
  const gasPrice_ = await eth_gasPrice(rpcClient);
  const extraTip = percentMultiplier ? gasPrice_ / BigInt(100) * BigInt(percentMultiplier) : 0n;
  const txGasPrice = gasPrice_ + extraTip;
  return txGasPrice;
}

// node_modules/thirdweb/dist/esm/gas/op-gas-fee-reducer.js
function roundUpGas(value) {
  if (value === 0n || (value & value - 1n) === 0n) {
    return value;
  }
  let highestBit = 1n;
  while (value > 0n) {
    value >>= 1n;
    highestBit <<= 1n;
  }
  return highestBit;
}

// node_modules/thirdweb/dist/esm/gas/fee-data.js
async function getGasOverridesForTransaction(transaction) {
  var _a;
  const [maxFeePerGas, maxPriorityFeePerGas, gasPrice] = await Promise.all([
    resolvePromisedValue(transaction.maxFeePerGas),
    resolvePromisedValue(transaction.maxPriorityFeePerGas),
    resolvePromisedValue(transaction.gasPrice)
  ]);
  if (maxFeePerGas !== void 0 && maxPriorityFeePerGas !== void 0) {
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  if (gasPrice) {
    return { gasPrice };
  }
  const defaultGasOverrides = await getDefaultGasOverrides(transaction.client, transaction.chain);
  if ((_a = transaction.chain.experimental) == null ? void 0 : _a.increaseZeroByteCount) {
    if (defaultGasOverrides.gasPrice) {
      return { gasPrice: roundUpGas(defaultGasOverrides.gasPrice) };
    }
    return {
      maxFeePerGas: maxFeePerGas ?? roundUpGas(defaultGasOverrides.maxFeePerGas ?? 0n),
      maxPriorityFeePerGas: maxPriorityFeePerGas ?? roundUpGas(defaultGasOverrides.maxPriorityFeePerGas ?? 0n)
    };
  }
  if (defaultGasOverrides.gasPrice) {
    return defaultGasOverrides;
  }
  return {
    maxFeePerGas: maxFeePerGas ?? defaultGasOverrides.maxFeePerGas,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? defaultGasOverrides.maxPriorityFeePerGas
  };
}
async function getDefaultGasOverrides(client, chain) {
  const feeData = await getDynamicFeeData(client, chain);
  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
    return {
      maxFeePerGas: feeData.maxFeePerGas,
      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
    };
  }
  return {
    gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 })
  };
}
async function getDynamicFeeData(client, chain) {
  let maxFeePerGas = null;
  let maxPriorityFeePerGas_ = null;
  const rpcRequest = getRpcClient({ client, chain });
  const [block, maxPriorityFeePerGas] = await Promise.all([
    eth_getBlockByNumber(rpcRequest, { blockTag: "latest" }),
    eth_maxPriorityFeePerGas(rpcRequest).catch(() => null)
  ]);
  const baseBlockFee = (block == null ? void 0 : block.baseFeePerGas) ? block.baseFeePerGas : 100n;
  const chainId = chain.id;
  if (chainId === 220 || chainId === 1220) {
    return { maxFeePerGas: null, maxPriorityFeePerGas: null };
  }
  if (chainId === 80001 || chainId === 137) {
    maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);
  } else if (maxPriorityFeePerGas) {
    maxPriorityFeePerGas_ = maxPriorityFeePerGas;
  }
  if (!maxPriorityFeePerGas_) {
    return { maxFeePerGas: null, maxPriorityFeePerGas: null };
  }
  maxPriorityFeePerGas_ = getPreferredPriorityFee(maxPriorityFeePerGas_);
  maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;
  if (chainId === 42220 || chainId === 44787 || chainId === 62320) {
    maxPriorityFeePerGas_ = maxFeePerGas;
  }
  return {
    maxFeePerGas,
    maxPriorityFeePerGas: maxPriorityFeePerGas_
  };
}
function getPreferredPriorityFee(defaultPriorityFeePerGas, percentMultiplier = 10) {
  const extraTip = defaultPriorityFeePerGas / BigInt(100) * BigInt(percentMultiplier);
  const totalPriorityFee = defaultPriorityFeePerGas + extraTip;
  return totalPriorityFee;
}
function getGasStationUrl(chainId) {
  switch (chainId) {
    case 137:
      return "https://gasstation.polygon.technology/v2";
    case 80001:
      return "https://gasstation-testnet.polygon.technology/v2";
  }
}
var MIN_POLYGON_GAS_PRICE = 31n;
var MIN_MUMBAI_GAS_PRICE = 1n;
function getDefaultGasFee(chainId) {
  switch (chainId) {
    case 137:
      return MIN_POLYGON_GAS_PRICE;
    case 80001:
      return MIN_MUMBAI_GAS_PRICE;
  }
}
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await fetch(gasStationUrl)).json();
    const priorityFee = data.fast.maxPriorityFee;
    if (priorityFee > 0) {
      const fixedFee = Number.parseFloat(priorityFee).toFixed(9);
      return toUnits(fixedFee, 9);
    }
  } catch (e) {
    console.error("failed to fetch gas", e);
  }
  return getDefaultGasFee(chainId);
}

// node_modules/thirdweb/dist/esm/extensions/modular/__generated__/ModularCore/read/getInstalledExtensions.js
var FN_SELECTOR = "0x5357aa5e";
var FN_INPUTS = [];
var FN_OUTPUTS = [
  {
    name: "_installedExtensions",
    type: "tuple[]",
    internalType: "struct IModularCore.InstalledExtension[]",
    components: [
      {
        name: "implementation",
        type: "address",
        internalType: "address"
      },
      {
        name: "config",
        type: "tuple",
        internalType: "struct IExtensionConfig.ExtensionConfig",
        components: [
          {
            name: "registerInstallationCallback",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "requiredInterfaces",
            type: "bytes4[]",
            internalType: "bytes4[]"
          },
          {
            name: "supportedInterfaces",
            type: "bytes4[]",
            internalType: "bytes4[]"
          },
          {
            name: "callbackFunctions",
            type: "tuple[]",
            internalType: "struct IExtensionConfig.CallbackFunction[]",
            components: [
              {
                name: "selector",
                type: "bytes4",
                internalType: "bytes4"
              }
            ]
          },
          {
            name: "fallbackFunctions",
            type: "tuple[]",
            internalType: "struct IExtensionConfig.FallbackFunction[]",
            components: [
              {
                name: "selector",
                type: "bytes4",
                internalType: "bytes4"
              },
              {
                name: "permissionBits",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ]
  }
];
async function getInstalledExtensions(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/utils/base58/alphabet.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

// node_modules/thirdweb/dist/esm/utils/base58/encode.js
var BASE = ALPHABET.length;
var LEADER = (() => ALPHABET.charAt(0))();
var iFACTOR = (() => Math.log(256) / Math.log(BASE))();
function base58Encode(source) {
  if (!(source instanceof Uint8Array)) {
    throw new TypeError("Expected Uint8Array");
  }
  if (source.length === 0) {
    return "";
  }
  let zeroes = 0;
  let length = 0;
  let pbegin = 0;
  const pend = source.length;
  while (pbegin !== pend && source[pbegin] === 0) {
    pbegin++;
    zeroes++;
  }
  const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
  const b58 = new Uint8Array(size);
  while (pbegin !== pend) {
    let carry = source[pbegin] || 0;
    let i = 0;
    for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
      carry += 256 * (b58[it1] || 0) >>> 0;
      b58[it1] = carry % BASE >>> 0;
      carry = carry / BASE >>> 0;
    }
    if (carry !== 0) {
      throw new Error("Non-zero carry");
    }
    length = i;
    pbegin++;
  }
  let it2 = size - length;
  while (it2 !== size && b58[it2] === 0) {
    it2++;
  }
  let str = LEADER.repeat(zeroes);
  for (; it2 < size; ++it2) {
    str += ALPHABET.charAt(b58[it2] || 0);
  }
  return str;
}

// node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js
var src;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var packedValues;
var dataView;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var Decoder = class _Decoder {
  constructor() {
    Object.assign(this, defaultOptions);
  }
  decodeKey(key) {
    return key;
  }
  decode(source, end = -1) {
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === "object" ? source.constructor.name : typeof source}`);
    }
    if (this instanceof _Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
};
function checkedRead() {
  try {
    const result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        const error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position === srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position > srcEnd) {
      const error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  const majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      default:
        throw new Error(`Unknown token ${token}`);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {
        const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string !== null) {
          return string;
        }
      }
      return readFixedString(token);
    case 4: {
      const array = new Array(token);
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      return array;
    }
    case 5: {
      const object = {};
      for (let i = 0; i < token; i++) {
        object[safeKey(read())] = read();
      }
      return object;
    }
    default:
      if (Number.isNaN(token)) {
        const error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error(`Unknown CBOR token ${token}`);
  }
}
function safeKey(key) {
  if (typeof key === "string") {
    return key === "__proto__" ? "__proto_" : key;
  }
  if (typeof key !== "object") {
    return key.toString();
  }
  throw new Error(`Invalid property name type ${typeof key}`);
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  const start = position;
  const bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) {
        return "";
      }
      const a3 = src[position++];
      if ((a3 & 128) > 1) {
        position -= 1;
        return;
      }
      return fromCharCode(a3);
    }
    const a2 = src[position++];
    const b2 = src[position++];
    if ((a2 & 128) > 0 || (b2 & 128) > 0) {
      position -= 2;
      return;
    }
    if (length < 3) {
      return fromCharCode(a2, b2);
    }
    const c2 = src[position++];
    if ((c2 & 128) > 0) {
      position -= 3;
      return;
    }
    return fromCharCode(a2, b2, c2);
  }
  const a = src[position++];
  const b = src[position++];
  const c = src[position++];
  const d = src[position++];
  if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
    position -= 4;
    return;
  }
  if (length < 6) {
    if (length === 4) {
      return fromCharCode(a, b, c, d);
    }
    const e2 = src[position++];
    if ((e2 & 128) > 0) {
      position -= 5;
      return;
    }
    return fromCharCode(a, b, c, d, e2);
  }
  if (length < 8) {
    const e2 = src[position++];
    const f2 = src[position++];
    if ((e2 & 128) > 0 || (f2 & 128) > 0) {
      position -= 6;
      return;
    }
    if (length < 7) {
      return fromCharCode(a, b, c, d, e2, f2);
    }
    const g2 = src[position++];
    if ((g2 & 128) > 0) {
      position -= 7;
      return;
    }
    return fromCharCode(a, b, c, d, e2, f2, g2);
  }
  const e = src[position++];
  const f = src[position++];
  const g = src[position++];
  const h = src[position++];
  if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
    position -= 8;
    return;
  }
  if (length < 10) {
    if (length === 8) {
      return fromCharCode(a, b, c, d, e, f, g, h);
    }
    const i2 = src[position++];
    if ((i2 & 128) > 0) {
      position -= 9;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i2);
  }
  if (length < 12) {
    const i2 = src[position++];
    const j2 = src[position++];
    if ((i2 & 128) > 0 || (j2 & 128) > 0) {
      position -= 10;
      return;
    }
    if (length < 11) {
      return fromCharCode(a, b, c, d, e, f, g, h, i2, j2);
    }
    const k2 = src[position++];
    if ((k2 & 128) > 0) {
      position -= 11;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i2, j2, k2);
  }
  const i = src[position++];
  const j = src[position++];
  const k = src[position++];
  const l = src[position++];
  if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
    position -= 12;
    return;
  }
  if (length < 14) {
    if (length === 12) {
      return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
    }
    const m2 = src[position++];
    if ((m2 & 128) > 0) {
      position -= 13;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m2);
  }
  const m = src[position++];
  const n = src[position++];
  if ((m & 128) > 0 || (n & 128) > 0) {
    position -= 14;
    return;
  }
  if (length < 15) {
    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
  }
  const o = src[position++];
  if ((o & 128) > 0) {
    position -= 15;
    return;
  }
  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
}
function readBin(length) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length)
  ) : src.subarray(position, position += length);
}
var glbl = { Error, RegExp };
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (read_) => {
  if (src[position++] !== 132) {
    const error = new Error("Packed values structure must be followed by a 4 element array");
    if (src.length < position) {
      error.incomplete = true;
    }
    throw error;
  }
  const newPackedValues = read_();
  if (!newPackedValues || !newPackedValues.length) {
    const error = new Error("Packed values structure must be followed by a 4 element array");
    error.incomplete = true;
    throw error;
  }
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = read_();
  packedValues.suffixes = read_();
  return read_();
};
packedTable.handlesRead = true;
currentExtensions[28] = (read_) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  const id = referenceMap.id++;
  const token = src[position];
  let target;
  if (token >> 5 === 4) {
    target = [];
  } else {
    target = {};
  }
  const refEntry = { target };
  referenceMap.set(id, refEntry);
  const targetProperties = read_();
  if (refEntry.used) {
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = (() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();
}
var defaultDecoder = new Decoder();
var decode = defaultDecoder.decode;

// node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js
function ensureBytecodePrefix(bytecode) {
  if (isHex(bytecode, { strict: false })) {
    return bytecode;
  }
  return `0x${bytecode}`;
}

// node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js
function extractIPFSUri(bytecode) {
  const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));
  const cborLength = (
    // @ts-expect-error - TS doesn't like this, but it's fine
    numericBytecode[numericBytecode.length - 2] * 256 + // @ts-expect-error - TS doesn't like this, but it's fine
    numericBytecode[numericBytecode.length - 1]
  );
  const cborStart = numericBytecode.length - 2 - cborLength;
  if (cborStart < 0 || cborStart > numericBytecode.length) {
    return void 0;
  }
  const bytecodeBuffer = numericBytecode.slice(cborStart, -2);
  const cborData = decode(bytecodeBuffer);
  if ("ipfs" in cborData) {
    return `ipfs://${base58Encode(cborData.ipfs)}`;
  }
  return void 0;
}

// node_modules/thirdweb/dist/esm/contract/actions/resolve-abi.js
var ABI_RESOLUTION_CACHE = /* @__PURE__ */ new WeakMap();
function resolveContractAbi(contract, contractApiBaseUrl = "https://contract.thirdweb.com/abi") {
  if (ABI_RESOLUTION_CACHE.has(contract)) {
    return ABI_RESOLUTION_CACHE.get(contract);
  }
  const prom = (async () => {
    if (contract.abi) {
      return contract.abi;
    }
    try {
      return await resolveAbiFromContractApi(contract, contractApiBaseUrl);
    } catch (e) {
      return await resolveCompositeAbi(contract);
    }
  })();
  ABI_RESOLUTION_CACHE.set(contract, prom);
  return prom;
}
async function resolveAbiFromContractApi(contract, contractApiBaseUrl = "https://contract.thirdweb.com/abi") {
  const response = await getClientFetch(contract.client)(`${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`);
  const json = await response.json();
  if (!json || json.error) {
    throw new Error(`Failed to resolve ABI from contract API. ${json.error || ""}`);
  }
  return json;
}
async function resolveAbiFromBytecode(contract) {
  const bytecode = await getBytecode(contract);
  if (bytecode === "0x") {
    const { id, name } = contract.chain;
    throw new Error(`Failed to load contract bytecode. Make sure the contract [${contract.address}] exists on the chain [${name || "Unknown Chain"} (chain id: ${id})]`);
  }
  const ipfsUri = extractIPFSUri(bytecode);
  if (!ipfsUri) {
    return [];
  }
  try {
    const res = await download({ uri: ipfsUri, client: contract.client });
    const json = await res.json();
    return json.output.abi;
  } catch {
    return [];
  }
}
var PLUGINS_ABI = {
  inputs: [],
  name: "getAllPlugins",
  outputs: [
    {
      components: [
        {
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4"
        },
        {
          internalType: "string",
          name: "functionSignature",
          type: "string"
        },
        {
          internalType: "address",
          name: "pluginAddress",
          type: "address"
        }
      ],
      internalType: "struct IPluginMap.Plugin[]",
      name: "registered",
      type: "tuple[]"
    }
  ],
  stateMutability: "view",
  type: "function"
};
var BASE_ROUTER_ABI = {
  inputs: [],
  name: "getAllExtensions",
  outputs: [
    {
      components: [
        {
          components: [
            {
              internalType: "string",
              name: "name",
              type: "string"
            },
            {
              internalType: "string",
              name: "metadataURI",
              type: "string"
            },
            {
              internalType: "address",
              name: "implementation",
              type: "address"
            }
          ],
          internalType: "struct IExtension.ExtensionMetadata",
          name: "metadata",
          type: "tuple"
        },
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4"
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string"
            }
          ],
          internalType: "struct IExtension.ExtensionFunction[]",
          name: "functions",
          type: "tuple[]"
        }
      ],
      internalType: "struct IExtension.Extension[]",
      name: "allExtensions",
      type: "tuple[]"
    }
  ],
  stateMutability: "view",
  type: "function"
};
var DIAMOND_ABI = {
  inputs: [],
  name: "facets",
  outputs: [
    {
      components: [
        {
          internalType: "address",
          name: "facetAddress",
          type: "address"
        },
        {
          internalType: "bytes4[]",
          name: "functionSelectors",
          type: "bytes4[]"
        }
      ],
      type: "tuple[]"
    }
  ],
  stateMutability: "view",
  type: "function"
};
async function resolveCompositeAbi(contract, rootAbi, resolveSubAbi) {
  const [rootAbi_, pluginPatternAddresses, baseRouterAddresses, modularExtensionAddresses, diamondFacetAddresses] = await Promise.all([
    rootAbi ? rootAbi : resolveAbiFromBytecode(contract),
    // check these all at the same time
    resolvePluginPatternAddresses(contract),
    resolveBaseRouterAddresses(contract),
    resolveModularExtensionAddresses(contract),
    resolveDiamondFacetAddresses(contract)
  ]);
  const mergedPlugins = [
    .../* @__PURE__ */ new Set([
      ...pluginPatternAddresses,
      ...baseRouterAddresses,
      ...modularExtensionAddresses,
      ...diamondFacetAddresses
    ])
  ];
  if (!mergedPlugins.length) {
    return rootAbi_;
  }
  const pluginAbis = await getAbisForPlugins({
    contract,
    plugins: mergedPlugins,
    resolveSubAbi
  });
  return joinAbis({ rootAbi: rootAbi_, pluginAbis });
}
async function resolvePluginPatternAddresses(contract) {
  try {
    const { readContract: readContract2 } = await import("./read-contract-45JU6MUZ.js");
    const pluginMap = await readContract2({
      contract,
      method: PLUGINS_ABI
    });
    if (!pluginMap.length) {
      return [];
    }
    return [...new Set(pluginMap.map((item) => item.pluginAddress))];
  } catch {
  }
  return [];
}
async function resolveBaseRouterAddresses(contract) {
  try {
    const { readContract: readContract2 } = await import("./read-contract-45JU6MUZ.js");
    const pluginMap = await readContract2({
      contract,
      method: BASE_ROUTER_ABI
    });
    if (!pluginMap.length) {
      return [];
    }
    return [...new Set(pluginMap.map((item) => item.metadata.implementation))];
  } catch {
  }
  return [];
}
async function resolveModularExtensionAddresses(contract) {
  try {
    const extensions = await getInstalledExtensions({ contract });
    if (!extensions.length) {
      return [];
    }
    return [...new Set(extensions.map((item) => item.implementation))];
  } catch {
  }
  return [];
}
async function resolveDiamondFacetAddresses(contract) {
  try {
    const { readContract: readContract2 } = await import("./read-contract-45JU6MUZ.js");
    const facets = await readContract2({ contract, method: DIAMOND_ABI });
    if (!facets.length) {
      return [];
    }
    return facets.map((item) => item.facetAddress);
  } catch {
  }
  return [];
}
async function getAbisForPlugins(options) {
  return Promise.all(options.plugins.map((pluginAddress) => {
    const newContract = {
      ...options.contract,
      address: pluginAddress
    };
    if (options.resolveSubAbi) {
      return options.resolveSubAbi(newContract);
    }
    return resolveAbiFromBytecode(newContract);
  }));
}
function joinAbis(options) {
  let mergedPlugins = options.pluginAbis.flat().filter((item) => item.type !== "constructor");
  if (options.rootAbi) {
    mergedPlugins = [...options.rootAbi || [], ...mergedPlugins].filter(Boolean);
  }
  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];
  return parseAbi(humanReadableAbi);
}

// node_modules/thirdweb/dist/esm/transaction/extract-error.js
async function extractError(args) {
  const { error, contract } = args;
  if (typeof error === "object") {
    const errorObj = error;
    if (errorObj.data) {
      if (errorObj.data !== "0x") {
        let abi = contract == null ? void 0 : contract.abi;
        if (contract && !abi) {
          abi = await resolveContractAbi(contract).catch(() => void 0);
        }
        const parsedError = decodeErrorResult({
          data: errorObj.data,
          abi
        });
        return new TransactionError(`${parsedError.errorName}${parsedError.args ? ` - ${parsedError.args}` : ""}`, contract);
      }
      return new TransactionError("Execution Reverted", contract);
    }
  }
  return error;
}
var __DEV__ = true;
var TransactionError = class extends Error {
  constructor(reason, contract) {
    var _a;
    super();
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "chainId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "TransactionError";
    this.contractAddress = contract == null ? void 0 : contract.address;
    this.chainId = (_a = contract == null ? void 0 : contract.chain) == null ? void 0 : _a.id;
    if (__DEV__ && contract) {
      this.message = [
        reason,
        "",
        `contract: ${this.contractAddress}`,
        `chainId: ${this.chainId}`
      ].join("\n");
    } else {
      this.message = reason;
    }
  }
};

// node_modules/thirdweb/dist/esm/transaction/actions/estimate-gas.js
var cache = /* @__PURE__ */ new WeakMap();
async function estimateGas(options) {
  var _a;
  const from = options.from ?? ((_a = options.account) == null ? void 0 : _a.address) ?? void 0;
  const txWithFrom = { ...options.transaction, from };
  if (cache.has(txWithFrom)) {
    return cache.get(txWithFrom);
  }
  const { account } = options;
  const promise = (async () => {
    var _a2, _b;
    const predefinedGas = await resolvePromisedValue(options.transaction.gas);
    if (predefinedGas) {
      return predefinedGas;
    }
    if (account == null ? void 0 : account.estimateGas) {
      try {
        let gas = await account.estimateGas(options.transaction);
        if ((_a2 = options.transaction.chain.experimental) == null ? void 0 : _a2.increaseZeroByteCount) {
          gas = roundUpGas(gas);
        }
        return gas;
      } catch (error) {
        throw await extractError({
          error,
          contract: options.transaction.__contract
        });
      }
    }
    const { encode: encode2 } = await import("./encode-66XWEPW4.js");
    const [encodedData, toAddress, value] = await Promise.all([
      encode2(options.transaction),
      resolvePromisedValue(options.transaction.to),
      resolvePromisedValue(options.transaction.value)
    ]);
    const [{ getRpcClient: getRpcClient2 }, { eth_estimateGas }] = await Promise.all([
      import("./rpc-K2FMQQLL.js"),
      import("./eth_estimateGas-VTG6UQP6.js")
    ]);
    const rpcRequest = getRpcClient2(options.transaction);
    try {
      let gas = await eth_estimateGas(rpcRequest, formatTransactionRequest({
        to: toAddress,
        data: encodedData,
        from,
        value
      }));
      if ((_b = options.transaction.chain.experimental) == null ? void 0 : _b.increaseZeroByteCount) {
        gas = roundUpGas(gas);
      }
      return gas;
    } catch (error) {
      throw await extractError({
        error,
        contract: options.transaction.__contract
      });
    }
  })();
  cache.set(txWithFrom, promise);
  return promise;
}

// node_modules/thirdweb/dist/esm/transaction/actions/to-serializable-transaction.js
async function toSerializableTransaction(options) {
  const rpcRequest = getRpcClient(options.transaction);
  const chainId = options.transaction.chain.id;
  const from = options.from;
  let [data, nonce, gas, feeData, to, accessList, value] = await Promise.all([
    encode(options.transaction),
    (async () => {
      const resolvedNonce = await resolvePromisedValue(options.transaction.nonce);
      if (resolvedNonce !== void 0) {
        return resolvedNonce;
      }
      return from ? await import("./eth_getTransactionCount-PM64DLUZ.js").then(({ eth_getTransactionCount }) => eth_getTransactionCount(rpcRequest, {
        address: from,
        blockTag: "pending"
      })) : void 0;
    })(),
    // takes the same options as the sendTransaction function thankfully!
    estimateGas(options),
    getGasOverridesForTransaction(options.transaction),
    resolvePromisedValue(options.transaction.to),
    resolvePromisedValue(options.transaction.accessList),
    resolvePromisedValue(options.transaction.value)
  ]);
  const extraGas = await resolvePromisedValue(options.transaction.extraGas);
  if (extraGas) {
    gas += extraGas;
  }
  return {
    to,
    chainId,
    data,
    gas,
    nonce,
    accessList,
    value,
    ...feeData
  };
}

export {
  resolvePromisedValue,
  getGasPrice,
  getDefaultGasOverrides,
  resolveContractAbi,
  extractError,
  estimateGas,
  toSerializableTransaction
};
//# sourceMappingURL=chunk-JRJTWVCA.js.map
