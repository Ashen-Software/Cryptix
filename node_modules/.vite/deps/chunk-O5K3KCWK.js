import {
  AccentFailIcon
} from "./chunk-BZBZUKEQ.js";
import {
  LoadingScreen
} from "./chunk-MYDXRGVE.js";
import {
  Fuse,
  useDebouncedValue,
  useShowMore
} from "./chunk-EECLXWBX.js";
import {
  useActiveWallet,
  useWalletBalance
} from "./chunk-EGTGOWTN.js";
import {
  Input,
  Spinner,
  compactModalMaxHeight,
  modalCloseFadeOutDuration,
  modalMaxWidthCompact,
  modalMaxWidthWide,
  useActiveAccount,
  wideModalMaxHeight
} from "./chunk-BFEMHPGA.js";
import {
  Button,
  ButtonLink,
  CheckCircledIcon,
  CheckIcon,
  ChevronDownIcon,
  ClockIcon,
  Container,
  Cross1Icon,
  Cross2Icon,
  CrossCircledIcon,
  ExternalLinkIcon,
  IconButton,
  IdCardIcon,
  Img,
  Line,
  MagnifyingGlassIcon,
  ModalHeader,
  ModalTitle,
  RadiobuttonIcon,
  Skeleton,
  Spacer,
  StyledButton,
  StyledDiv,
  StyledP,
  StyledUl,
  Text,
  TriangleDownIcon,
  connectionManager,
  fadeInAnimation,
  fontSize,
  genericTokenIcon,
  iconSize,
  keyframes,
  media,
  newStyled,
  noScrollBar,
  radius,
  shadow,
  spacing,
  useCustomTheme,
  useMutation,
  useQueries,
  useQuery,
  useQueryClient
} from "./chunk-TS42ER4K.js";
import {
  prepareContractCall
} from "./chunk-J6SGVPAD.js";
import {
  NATIVE_TOKEN_ADDRESS
} from "./chunk-X7ZQ7JNR.js";
import {
  waitForReceipt
} from "./chunk-3FNFQJO5.js";
import {
  require_jsx_runtime
} from "./chunk-PQVTKVEJ.js";
import {
  require_react_dom
} from "./chunk-3POKLTNE.js";
import {
  require_react
} from "./chunk-A4STD2P3.js";
import {
  isMobile
} from "./chunk-7JYW3NMA.js";
import {
  eth_getBalance,
  getWalletBalance
} from "./chunk-62SMVODG.js";
import {
  sendTransaction
} from "./chunk-KVTKFUNA.js";
import {
  estimateGas,
  getGasPrice,
  resolvePromisedValue
} from "./chunk-JRJTWVCA.js";
import {
  toEther,
  toTokens,
  toUnits
} from "./chunk-3SOZ25XX.js";
import {
  getContract
} from "./chunk-AOWXXJZS.js";
import {
  createStore
} from "./chunk-OSZAYZBM.js";
import {
  getAddress
} from "./chunk-LW7EMTNJ.js";
import {
  resolveScheme
} from "./chunk-PZWOPBWI.js";
import {
  getRpcClient
} from "./chunk-HGWZNQ5H.js";
import {
  convertApiChainToChain,
  defineChain,
  getCachedChain,
  getChainDecimals,
  getChainMetadata,
  getChainNativeCurrencyName,
  getChainSymbol,
  withCache
} from "./chunk-NMVKDFRL.js";
import {
  getThirdwebDomains
} from "./chunk-MHFR2GDE.js";
import {
  getClientFetch
} from "./chunk-CVWITOXT.js";
import {
  __toESM
} from "./chunk-SEVZ5PBP.js";

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/BuyScreen.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react27 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/pay/buyWithFiat/isSwapRequiredPostOnramp.js
function isSwapRequiredPostOnramp(buyWithFiatQuote) {
  const sameChain = buyWithFiatQuote.toToken.chainId === buyWithFiatQuote.onRampToken.token.chainId;
  const sameToken = getAddress(buyWithFiatQuote.toToken.tokenAddress) === getAddress(buyWithFiatQuote.onRampToken.token.tokenAddress);
  return !(sameChain && sameToken);
}

// node_modules/thirdweb/dist/esm/utils/formatNumber.js
function formatNumber(value, decimalPlaces) {
  return Number(value.toFixed(decimalPlaces));
}

// node_modules/thirdweb/dist/esm/react/core/hooks/others/useChainQuery.js
var import_react = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/utils/promise/p-limit.js
var Node = class {
  constructor(value) {
    Object.defineProperty(this, "value", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "next", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.value = value;
  }
};
var Queue = class {
  constructor() {
    Object.defineProperty(this, "head", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tail", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.clear();
    this.size = 0;
  }
  enqueue(value) {
    const node = new Node(value);
    if (this.head) {
      if (this.tail) {
        this.tail.next = node;
      }
      this.tail = node;
    } else {
      this.head = node;
      this.tail = node;
    }
    this.size++;
  }
  dequeue() {
    var _a;
    const current = this.head;
    if (!current) {
      return;
    }
    this.head = (_a = this.head) == null ? void 0 : _a.next;
    this.size--;
    return current.value;
  }
  clear() {
    this.head = void 0;
    this.tail = void 0;
    this.size = 0;
  }
  *[Symbol.iterator]() {
    let current = this.head;
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
var AsyncResource = {
  bind(fn, _type, thisArg) {
    return fn.bind(thisArg);
  }
};
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      const fn = queue.dequeue();
      if (fn) {
        fn();
      }
    }
  };
  const run = async (function_, resolve, arguments_) => {
    activeCount++;
    const result = (async () => function_(...arguments_))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (function_, resolve, arguments_) => {
    queue.enqueue(AsyncResource.bind(run.bind(void 0, function_, resolve, arguments_)));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        const fn = queue.dequeue();
        if (fn) {
          fn();
        }
      }
    })();
  };
  const generator = (function_, ...arguments_) => new Promise((resolve) => {
    enqueue(function_, resolve, arguments_);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value() {
        queue.clear();
      }
    }
  });
  return generator;
}

// node_modules/thirdweb/dist/esm/react/core/hooks/others/useChainQuery.js
function getQueryOptions(chain) {
  return {
    queryKey: ["chain", chain],
    enabled: !!chain,
    staleTime: 1e3 * 60 * 60
    // 1 hour
  };
}
function useChainQuery(chain) {
  return useQuery({
    ...getQueryOptions(chain),
    queryFn: async () => {
      if (!chain) {
        throw new Error("chainId is required");
      }
      return getChainMetadata(chain);
    }
  });
}
function useChainsQuery(chains, maxConcurrency) {
  const queryList = (0, import_react.useMemo)(() => {
    const limit = pLimit(maxConcurrency);
    return chains.map((chain) => {
      return {
        ...getQueryOptions(chain),
        queryFn: () => limit(() => getChainMetadata(chain))
      };
    });
  }, [chains, maxConcurrency]);
  return useQueries({
    queries: queryList
  });
}

// node_modules/thirdweb/dist/esm/utils/promise/once.js
function once(fn) {
  let result;
  return () => {
    if (!result) {
      result = fn();
    }
    return result;
  };
}

// node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/approve.js
var FN_SELECTOR = "0x095ea7b3";
var FN_INPUTS = [
  {
    type: "address",
    name: "spender"
  },
  {
    type: "uint256",
    name: "value"
  }
];
var FN_OUTPUTS = [
  {
    type: "bool"
  }
];
function approve(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.spender, resolvedOptions.value];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc20/write/approve.js
function approve2(options) {
  return approve({
    contract: options.contract,
    asyncParams: async () => {
      let amount;
      if ("amount" in options) {
        const { decimals } = await import("./decimals-THCH4QZE.js");
        const d = await decimals(options).catch(() => 18);
        amount = toUnits(options.amount.toString(), d);
      } else {
        amount = options.amountWei;
      }
      return {
        spender: options.spender,
        value: amount
      };
    }
  });
}

// node_modules/thirdweb/dist/esm/pay/utils/definitions.js
var getPayBaseUrl = () => {
  const payDomain = getThirdwebDomains().pay;
  return payDomain.startsWith("localhost") ? `http://${payDomain}` : `https://${payDomain}`;
};
var getPayBuyWithCryptoStatusUrl = () => `${getPayBaseUrl()}/buy-with-crypto/status/v1`;
var getPayBuyWithCryptoQuoteEndpoint = () => `${getPayBaseUrl()}/buy-with-crypto/quote/v1`;
var getPayBuyWithFiatQuoteEndpoint = () => `${getPayBaseUrl()}/buy-with-fiat/quote/v1`;
var getPayBuyWithFiatStatusEndpoint = () => `${getPayBaseUrl()}/buy-with-fiat/status/v1`;
var getPayBuyWithFiatHistoryEndpoint = () => `${getPayBaseUrl()}/buy-with-fiat/history/v1`;
var getPayBuyWithCryptoHistoryEndpoint = () => `${getPayBaseUrl()}/buy-with-crypto/history/v1`;
var getPaySupportedDestinations = () => `${getPayBaseUrl()}/destination-tokens/v1`;
var getPaySupportedSources = () => `${getPayBaseUrl()}/buy-with-crypto/source-tokens/v1`;
var getPayBuyHistoryEndpoint = () => `${getPayBaseUrl()}/wallet/history/v1`;

// node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getQuote.js
async function getBuyWithCryptoQuote(params) {
  var _a;
  try {
    const clientFetch = getClientFetch(params.client);
    const response = await clientFetch(getPayBuyWithCryptoQuoteEndpoint(), {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        fromAddress: params.fromAddress,
        fromChainId: params.fromChainId.toString(),
        fromTokenAddress: params.fromTokenAddress,
        toChainId: params.toChainId.toString(),
        toTokenAddress: params.toTokenAddress,
        fromAmount: params.fromAmount,
        toAmount: params.toAmount,
        maxSlippageBPS: params.maxSlippageBPS,
        intentId: params.intentId,
        purchaseData: params.purchaseData
      })
    });
    if (!response.ok) {
      const errorObj = await response.json();
      if (errorObj && "error" in errorObj && typeof errorObj.error === "object" && "message" in errorObj.error) {
        throw new Error(errorObj.error.message);
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    const swapRoute = {
      transactionRequest: {
        chain: getCachedChain(data.transactionRequest.chainId),
        client: params.client,
        data: data.transactionRequest.data,
        to: data.transactionRequest.to,
        value: BigInt(data.transactionRequest.value),
        gas: BigInt(data.transactionRequest.gasLimit),
        gasPrice: BigInt(data.transactionRequest.gasPrice)
      },
      approval: data.approval ? approve2({
        contract: getContract({
          client: params.client,
          address: data.approval.tokenAddress,
          chain: getCachedChain(data.approval.chainId)
        }),
        spender: (_a = data.approval) == null ? void 0 : _a.spenderAddress,
        amountWei: BigInt(data.approval.amountWei)
      }) : void 0,
      swapDetails: {
        fromAddress: data.fromAddress,
        toAddress: data.toAddress,
        fromToken: data.fromToken,
        toToken: data.toToken,
        fromAmount: data.fromAmount,
        fromAmountWei: data.fromAmountWei,
        toAmountMinWei: data.toAmountMinWei,
        toAmountMin: data.toAmountMin,
        toAmountWei: data.toAmountWei,
        toAmount: data.toAmount,
        estimated: data.estimated,
        maxSlippageBPS: data.maxSlippageBPS
      },
      paymentTokens: data.paymentTokens,
      processingFees: data.processingFees,
      client: params.client
    };
    return swapRoute;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithCryptoQuote.js
function useBuyWithCryptoQuote(params, queryParams) {
  return useQuery({
    ...queryParams,
    queryKey: ["buyWithCryptoQuote", params],
    queryFn: () => {
      if (!params) {
        throw new Error("Swap params are required");
      }
      return getBuyWithCryptoQuote(params);
    },
    enabled: !!params,
    retry(failureCount, error) {
      if (failureCount > 3) {
        return false;
      }
      if (error.message.includes("Minimum purchase")) {
        return false;
      }
      return true;
    }
  });
}

// node_modules/thirdweb/dist/esm/pay/buyWithFiat/getQuote.js
async function getBuyWithFiatQuote(params) {
  try {
    const clientFetch = getClientFetch(params.client);
    const response = await clientFetch(getPayBuyWithFiatQuoteEndpoint(), {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        toAddress: params.toAddress,
        fromCurrencySymbol: params.fromCurrencySymbol,
        toChainId: params.toChainId.toString(),
        toTokenAddress: params.toTokenAddress,
        fromAmount: params.fromAmount,
        toAmount: params.toAmount,
        maxSlippageBPS: params.maxSlippageBPS,
        isTestMode: params.isTestMode,
        purchaseData: params.purchaseData,
        fromAddress: params.fromAddress
      })
    });
    if (!response.ok) {
      const errorObj = await response.json();
      if (errorObj && "error" in errorObj) {
        throw errorObj;
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return (await response.json()).result;
  } catch (error) {
    console.error("Fetch error:", error);
    throw error;
  }
}

// node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithFiatQuote.js
function useBuyWithFiatQuote(params, queryOptions) {
  return useQuery({
    ...queryOptions,
    queryKey: ["useBuyWithFiatQuote", params],
    queryFn: async () => {
      if (!params) {
        throw new Error("No params provided");
      }
      return getBuyWithFiatQuote(params);
    },
    enabled: !!params,
    retry(failureCount, error) {
      if (failureCount > 3) {
        return false;
      }
      try {
        if (error.error.code === "MINIMUM_PURCHASE_AMOUNT") {
          return false;
        }
      } catch {
        return true;
      }
      return true;
    }
  });
}

// node_modules/thirdweb/dist/esm/react/core/hooks/wallets/useActiveWalletChain.js
var import_react2 = __toESM(require_react(), 1);
function useActiveWalletChainCore(manager) {
  const store = manager.activeWalletChainStore;
  return (0, import_react2.useSyncExternalStore)(store.subscribe, store.getValue, store.getValue);
}

// node_modules/thirdweb/dist/esm/react/web/hooks/wallets/useActiveWalletChain.js
function useActiveWalletChain() {
  return useActiveWalletChainCore(connectionManager);
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/ChainName.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var ChainName = (props) => {
  const chainQuery = useChainQuery(props.chain);
  if (chainQuery.data) {
    return (0, import_jsx_runtime.jsx)(Text, { size: props.size, children: props.short ? shorterChainName(chainQuery.data.name) : chainQuery.data.name });
  }
  return (0, import_jsx_runtime.jsx)(Skeleton, { width: "50px", height: fontSize[props.size] });
};
function shorterChainName(name) {
  const split = name.split(" ");
  const wordsToRemove = /* @__PURE__ */ new Set(["mainnet", "testnet", "chain"]);
  return split.filter((s) => {
    return !wordsToRemove.has(s.toLowerCase());
  }).join(" ");
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/Drawer.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/components/Modal.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var React25 = __toESM(require_react(), 1);

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-context/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createContext2(rootComponentName, defaultContext) {
  const Context = React2.createContext(defaultContext);
  function Provider(props) {
    const { children, ...context } = props;
    const value = React2.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime2.jsx)(Context.Provider, { value, children });
  }
  function useContext22(consumerName) {
    const context = React2.useContext(Context);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider.displayName = rootComponentName + "Provider";
  return [Provider, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React2.createContext(defaultContext);
    const index = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
      const value = React2.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime2.jsx)(Context.Provider, { value, children });
    }
    function useContext22(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
      const context = React2.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [Provider, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React2.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React2.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React2.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React3.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React4["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React4.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React6 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React5 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React5.useRef(callback);
  React5.useEffect(() => {
    callbackRef.current = callback;
  });
  return React5.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef(onChange);
  const setValue = React6.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop)
          handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React6.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React6.useRef(value);
  const handleChange = useCallbackRef(onChange);
  React6.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React10 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var Slot = React7.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React7.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React7.Children.count(newElement) > 1)
          return React7.Children.only(null);
        return React7.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React7.isValidElement(newElement) ? React7.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React7.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React7.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return React7.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return React7.Children.count(children) > 1 ? React7.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children });
};
function isSlottable(child) {
  return React7.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React8.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime4.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React9 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React9.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React10.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React10.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React10.useContext(DismissableLayerContext);
    const [node, setNode] = React10.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React10.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch)
        return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React10.useEffect(() => {
      if (!node)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React10.useEffect(() => {
      return () => {
        if (!node)
          return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React10.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime5.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React10.forwardRef((props, forwardedRef) => {
  const context = React10.useContext(DismissableLayerContext);
  const ref = React10.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React10.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime5.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React10.useRef(false);
  const handleClickRef = React10.useRef(() => {
  });
  React10.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React10.useRef(false);
  React10.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React11.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React11.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React11.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React11.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React11.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React11.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React11.useCallback(
    (event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime6.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-portal/dist/index.mjs
var React12 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React12.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React12.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? import_react_dom.default.createPortal((0, import_jsx_runtime7.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-presence/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var React13 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React13.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React22.useState();
  const stylesRef = React22.useRef({});
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          ReactDOM3.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node2) => {
      if (node2)
        stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React14 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React14.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}

// node_modules/react-remove-scroll/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React24 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React19 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react3 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react3.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React15 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React15.useLayoutEffect : React15.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/node_modules/tslib/tslib.es6.mjs
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React16 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react4 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign2({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React17 = __toESM(require_react());
var import_react5 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React18 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest2(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React18.createElement(Target, __assign2({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React19.forwardRef(function(props, parentRef) {
  var ref = React19.useRef(null);
  var _a = React19.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container2 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React19.createElement(
    React19.Fragment,
    null,
    enabled && React19.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React19.cloneElement(React19.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React19.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React23 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React21 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React20 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React20.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React21.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React21.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React21.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React23.useRef([]);
  var touchStartRef = React23.useRef([0, 0]);
  var activeAxis = React23.useRef();
  var id = React23.useState(idCounter++)[0];
  var Style2 = React23.useState(styleSingleton)[0];
  var lastProps = React23.useRef(props);
  React23.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React23.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React23.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React23.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React23.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React23.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React23.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React23.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React23.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React23.createElement(
    React23.Fragment,
    null,
    inert ? React23.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React23.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React24.forwardRef(function(props, ref) {
  return React24.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React25.useRef(null);
  const contentRef = React25.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime8.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React25.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger";
var DialogTrigger = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime8.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return (0, import_jsx_runtime8.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React25.Children.map(children, (child) => (0, import_jsx_runtime8.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime8.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React25.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime8.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime8.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime8.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime8.jsx)(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME = "DialogContent";
var DialogContent = React25.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    return (0, import_jsx_runtime8.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime8.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime8.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME;
var DialogContentModal = React25.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const contentRef = React25.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React25.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime8.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React25.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = React25.useRef(false);
    const hasPointerDownOutsideRef = React25.useRef(false);
    return (0, import_jsx_runtime8.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, __scopeDialog);
    const contentRef = React25.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
      (0, import_jsx_runtime8.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime8.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
        (0, import_jsx_runtime8.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime8.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime8.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime8.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime8.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React25.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React25.useEffect(() => {
    var _a;
    const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root = Dialog;
var Trigger = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content = DialogContent;
var Close = DialogClose;

// node_modules/thirdweb/dist/esm/react/web/ui/components/Modal.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/components/DynamicHeight.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
function DynamicHeight(props) {
  const { height, elementRef } = useHeightObserver();
  return (0, import_jsx_runtime9.jsx)("div", { style: {
    height: height ? `${height}px` : "auto",
    transition: "height 210ms cubic-bezier(0.175, 0.885, 0.32, 1.1)",
    overflow: "hidden",
    boxSizing: "border-box"
  }, children: (0, import_jsx_runtime9.jsx)("div", { ref: elementRef, style: {
    maxHeight: props.maxHeight
  }, children: props.children }) });
}
function useHeightObserver() {
  const elementRef = (0, import_react6.useRef)(null);
  const [height, setHeight] = (0, import_react6.useState)();
  (0, import_react6.useEffect)(() => {
    const element = elementRef.current;
    if (!element) {
      return;
    }
    const resizeObserver = new ResizeObserver(() => {
      setHeight(element.scrollHeight);
    });
    resizeObserver.observe(element);
    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  return { height, elementRef };
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/Overlay.js
var Overlay2 = StyledDiv((_) => {
  const theme = useCustomTheme();
  return {
    backgroundColor: theme.colors.modalOverlayBg,
    zIndex: 9999,
    position: "fixed",
    inset: 0,
    animation: `${fadeInAnimation} 400ms cubic-bezier(0.16, 1, 0.3, 1)`,
    backdropFilter: "blur(10px)"
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/components/Modal.js
var Modal = (props) => {
  const [open, setOpen] = (0, import_react8.useState)(props.open);
  const contentRef = (0, import_react8.useRef)(null);
  const overlayRef = (0, import_react8.useRef)(null);
  (0, import_react8.useEffect)(() => {
    var _a;
    if (!props.open) {
      if (contentRef.current) {
        const animationConfig = {
          duration: modalCloseFadeOutDuration,
          fill: "forwards",
          easing: "ease"
        };
        contentRef.current.animate([{ opacity: 0 }], {
          ...animationConfig
        }).onfinish = () => {
          setOpen(false);
        };
        (_a = overlayRef.current) == null ? void 0 : _a.animate([{ opacity: 0 }], {
          ...animationConfig,
          duration: modalCloseFadeOutDuration + 100
        });
      } else {
        setOpen(props.open);
      }
    } else {
      setOpen(props.open);
    }
  }, [props.open]);
  return (0, import_jsx_runtime10.jsxs)(Root, { open, onOpenChange: props.setOpen, children: [props.trigger && (0, import_jsx_runtime10.jsx)(Trigger, { asChild: true, children: props.trigger }), (0, import_jsx_runtime10.jsxs)(Portal2, { children: [!props.hide && (0, import_jsx_runtime10.jsx)(Overlay, { asChild: true, children: (0, import_jsx_runtime10.jsx)(Overlay2, { ref: overlayRef }) }), (0, import_jsx_runtime10.jsx)(FocusScope, { trapped: !props.hide, children: (0, import_jsx_runtime10.jsx)(Content, { asChild: true, children: (0, import_jsx_runtime10.jsxs)(DialogContent2, { ref: contentRef, style: props.hide ? { width: 0, height: 0, overflow: "hidden", opacity: 0 } : {
    height: props.size === "compact" ? "auto" : wideModalMaxHeight,
    maxWidth: props.size === "compact" ? modalMaxWidthCompact : modalMaxWidthWide
  }, children: [props.size === "compact" ? (0, import_jsx_runtime10.jsxs)(DynamicHeight, { maxHeight: compactModalMaxHeight, children: [props.children, " "] }) : props.children, !props.hideCloseIcon && (0, import_jsx_runtime10.jsx)(CrossContainer, { children: (0, import_jsx_runtime10.jsx)(Close, { asChild: true, children: (0, import_jsx_runtime10.jsx)(IconButton, { type: "button", "aria-label": "Close", children: (0, import_jsx_runtime10.jsx)(Cross2Icon, { width: iconSize.md, height: iconSize.md, style: {
    color: "inherit"
  } }) }) }) })] }) }) })] })] });
};
var CrossContainer = StyledDiv({
  position: "absolute",
  top: spacing.lg,
  right: spacing.lg,
  transform: "translateX(15%)",
  [media.mobile]: {
    right: spacing.md
  }
});
var modalAnimationDesktop = keyframes`
  from {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
`;
var modalAnimationMobile = keyframes`
  from {
    opacity: 0;
    transform: translate(0, 50%);
  }
  to {
    opacity: 1;
    transform: translate(0, 0);
  }
`;
var DialogContent2 = StyledDiv((_) => {
  const theme = useCustomTheme();
  return {
    zIndex: 1e4,
    background: theme.colors.modalBg,
    "--bg": theme.colors.modalBg,
    color: theme.colors.primaryText,
    borderRadius: radius.xl,
    position: "fixed",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: "calc(100vw - 40px)",
    boxSizing: "border-box",
    animation: `${modalAnimationDesktop} 300ms ease`,
    boxShadow: shadow.lg,
    lineHeight: "normal",
    border: `1px solid ${theme.colors.borderColor}`,
    outline: "none",
    overflow: "hidden",
    fontFamily: theme.fontFamily,
    "& *": {
      boxSizing: "border-box"
    },
    [media.mobile]: {
      top: "auto",
      bottom: 0,
      left: 0,
      right: 0,
      transform: "none",
      width: "100vw",
      animation: `${modalAnimationMobile} 0.35s cubic-bezier(0.15, 1.15, 0.6, 1)`,
      borderRadius: radius.xxl,
      borderBottomRightRadius: 0,
      borderBottomLeftRadius: 0,
      maxWidth: "none !important"
    },
    "& *::selection": {
      backgroundColor: theme.colors.selectedTextBg,
      color: theme.colors.selectedTextColor
    },
    ...noScrollBar
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/components/Drawer.js
var Drawer = (0, import_react10.forwardRef)(function Drawer_(props, ref) {
  return (0, import_jsx_runtime11.jsx)(import_jsx_runtime11.Fragment, { children: (0, import_jsx_runtime11.jsxs)(DrawerContainer, { ref, children: [(0, import_jsx_runtime11.jsx)(CrossContainer, { children: (0, import_jsx_runtime11.jsx)(IconButton, { type: "button", "aria-label": "Close", onClick: props.close, children: (0, import_jsx_runtime11.jsx)(Cross2Icon, { width: iconSize.md, height: iconSize.md, style: {
    color: "inherit"
  } }) }) }), props.children] }) });
});
var DrawerContainer = StyledDiv((_) => {
  const theme = useCustomTheme();
  return {
    zIndex: 1e4,
    padding: spacing.lg,
    borderTopLeftRadius: radius.xl,
    borderTopRightRadius: radius.xl,
    background: theme.colors.modalBg,
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    animation: `${drawerOpenAnimation} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.1)`,
    borderTop: `1px solid ${theme.colors.borderColor}`
  };
});
var drawerOpenAnimation = keyframes`
  from {
    opacity: 0;
    transform: translateY(100px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
var DrawerOverlay = StyledDiv((_) => {
  const theme = useCustomTheme();
  return {
    backgroundColor: theme.colors.modalOverlayBg,
    zIndex: 9999,
    position: "absolute",
    inset: 0,
    animation: `${fadeInAnimation} 400ms cubic-bezier(0.16, 1, 0.3, 1)`
  };
});
function useDrawer() {
  const drawerRef = (0, import_react10.useRef)(null);
  const drawerOverlayRef = (0, import_react10.useRef)(null);
  const onClose = (closeDrawer) => {
    var _a;
    if (drawerRef.current) {
      const animOptions = {
        easing: "cubic-bezier(0.175, 0.885, 0.32, 1.1)",
        fill: "forwards",
        duration: 300
      };
      const closeAnimation = drawerRef.current.animate([{ transform: "translateY(100%)", opacity: 0 }], animOptions);
      (_a = drawerOverlayRef.current) == null ? void 0 : _a.animate([{ opacity: 0 }], animOptions);
      closeAnimation.onfinish = closeDrawer;
    } else {
      closeDrawer();
    }
  };
  return {
    drawerRef,
    drawerOverlayRef,
    onClose
  };
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/SwitchNetwork.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/core/hooks/wallets/useSwitchActiveWalletChain.js
function useSwitchActiveWalletChainCore(manager) {
  return manager.switchActiveWalletChain;
}

// node_modules/thirdweb/dist/esm/react/web/hooks/wallets/useSwitchActiveWalletChain.js
function useSwitchActiveWalletChain() {
  return useSwitchActiveWalletChainCore(connectionManager);
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/SwitchNetwork.js
function SwitchNetworkButton(props) {
  const [isSwitching, setIsSwitching] = (0, import_react11.useState)(false);
  const switchActiveWalletChain = useSwitchActiveWalletChain();
  return (0, import_jsx_runtime12.jsx)(Button, { ...props, gap: "xs", onClick: async () => {
    setIsSwitching(true);
    try {
      await switchActiveWalletChain(props.chain);
    } catch {
    }
    setIsSwitching(false);
  }, children: isSwitching ? (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: ["Switching", (0, import_jsx_runtime12.jsx)(Spinner, { size: "sm", color: "accentButtonText" })] }) : "Switch Network" });
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/TokenIcon.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/nativeToken.js
var NATIVE_TOKEN = { nativeToken: true };
function isNativeToken(token) {
  return "nativeToken" in token;
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/TokenIcon.js
function TokenIcon(props) {
  const chainQuery = useChainQuery(props.chain);
  const tokenImage = (0, import_react12.useMemo)(() => {
    var _a, _b;
    if (isNativeToken(props.token) || props.token.address === NATIVE_TOKEN_ADDRESS) {
      return (_b = (_a = chainQuery.data) == null ? void 0 : _a.icon) == null ? void 0 : _b.url;
    }
    return props.token.icon;
  }, [props.token, chainQuery.data]);
  return (0, import_jsx_runtime13.jsx)(Img, { src: tokenImage || "", width: iconSize[props.size], height: iconSize[props.size], fallbackImage: genericTokenIcon, client: props.client });
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/token/TokenSymbol.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function TokenSymbol(props) {
  if (!isNativeToken(props.token)) {
    return (0, import_jsx_runtime14.jsx)(Text, { size: props.size, color: props.color || "primaryText", inline: props.inline, children: props.token.symbol });
  }
  return (0, import_jsx_runtime14.jsx)(NativeTokenSymbol, { chain: props.chain, size: props.size, color: props.color, inline: props.inline });
}
function NativeTokenSymbol(props) {
  var _a;
  const chainQuery = useChainQuery(props.chain);
  if (!chainQuery.isFetched) {
    return (0, import_jsx_runtime14.jsx)(Skeleton, { width: "70px", height: fontSize[props.size] });
  }
  return (0, import_jsx_runtime14.jsx)(Text, { size: props.size, color: props.color || "primaryText", inline: props.inline, children: ((_a = chainQuery.data) == null ? void 0 : _a.nativeCurrency.symbol) ?? "ETH" });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/NetworkSelector.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/components/ChainIcon.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var fallbackChainIcon = "data:image/svg+xml;charset=UTF-8,%3csvg width='15' height='14' viewBox='0 0 15 14' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M7 8.04238e-07C5.1435 8.04238e-07 3.36301 0.737501 2.05025 2.05025C0.7375 3.36301 0 5.1435 0 7C0 7.225 -1.52737e-07 7.445 0.0349998 7.665C0.16385 9.0151 0.68213 10.2988 1.52686 11.3598C2.37158 12.4209 3.50637 13.2137 4.79326 13.642C6.0801 14.0702 7.4637 14.1153 8.7758 13.7719C10.0879 13.4285 11.2719 12.7113 12.184 11.7075C13.0961 10.7038 13.6969 9.4567 13.9135 8.1178C14.1301 6.7789 13.9531 5.406 13.4039 4.16587C12.8548 2.92574 11.9573 1.87184 10.8204 1.13228C9.6835 0.392721 8.3563 -0.000649196 7 8.04238e-07ZM7 1C8.581 1.00137 10.0975 1.62668 11.22 2.74V3.24C9.2438 2.55991 7.0956 2.56872 5.125 3.265C4.96758 3.1116 4.76997 3.00586 4.555 2.96H4.43C4.37 2.75 4.315 2.54 4.27 2.325C4.225 2.11 4.2 1.92 4.175 1.715C5.043 1.24658 6.0137 1.00091 7 1ZM5.5 3.935C7.3158 3.32693 9.2838 3.34984 11.085 4C10.8414 5.2703 10.3094 6.4677 9.53 7.5C9.312 7.4077 9.0707 7.3855 8.8395 7.4366C8.6083 7.4877 8.3988 7.6094 8.24 7.785C8.065 7.685 7.89 7.585 7.74 7.47C6.7307 6.7966 5.8877 5.9023 5.275 4.855C5.374 4.73221 5.4461 4.58996 5.4866 4.43749C5.5271 4.28502 5.5351 4.12575 5.51 3.97L5.5 3.935ZM3.5 2.135C3.5 2.24 3.53 2.35 3.55 2.455C3.595 2.675 3.655 2.89 3.715 3.105C3.52353 3.21838 3.36943 3.38531 3.2717 3.58522C3.17397 3.78513 3.13688 4.00927 3.165 4.23C2.37575 4.7454 1.67078 5.3795 1.075 6.11C1.19455 5.3189 1.47112 4.55966 1.88843 3.87701C2.30575 3.19437 2.85539 2.60208 3.505 2.135H3.5ZM3.5 9.99C3.30481 10.0555 3.13037 10.1714 2.9943 10.3259C2.85822 10.4804 2.76533 10.6681 2.725 10.87H2.405C1.59754 9.9069 1.1146 8.7136 1.025 7.46L1.08 7.365C1.70611 6.3942 2.52463 5.562 3.485 4.92C3.62899 5.0704 3.81094 5.179 4.01162 5.2345C4.2123 5.2899 4.42423 5.2901 4.625 5.235C5.2938 6.3652 6.208 7.3306 7.3 8.06C7.505 8.195 7.715 8.32 7.925 8.44C7.9082 8.6312 7.9391 8.8237 8.015 9C7.1 9.7266 6.0445 10.256 4.915 10.555C4.78401 10.3103 4.57028 10.1201 4.31199 10.0184C4.05369 9.9167 3.76766 9.9102 3.505 10L3.5 9.99ZM7 12.99C5.9831 12.9903 4.98307 12.7304 4.095 12.235L4.235 12.205C4.43397 12.1397 4.61176 12.0222 4.74984 11.8648C4.88792 11.7074 4.98122 11.5158 5.02 11.31C6.2985 10.984 7.4921 10.3872 8.52 9.56C8.7642 9.7027 9.0525 9.75 9.3295 9.6927C9.6064 9.6355 9.8524 9.4778 10.02 9.25C10.7254 9.4334 11.4511 9.5275 12.18 9.53H12.445C11.9626 10.5673 11.1938 11.4451 10.2291 12.0599C9.2643 12.6747 8.144 13.0009 7 13V12.99ZM10.255 8.54C10.2545 8.3304 10.1975 8.1249 10.09 7.945C10.9221 6.8581 11.5012 5.5991 11.785 4.26C12.035 4.37667 12.2817 4.50667 12.525 4.65C13.0749 5.9495 13.1493 7.4012 12.735 8.75C11.9049 8.8142 11.0698 8.7484 10.26 8.555L10.255 8.54Z' fill='%23646D7A'/%3e%3c/svg%3e";
var ChainIcon = (props) => {
  const getSrc = () => {
    var _a;
    const url = (_a = props.chainIcon) == null ? void 0 : _a.url;
    if (!url) {
      return fallbackChainIcon;
    }
    try {
      return resolveScheme({
        uri: url,
        client: props.client
      });
    } catch {
      return fallbackChainIcon;
    }
  };
  return (0, import_jsx_runtime15.jsxs)("div", { style: {
    position: "relative",
    display: "flex",
    flexShrink: 0,
    alignItems: "center"
  }, children: [(0, import_jsx_runtime15.jsx)(Img, { src: getSrc(), width: props.size, height: props.size, fallbackImage: fallbackChainIcon, client: props.client }), props.active && (0, import_jsx_runtime15.jsx)(ActiveDot, {})] });
};
var ActiveDot = StyledDiv({
  width: "28%",
  height: "28%",
  borderRadius: "50%",
  position: "absolute",
  top: "60%",
  right: 0,
  backgroundColor: "#00d395",
  boxShadow: "0 0 0 2px var(--bg)"
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/NetworkSelector.js
var fuseInstances = void 0;
var fuseInitializationStarted = false;
function initializeFuseInstances() {
  if (fuseInitializationStarted) {
    return;
  }
  fuseInitializationStarted = true;
  const fuseConfig = {
    threshold: 0.4,
    keys: [
      {
        name: "name",
        weight: 1
      },
      {
        name: "chainId",
        weight: 1
      }
    ]
  };
  fuseInstances = {
    all: new Fuse([], fuseConfig),
    popular: new Fuse([], fuseConfig),
    recent: new Fuse([], fuseConfig)
  };
}
function useLoadChains(allChainsInput, popularChainIds, recentChainIds) {
  const chainsQueries = useChainsQuery(allChainsInput, 50);
  const isLoading = chainsQueries.some((q) => q.isLoading);
  const { allChains, chainsMap } = (0, import_react13.useMemo)(() => {
    const _chains = [];
    const _chainsMap = /* @__PURE__ */ new Map();
    if (isLoading) {
      return { allChains: [], chainsMap: _chainsMap };
    }
    for (const chainQuery of chainsQueries) {
      if (chainQuery.data) {
        _chains.push({
          ...chainQuery.data
        });
      }
    }
    for (const chain of _chains) {
      _chainsMap.set(chain.chainId, chain);
    }
    return { allChains: _chains, chainsMap: _chainsMap, isLoading: false };
  }, [chainsQueries, isLoading]);
  const recentChains = (0, import_react13.useMemo)(() => {
    if (!recentChainIds) {
      return [];
    }
    const _recentChains = [];
    for (const chainId of recentChainIds) {
      const _chain = chainsMap.get(chainId);
      if (_chain) {
        _recentChains.push(_chain);
      }
    }
    return _recentChains;
  }, [recentChainIds, chainsMap]);
  const popularChains = (0, import_react13.useMemo)(() => {
    if (!popularChainIds) {
      return [];
    }
    const _popularChains = [];
    for (const chainId of popularChainIds) {
      const _chain = chainsMap.get(chainId);
      if (_chain) {
        _popularChains.push(_chain);
      }
    }
    return _popularChains;
  }, [popularChainIds, chainsMap]);
  return {
    allChains,
    popularChains,
    recentChains,
    isLoading
  };
}
function NetworkSelectorContent(props) {
  var _a, _b;
  const chainsData = useLoadChains(props.chains, ((_a = props.networkSelector) == null ? void 0 : _a.popularChainIds) || [], ((_b = props.networkSelector) == null ? void 0 : _b.recentChainIds) || []);
  initializeFuseInstances();
  return (0, import_jsx_runtime16.jsx)(NetworkSelectorContentInner, { ...props, chainsData });
}
function NetworkSelectorContentInner(props) {
  var _a, _b, _c;
  const { chainsData, connectLocale } = props;
  const chainMap = (0, import_react13.useMemo)(() => {
    const _chainMap = /* @__PURE__ */ new Map();
    for (const chain of props.chains) {
      _chainMap.set(chain.id, chain);
    }
    return _chainMap;
  }, [props.chains]);
  const locale = connectLocale.networkSelector;
  const [searchTerm, setSearchTerm] = (0, import_react13.useState)("");
  const [selectedTab, setSelectedTab] = (0, import_react13.useState)("all");
  const deferredSearchTerm = useDebouncedValue(searchTerm, 300);
  const { onSwitch, onCustomClick } = props.networkSelector || {};
  const allChainsTab = (0, import_react13.useMemo)(() => {
    return filterChainByType(chainsData.allChains, selectedTab);
  }, [chainsData.allChains, selectedTab]);
  const popularChainsTab = (0, import_react13.useMemo)(() => {
    return filterChainByType(chainsData.popularChains, selectedTab);
  }, [chainsData.popularChains, selectedTab]);
  const recentChainsTab = (0, import_react13.useMemo)(() => {
    return filterChainByType(chainsData.recentChains, selectedTab);
  }, [chainsData.recentChains, selectedTab]);
  const allChainsFiltered = (0, import_react13.useMemo)(() => {
    if (!fuseInstances) {
      return allChainsTab;
    }
    if (deferredSearchTerm === "") {
      return allChainsTab;
    }
    fuseInstances.all.setCollection(allChainsTab);
    return fuseInstances.all.search(deferredSearchTerm).map((r) => r.item);
  }, [allChainsTab, deferredSearchTerm]);
  const popularChainsFiltered = (0, import_react13.useMemo)(() => {
    if (!fuseInstances) {
      return popularChainsTab;
    }
    if (deferredSearchTerm === "") {
      return popularChainsTab;
    }
    fuseInstances.popular.setCollection(popularChainsTab);
    return fuseInstances.popular.search(deferredSearchTerm).map((r) => r.item);
  }, [deferredSearchTerm, popularChainsTab]);
  const recentChainsFiltered = (0, import_react13.useMemo)(() => {
    if (!fuseInstances) {
      return recentChainsTab;
    }
    if (deferredSearchTerm === "") {
      return recentChainsTab;
    }
    fuseInstances.recent.setCollection(recentChainsTab);
    return fuseInstances.recent.search(deferredSearchTerm).map((r) => r.item);
  }, [deferredSearchTerm, recentChainsTab]);
  const handleSwitch = (0, import_react13.useCallback)((chain) => {
    if (onSwitch) {
      onSwitch(chain);
    }
    props.closeModal();
  }, [onSwitch, props]);
  const allChainsToShow = (0, import_react13.useMemo)(() => {
    if (chainsData.isLoading) {
      return props.chains;
    }
    return allChainsFiltered.map(convertApiChainToChain);
  }, [allChainsFiltered, chainsData.isLoading, props.chains]);
  const popularChainsToShow = (0, import_react13.useMemo)(() => {
    var _a2, _b2;
    if (chainsData.isLoading) {
      return ((_b2 = (_a2 = props.networkSelector) == null ? void 0 : _a2.popularChainIds) == null ? void 0 : _b2.map((id) => chainMap.get(id))) || [];
    }
    return popularChainsFiltered.map(convertApiChainToChain);
  }, [
    chainMap,
    chainsData.isLoading,
    popularChainsFiltered,
    (_a = props.networkSelector) == null ? void 0 : _a.popularChainIds
  ]);
  const recentChainsToShow = (0, import_react13.useMemo)(() => {
    var _a2, _b2;
    if (chainsData.isLoading) {
      return ((_b2 = (_a2 = props.networkSelector) == null ? void 0 : _a2.recentChainIds) == null ? void 0 : _b2.map((id) => chainMap.get(id))) || [];
    }
    return recentChainsFiltered.map(convertApiChainToChain);
  }, [
    chainMap,
    chainsData.isLoading,
    (_b = props.networkSelector) == null ? void 0 : _b.recentChainIds,
    recentChainsFiltered
  ]);
  return (0, import_jsx_runtime16.jsxs)(Container, { children: [(0, import_jsx_runtime16.jsx)(Container, { p: "lg", children: props.onBack ? (0, import_jsx_runtime16.jsx)(ModalHeader, { title: locale.title, onBack: props.onBack }) : (0, import_jsx_runtime16.jsx)(ModalTitle, { children: locale.title }) }), props.showTabs !== false && (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [(0, import_jsx_runtime16.jsx)(Container, { px: "lg", children: (0, import_jsx_runtime16.jsxs)(Container, { flex: "row", gap: "xxs", children: [(0, import_jsx_runtime16.jsx)(TabButton, { onClick: () => setSelectedTab("all"), "data-active": selectedTab === "all", children: locale.allNetworks }), (0, import_jsx_runtime16.jsx)(TabButton, { onClick: () => setSelectedTab("mainnet"), "data-active": selectedTab === "mainnet", children: locale.mainnets }), (0, import_jsx_runtime16.jsx)(TabButton, { onClick: () => setSelectedTab("testnet"), "data-active": selectedTab === "testnet", children: locale.testnets })] }) }), (0, import_jsx_runtime16.jsx)(Spacer, { y: "lg" })] }), props.showTabs === false && (0, import_jsx_runtime16.jsx)(Spacer, { y: "xxs" }), (0, import_jsx_runtime16.jsx)(Container, { px: "lg", children: (0, import_jsx_runtime16.jsxs)("div", { style: {
    display: "flex",
    alignItems: "center",
    position: "relative"
  }, children: [(0, import_jsx_runtime16.jsx)(StyledMagnifyingGlassIcon, { width: iconSize.md, height: iconSize.md }), (0, import_jsx_runtime16.jsx)(Input, { style: {
    padding: `${spacing.sm} ${spacing.md} ${spacing.sm} ${spacing.xxl}`
  }, tabIndex: -1, variant: "outline", disabled: chainsData.isLoading, placeholder: chainsData.isLoading ? "Loading chains..." : locale.inputPlaceholder, value: searchTerm, onChange: (e) => {
    setSearchTerm(e.target.value);
  } }), (deferredSearchTerm !== searchTerm || chainsData.isLoading) && (0, import_jsx_runtime16.jsx)("div", { style: {
    position: "absolute",
    right: spacing.md
  }, children: (0, import_jsx_runtime16.jsx)(Spinner, { size: "md", color: "accentText" }) })] }) }), (0, import_jsx_runtime16.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime16.jsx)(Container, { px: "md", children: (0, import_jsx_runtime16.jsx)(NetworkTabContent, { allChainIds: allChainsToShow, popularChainIds: popularChainsToShow, recentChainIds: recentChainsToShow, onSwitch: handleSwitch, renderChain: (_c = props.networkSelector) == null ? void 0 : _c.renderChain, connectLocale, client: props.client, close: props.closeModal }) }), onCustomClick && (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [(0, import_jsx_runtime16.jsx)(Line, {}), (0, import_jsx_runtime16.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime16.jsx)(Button, { fullWidth: true, variant: "link", onClick: () => {
    onCustomClick();
  }, style: {
    display: "flex",
    fontSize: fontSize.sm,
    boxShadow: "none"
  }, children: locale.addCustomNetwork }) })] })] });
}
var filterChainByType = (chains, type) => {
  if (type === "all") {
    return chains;
  }
  if (type === "testnet") {
    return chains.filter((c) => c.testnet);
  }
  return chains.filter((c) => !c.testnet);
};
var NetworkTabContent = (props) => {
  const locale = props.connectLocale.networkSelector.categoryLabel;
  const { recentChainIds, popularChainIds, allChainIds } = props;
  const noChainsToShow = (recentChainIds == null ? void 0 : recentChainIds.length) === 0 && (popularChainIds == null ? void 0 : popularChainIds.length) === 0 && allChainIds.length === 0;
  return (0, import_jsx_runtime16.jsxs)(Container, { scrollY: true, animate: "fadein", style: {
    height: "330px",
    paddingBottom: spacing.lg
  }, children: [recentChainIds && recentChainIds.length > 0 && (0, import_jsx_runtime16.jsxs)("div", { children: [(0, import_jsx_runtime16.jsx)(SectionLabel, { children: locale.recentlyUsed }), (0, import_jsx_runtime16.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime16.jsx)(NetworkList, { chains: recentChainIds, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale }), (0, import_jsx_runtime16.jsx)(Spacer, { y: "lg" })] }), popularChainIds && popularChainIds.length > 0 && (0, import_jsx_runtime16.jsxs)("div", { children: [(0, import_jsx_runtime16.jsx)(SectionLabel, { children: locale.popular }), (0, import_jsx_runtime16.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime16.jsx)(NetworkList, { chains: popularChainIds, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale }), (0, import_jsx_runtime16.jsx)(Spacer, { y: "lg" })] }), (popularChainIds && popularChainIds.length > 0 || recentChainIds && recentChainIds.length > 0) && (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [(0, import_jsx_runtime16.jsx)(SectionLabel, { children: locale.others }), (0, import_jsx_runtime16.jsx)(Spacer, { y: "sm" })] }), (0, import_jsx_runtime16.jsx)(NetworkList, { chains: allChainIds, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale }), noChainsToShow && (0, import_jsx_runtime16.jsxs)(Container, { flex: "column", gap: "md", center: "both", color: "secondaryText", children: [(0, import_jsx_runtime16.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime16.jsx)(CrossCircledIcon, { width: iconSize.xl, height: iconSize.xl }), (0, import_jsx_runtime16.jsx)(Text, { children: " No Results " })] })] });
};
var NetworkList = (0, import_react13.memo)(function NetworkList2(props) {
  const { itemsToShow, lastItemRef } = useShowMore(10, 10);
  const switchChain = useSwitchActiveWalletChain();
  const activeChain = useActiveWalletChain();
  const [switchingChainId, setSwitchingChainId] = (0, import_react13.useState)(-1);
  const [errorSwitchingChainId, setErrorSwitchingChainId] = (0, import_react13.useState)(-1);
  const close = props.close;
  (0, import_react13.useEffect)(() => {
    if (switchingChainId !== -1 && (activeChain == null ? void 0 : activeChain.id) === switchingChainId) {
      if (close) {
        close();
      }
    }
  }, [switchingChainId, close, activeChain == null ? void 0 : activeChain.id]);
  const handleSwitch = async (chain) => {
    setErrorSwitchingChainId(-1);
    setSwitchingChainId(chain.id);
    try {
      await switchChain(chain);
      props.onSwitch(chain);
    } catch (e) {
      setErrorSwitchingChainId(chain.id);
      console.error(e);
    } finally {
      setSwitchingChainId(-1);
    }
  };
  const RenderChain = props.renderChain;
  const chainsToShow = props.chains.slice(0, itemsToShow);
  return (0, import_jsx_runtime16.jsx)(NetworkListUl, { children: chainsToShow.map((chain, i) => {
    if (!chain) {
      return null;
    }
    const confirming = switchingChainId === chain.id;
    const switchingFailed = errorSwitchingChainId === chain.id;
    const isLast = i === chainsToShow.length - 1;
    return (0, import_jsx_runtime16.jsx)("li", { ref: isLast ? lastItemRef : void 0, children: RenderChain ? (0, import_jsx_runtime16.jsx)(RenderChain, { switchChain: () => {
      handleSwitch(chain);
    }, chain, switching: switchingChainId === chain.id, switchFailed: errorSwitchingChainId === chain.id, close: props.close }) : (0, import_jsx_runtime16.jsx)(ChainButton, { chain, confirming, onClick: () => handleSwitch(chain), switchingFailed, client: props.client, connectLocale: props.connectLocale }) }, chain.id);
  }) });
});
var ChainButton = (0, import_react13.memo)(function ChainButton2(props) {
  const locale = props.connectLocale;
  const { chain, confirming, switchingFailed } = props;
  const activeChain = useActiveWalletChain();
  const { data: fetchedChain } = useChainQuery(chain);
  let chainName;
  if (fetchedChain) {
    chainName = (0, import_jsx_runtime16.jsxs)("span", { children: [fetchedChain.name, " "] });
  } else {
    chainName = (0, import_jsx_runtime16.jsx)(Skeleton, { width: "150px", height: "20px" });
  }
  return (0, import_jsx_runtime16.jsxs)(NetworkButton, { "data-active": (activeChain == null ? void 0 : activeChain.id) === chain.id, onClick: props.onClick, children: [fetchedChain ? (0, import_jsx_runtime16.jsx)(ChainIcon, { chainIcon: fetchedChain.icon, size: iconSize.lg, active: (activeChain == null ? void 0 : activeChain.id) === chain.id, loading: "lazy", client: props.client }) : (0, import_jsx_runtime16.jsx)(Skeleton, { width: `${iconSize.lg}px`, height: `${iconSize.lg}px` }), confirming || switchingFailed ? (0, import_jsx_runtime16.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "column",
    gap: spacing.xs
  }, children: [chainName, (0, import_jsx_runtime16.jsxs)(Container, { animate: "fadein", flex: "row", gap: "xxs", center: "y", children: [confirming && (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [(0, import_jsx_runtime16.jsx)(Text, { size: "xs", color: "accentText", children: locale.confirmInWallet }), (0, import_jsx_runtime16.jsx)(Spinner, { size: "xs", color: "accentText" })] }), switchingFailed && (0, import_jsx_runtime16.jsx)(Container, { animate: "fadein", children: (0, import_jsx_runtime16.jsx)(Text, { size: "xs", color: "danger", children: locale.networkSelector.failedToSwitch }) })] })] }) : chainName] });
});
var TabButton = (() => newStyled.button((_) => {
  const theme = useCustomTheme();
  return {
    all: "unset",
    fontSize: fontSize.sm,
    fontWeight: 500,
    color: theme.colors.secondaryText,
    cursor: "pointer",
    padding: `${spacing.sm} ${spacing.sm}`,
    WebkitTapHighlightColor: "transparent",
    borderRadius: radius.lg,
    transition: "background 0.2s ease, color 0.2s ease",
    "&[data-active='true']": {
      background: theme.colors.secondaryButtonBg,
      color: theme.colors.primaryText
    }
  };
}))();
var SectionLabel = StyledP(() => {
  const theme = useCustomTheme();
  return {
    fontSize: fontSize.sm,
    color: theme.colors.secondaryText,
    margin: 0,
    display: "block",
    padding: `0 ${spacing.xs}`
  };
});
var NetworkListUl = StyledUl({
  padding: 0,
  margin: 0,
  listStyle: "none",
  display: "flex",
  flexDirection: "column",
  gap: spacing.xs,
  boxSizing: "border-box"
});
var NetworkButton = StyledButton((_) => {
  const theme = useCustomTheme();
  return {
    all: "unset",
    display: "flex",
    width: "100%",
    boxSizing: "border-box",
    alignItems: "center",
    gap: spacing.md,
    padding: `${spacing.xs} ${spacing.sm}`,
    borderRadius: radius.md,
    cursor: "pointer",
    transition: "background 0.2s ease",
    color: theme.colors.primaryText,
    fontWeight: 500,
    fontSize: fontSize.md,
    "&:hover": {
      background: theme.colors.secondaryButtonBg
    },
    [media.mobile]: {
      fontSize: fontSize.sm
    }
  };
});
var StyledMagnifyingGlassIcon = newStyled(MagnifyingGlassIcon)((_) => {
  const theme = useCustomTheme();
  return {
    color: theme.colors.secondaryText,
    position: "absolute",
    left: spacing.sm
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/icons/CoinsIcon.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var CoinsIcon = (props) => {
  return (0, import_jsx_runtime17.jsxs)("svg", { width: props.size, height: props.size, role: "presentation", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime17.jsx)("path", { d: "M8 14C11.3137 14 14 11.3137 14 8C14 4.68629 11.3137 2 8 2C4.68629 2 2 4.68629 2 8C2 11.3137 4.68629 14 8 14Z", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime17.jsx)("path", { d: "M18.0901 10.37C19.0354 10.7224 19.8766 11.3075 20.5358 12.0712C21.1951 12.8349 21.6512 13.7524 21.8618 14.7391C22.0725 15.7257 22.031 16.7495 21.7411 17.7158C21.4513 18.6822 20.9224 19.5598 20.2035 20.2676C19.4846 20.9754 18.5988 21.4905 17.6281 21.7652C16.6573 22.04 15.633 22.0655 14.6498 21.8395C13.6666 21.6134 12.7562 21.1431 12.0029 20.472C11.2496 19.8009 10.6777 18.9507 10.3401 18", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime17.jsx)("path", { d: "M7 6H8V10", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime17.jsx)("path", { d: "M16.7101 13.88L17.4101 14.59L14.5901 17.41", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })] });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/TokenSelector.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/wallets/utils/getTokenBalance.js
async function getTokenBalance(options) {
  const { account, client, chain, tokenAddress } = options;
  if (tokenAddress) {
    const { getBalance } = await import("./getBalance-BTIWBAJD.js");
    return getBalance({
      contract: getContract({ client, chain, address: tokenAddress }),
      address: account.address
    });
  }
  const rpcRequest = getRpcClient({ client, chain });
  const [nativeSymbol, nativeDecimals, nativeName, nativeBalance] = await Promise.all([
    getChainSymbol(chain),
    getChainDecimals(chain),
    getChainNativeCurrencyName(chain),
    eth_getBalance(rpcRequest, { address: account.address })
  ]);
  return {
    value: nativeBalance,
    decimals: nativeDecimals,
    displayValue: toTokens(nativeBalance, nativeDecimals),
    symbol: nativeSymbol,
    name: nativeName
  };
}

// node_modules/thirdweb/dist/esm/react/core/hooks/others/useTokenInfo.js
function useTokenInfo(options) {
  const { chain, tokenAddress, client } = options;
  return useQuery({
    queryKey: ["tokenInfo", (chain == null ? void 0 : chain.id) || -1, { tokenAddress }],
    queryFn: async () => {
      if (tokenAddress) {
        const { getCurrencyMetadata } = await import("./getCurrencyMetadata-VZUAMCUL.js");
        const result2 = await getCurrencyMetadata({
          contract: getContract({ client, chain, address: tokenAddress })
        });
        return result2;
      }
      const { getChainDecimals: getChainDecimals2, getChainNativeCurrencyName: getChainNativeCurrencyName2, getChainSymbol: getChainSymbol2 } = await import("./utils-NURKBI3F.js");
      const [nativeSymbol, nativeDecimals, nativeName] = await Promise.all([
        getChainSymbol2(chain),
        getChainDecimals2(chain),
        getChainNativeCurrencyName2(chain)
      ]);
      const result = {
        decimals: nativeDecimals,
        symbol: nativeSymbol,
        name: nativeName
      };
      return result;
    },
    enabled: !!chain && !!client
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/formatTokenBalance.js
function formatTokenBalance(balanceData, showSymbol = true) {
  return Number(balanceData.displayValue).toFixed(3) + (showSymbol ? ` ${balanceData.symbol}` : "");
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/TokenSelector.js
function TokenSelector(props) {
  var _a;
  const [screen, setScreen] = (0, import_react14.useState)("base");
  const [input, setInput] = (0, import_react14.useState)("");
  const chain = props.chain;
  const chainQuery = useChainQuery(chain);
  const tokenQuery = useTokenInfo({
    chain,
    tokenAddress: input,
    client: props.client
  });
  const locale = props.connectLocale.sendFundsScreen;
  let tokenList = props.tokenList;
  if (tokenQuery.data && input) {
    tokenList = [
      {
        ...tokenQuery.data,
        address: input
      },
      ...tokenList
    ];
  }
  const filteredList = input ? tokenList.filter((t) => {
    const inputStr = input.toLowerCase();
    return t.name.toLowerCase().includes(inputStr) || t.symbol.toLowerCase().includes(inputStr) || t.address.includes(input);
  }) : tokenList;
  const { chainSelection } = props;
  if (screen === "select-chain" && chainSelection) {
    return (0, import_jsx_runtime18.jsx)(NetworkSelectorContent, {
      client: props.client,
      connectLocale: props.connectLocale,
      showTabs: false,
      onBack: () => setScreen("base"),
      // pass swap supported chains
      chains: chainSelection.chains,
      closeModal: () => setScreen("base"),
      networkSelector: {
        renderChain(renderChainProps) {
          return (0, import_jsx_runtime18.jsx)(ChainButton, { chain: renderChainProps.chain, confirming: false, switchingFailed: false, onClick: () => {
            chainSelection.select(renderChainProps.chain);
            setScreen("base");
          }, client: props.client, connectLocale: props.connectLocale });
        }
      }
    });
  }
  return (0, import_jsx_runtime18.jsxs)(Container, { animate: "fadein", style: {
    minHeight: "300px"
  }, children: [(0, import_jsx_runtime18.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime18.jsx)(ModalHeader, { onBack: props.onBack, title: props.modalTitle || locale.selectTokenTitle }) }), (0, import_jsx_runtime18.jsx)(Line, {}), (0, import_jsx_runtime18.jsxs)(Container, { scrollY: true, style: {
    maxHeight: "450px"
  }, children: [(0, import_jsx_runtime18.jsx)(Spacer, { y: "md" }), props.chainSelection && (0, import_jsx_runtime18.jsx)(import_jsx_runtime18.Fragment, { children: (0, import_jsx_runtime18.jsxs)(Container, { px: "lg", children: [(0, import_jsx_runtime18.jsx)(Text, { size: "sm", children: "Select Network" }), (0, import_jsx_runtime18.jsx)(Spacer, { y: "xxs" }), (0, import_jsx_runtime18.jsxs)(SelectTokenBtn, { fullWidth: true, variant: "secondary", onClick: () => {
    setScreen("select-chain");
  }, children: [(0, import_jsx_runtime18.jsx)(ChainIcon, { chainIcon: (_a = chainQuery.data) == null ? void 0 : _a.icon, size: iconSize.lg, client: props.client }), chainQuery.data ? (0, import_jsx_runtime18.jsxs)(Text, { color: "primaryText", size: "sm", children: [" ", chainQuery.data.name] }) : (0, import_jsx_runtime18.jsx)(Skeleton, { height: fontSize.md }), (0, import_jsx_runtime18.jsx)(ChevronDownIcon, { width: iconSize.sm, height: iconSize.sm, style: {
    marginLeft: "auto"
  } })] }), (0, import_jsx_runtime18.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime18.jsx)(Text, { size: "sm", children: "Select Token" })] }) }), (0, import_jsx_runtime18.jsxs)(Container, { px: "lg", children: [(0, import_jsx_runtime18.jsx)(Spacer, { y: "xs" }), (0, import_jsx_runtime18.jsx)(Input, { placeholder: locale.searchToken, variant: "outline", value: input, onChange: (e) => {
    setInput(e.target.value);
  } })] }), (0, import_jsx_runtime18.jsx)(Spacer, { y: "md" }), (filteredList.length > 0 || !input) && (0, import_jsx_runtime18.jsxs)(Container, { flex: "column", gap: "xs", px: "lg", scrollY: true, style: {
    paddingTop: 0,
    paddingBottom: spacing.lg
    // maxHeight: props.chainSelection ? "300px" : "400px",
  }, children: [!input && (0, import_jsx_runtime18.jsx)(SelectTokenButton, { onClick: () => {
    props.onTokenSelect(NATIVE_TOKEN);
  }, chain: props.chain, token: NATIVE_TOKEN, client: props.client }), filteredList.map((token) => {
    return (0, import_jsx_runtime18.jsx)(SelectTokenButton, { onClick: () => props.onTokenSelect(token), token, chain: props.chain, client: props.client }, token.address);
  })] }), filteredList.length === 0 && tokenQuery.isLoading && input && (0, import_jsx_runtime18.jsx)(Container, { animate: "fadein", p: "lg", flex: "column", gap: "md", center: "both", style: {
    minHeight: "200px",
    paddingTop: 0
  }, color: "secondaryText", children: (0, import_jsx_runtime18.jsx)(Spinner, { size: "lg", color: "accentText" }) }), filteredList.length === 0 && !tokenQuery.isLoading && input && (0, import_jsx_runtime18.jsxs)(Container, { animate: "fadein", p: "lg", flex: "column", gap: "md", center: "both", style: {
    minHeight: "200px",
    paddingTop: 0
  }, color: "secondaryText", children: [(0, import_jsx_runtime18.jsx)(CrossCircledIcon, { width: iconSize.lg, height: iconSize.lg }), locale.noTokensFound] }), (0, import_jsx_runtime18.jsx)(Spacer, { y: "md" })] })] });
}
function SelectTokenButton(props) {
  var _a;
  const account = useActiveAccount();
  const tokenInfoQuery = useTokenInfo({
    chain: props.chain,
    tokenAddress: isNativeToken(props.token) ? void 0 : props.token.address,
    client: props.client
  });
  const tokenName = isNativeToken(props.token) ? (_a = tokenInfoQuery.data) == null ? void 0 : _a.name : props.token.name;
  return (0, import_jsx_runtime18.jsxs)(SelectTokenBtn, { fullWidth: true, variant: "secondary", onClick: props.onClick, children: [(0, import_jsx_runtime18.jsx)(TokenIcon, { token: props.token, chain: props.chain, size: "lg", client: props.client }), (0, import_jsx_runtime18.jsxs)(Container, { flex: "column", gap: "xxs", children: [tokenName ? (0, import_jsx_runtime18.jsx)(Text, { size: "sm", color: "primaryText", children: tokenName }) : (0, import_jsx_runtime18.jsx)(Skeleton, { height: fontSize.md, width: "150px" }), account && (0, import_jsx_runtime18.jsx)(TokenBalance, { account, chain: props.chain, client: props.client, tokenAddress: isNativeToken(props.token) ? void 0 : props.token.address })] })] });
}
function TokenBalance(props) {
  const tokenBalanceQuery = useQuery({
    queryKey: ["tokenBalance", props],
    queryFn: async () => {
      return getTokenBalance({
        account: props.account,
        chain: props.chain,
        client: props.client,
        tokenAddress: props.tokenAddress
      });
    }
  });
  if (tokenBalanceQuery.data) {
    return (0, import_jsx_runtime18.jsxs)(Text, { size: "xs", children: [" ", formatTokenBalance(tokenBalanceQuery.data)] });
  }
  return (0, import_jsx_runtime18.jsx)(Skeleton, { height: fontSize.xs, width: "100px" });
}
var SelectTokenBtn = newStyled(Button)(() => {
  const theme = useCustomTheme();
  return {
    background: theme.colors.tertiaryBg,
    justifyContent: "flex-start",
    gap: spacing.sm,
    padding: spacing.sm,
    "&:hover": {
      background: theme.colors.secondaryButtonBg,
      transform: "scale(1.01)"
    },
    transition: "background 200ms ease, transform 150ms ease"
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/EstimatedTimeAndFees.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/formatSeconds.js
function formatSeconds(seconds) {
  if (seconds > 3600) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    return `${hours} Hours ${minutes} Minutes`;
  }
  if (seconds > 60) {
    const minutes = Math.ceil(seconds / 60);
    return `${minutes} Minutes`;
  }
  return `${seconds}s`;
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/EstimatedTimeAndFees.js
function EstimatedTimeAndFees(props) {
  const { estimatedSeconds, quoteIsLoading } = props;
  return (0, import_jsx_runtime19.jsxs)(Container, { bg: "tertiaryBg", flex: "row", borderColor: "borderColor", style: {
    borderRadius: radius.md,
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    justifyContent: "space-between",
    alignItems: "center",
    borderWidth: "1px",
    borderStyle: "solid"
  }, children: [(0, import_jsx_runtime19.jsxs)(Container, { flex: "row", center: "y", gap: "xxs", color: "accentText", p: "sm", children: [(0, import_jsx_runtime19.jsx)(ClockIcon, { width: iconSize.sm, height: iconSize.sm }), quoteIsLoading ? (0, import_jsx_runtime19.jsx)(Skeleton, { height: fontSize.xs, width: "50px", color: "borderColor" }) : (0, import_jsx_runtime19.jsx)(Text, { size: "xs", color: "secondaryText", children: estimatedSeconds !== void 0 ? `~${formatSeconds(estimatedSeconds)}` : "--" })] }), (0, import_jsx_runtime19.jsxs)(Button, { variant: "ghost", onClick: props.onViewFees, gap: "xs", children: [(0, import_jsx_runtime19.jsx)(Container, { color: "accentText", flex: "row", center: "both", children: (0, import_jsx_runtime19.jsx)(ViewFeeIcon, { size: iconSize.sm }) }), (0, import_jsx_runtime19.jsx)(Text, { size: "xs", color: "secondaryText", children: "View Fees" })] })] });
}
var ViewFeeIcon = (props) => {
  return (0, import_jsx_runtime19.jsxs)("svg", { width: props.size, height: props.size, viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [(0, import_jsx_runtime19.jsx)("path", { d: "M9.5 1.5H2.5C1.94772 1.5 1.5 1.94772 1.5 2.5V9.5C1.5 10.0523 1.94772 10.5 2.5 10.5H9.5C10.0523 10.5 10.5 10.0523 10.5 9.5V2.5C10.5 1.94772 10.0523 1.5 9.5 1.5Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime19.jsx)("path", { d: "M4.5 7.5L7.5 4.5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" })] });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/PayTokenIcon.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/useSwapSupportedChains.js
async function fetchBuySupportedDestinations(client) {
  return withCache(async () => {
    const fetchWithHeaders = getClientFetch(client);
    const res = await fetchWithHeaders(getPaySupportedDestinations());
    const data = await res.json();
    return data.result.map((item) => ({
      chain: defineChain({
        id: item.chainId
      }),
      tokens: item.tokens
    }));
  }, {
    cacheKey: "destination-tokens",
    cacheTime: 5 * 60 * 1e3
  });
}
function useBuySupportedDestinations(client) {
  return useQuery({
    queryKey: ["destination-tokens", client],
    queryFn: async () => {
      return fetchBuySupportedDestinations(client);
    }
  });
}
function useBuySupportedSources(options) {
  return useQuery({
    queryKey: ["source-tokens", options],
    queryFn: async () => {
      const fetchWithHeaders = getClientFetch(options.client);
      const baseUrl = getPaySupportedSources();
      const url = new URL(baseUrl);
      url.searchParams.append("destinationChainId", options.destinationChainId.toString());
      url.searchParams.append("destinationTokenAddress", options.destinationTokenAddress);
      const res = await fetchWithHeaders(url.toString());
      const data = await res.json();
      return data.result.map((item) => ({
        chain: defineChain({
          id: item.chainId
        }),
        tokens: item.tokens
      }));
    }
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/PayTokenIcon.js
function PayTokenIcon(props) {
  var _a, _b, _c;
  const supportedDestinationsQuery = useBuySupportedDestinations(props.client);
  const token = props.token;
  const tokenIcon = !isNativeToken(token) ? (_c = (_b = (_a = supportedDestinationsQuery.data) == null ? void 0 : _a.find((c) => c.chain.id === props.chain.id)) == null ? void 0 : _b.tokens.find((t) => t.address === token.address)) == null ? void 0 : _c.icon : void 0;
  return (0, import_jsx_runtime20.jsx)(TokenIcon, { token: isNativeToken(token) ? { nativeToken: true } : {
    address: token.address,
    icon: token.icon || tokenIcon
  }, chain: props.chain, client: props.client, size: props.size });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/PayWIthCreditCard.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
function PayWithCreditCard(props) {
  return (0, import_jsx_runtime21.jsxs)(Container, { bg: "tertiaryBg", borderColor: "borderColor", flex: "row", style: {
    borderRadius: radius.md,
    borderBottomRightRadius: 0,
    borderBottomLeftRadius: 0,
    borderWidth: "1px",
    borderStyle: "solid",
    borderBottom: "none",
    flexWrap: "nowrap",
    justifyContent: "space-between",
    alignItems: "center"
  }, children: [(0, import_jsx_runtime21.jsxs)(CurrencyButton, { variant: "ghost", onClick: props.onSelectCurrency, style: {
    minHeight: "64px",
    justifyContent: "flex-start",
    minWidth: "50%"
  }, gap: "sm", children: [(0, import_jsx_runtime21.jsx)(props.currency.icon, { size: iconSize.md }), (0, import_jsx_runtime21.jsxs)(Container, { flex: "row", center: "y", gap: "xxs", color: "secondaryText", children: [(0, import_jsx_runtime21.jsx)(Text, { color: "primaryText", children: props.currency.shorthand }), (0, import_jsx_runtime21.jsx)(ChevronDownIcon, { width: iconSize.sm, height: iconSize.sm })] })] }), (0, import_jsx_runtime21.jsx)("div", { style: {
    flexGrow: 1,
    flexShrink: 1,
    display: "flex",
    flexDirection: "column",
    alignItems: "flex-end",
    gap: spacing.xxs,
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    justifyContent: "center",
    paddingRight: spacing.sm
  }, children: props.isLoading ? (0, import_jsx_runtime21.jsx)(Skeleton, { width: "100px", height: fontSize.lg }) : (0, import_jsx_runtime21.jsx)(Text, { size: "lg", color: props.value ? "primaryText" : "secondaryText", children: props.value ? `${formatNumber(Number(props.value), 4)}` : "--" }) })] });
}
var CurrencyButton = newStyled(Button)(() => {
  return {
    "&[disabled]:hover": {
      borderColor: "transparent"
    }
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/CurrencySelection.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/currencies.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/icons/currencies/CADIcon.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var CADIcon = (props) => {
  return (0, import_jsx_runtime22.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: props.size, height: props.size, viewBox: "0 0 512 512", "aria-hidden": "true", children: [(0, import_jsx_runtime22.jsx)("mask", { id: "a", children: (0, import_jsx_runtime22.jsx)("circle", { cx: "256", cy: "256", r: "256", fill: "#fff" }) }), (0, import_jsx_runtime22.jsxs)("g", { mask: "url(#a)", children: [(0, import_jsx_runtime22.jsx)("path", { fill: "#d80027", d: "M0 0v512h144l112-64 112 64h144V0H368L256 64 144 0Z" }), (0, import_jsx_runtime22.jsx)("path", { fill: "#eee", d: "M144 0h224v512H144Z" }), (0, import_jsx_runtime22.jsx)("path", { fill: "#d80027", d: "m301 289 44-22-22-11v-22l-45 22 23-44h-23l-22-34-22 33h-23l23 45-45-22v22l-22 11 45 22-12 23h45v33h22v-33h45z" })] })] });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/icons/currencies/EURIcon.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var EURIcon = (props) => {
  return (0, import_jsx_runtime23.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: props.size, height: props.size, viewBox: "0 0 512 512", "aria-hidden": "true", children: [(0, import_jsx_runtime23.jsx)("mask", { id: "a", children: (0, import_jsx_runtime23.jsx)("circle", { cx: "256", cy: "256", r: "256", fill: "#fff" }) }), (0, import_jsx_runtime23.jsxs)("g", { mask: "url(#a)", children: [(0, import_jsx_runtime23.jsx)("path", { fill: "#0052b4", d: "M0 0h512v512H0z" }), (0, import_jsx_runtime23.jsx)("path", { fill: "#ffda44", d: "m256 100.2 8.3 25.5H291l-21.7 15.7 8.3 25.6-21.7-15.8-21.7 15.8 8.3-25.6-21.7-15.7h26.8zm-110.2 45.6 24 12.2 18.9-19-4.2 26.5 23.9 12.2-26.5 4.2-4.2 26.5-12.2-24-26.5 4.3 19-19zM100.2 256l25.5-8.3V221l15.7 21.7 25.6-8.3-15.8 21.7 15.8 21.7-25.6-8.3-15.7 21.7v-26.8zm45.6 110.2 12.2-24-19-18.9 26.5 4.2 12.2-23.9 4.2 26.5 26.5 4.2-24 12.2 4.3 26.5-19-19zM256 411.8l-8.3-25.5H221l21.7-15.7-8.3-25.6 21.7 15.8 21.7-15.8-8.3 25.6 21.7 15.7h-26.8zm110.2-45.6-24-12.2-18.9 19 4.2-26.5-23.9-12.2 26.5-4.2 4.2-26.5 12.2 24 26.5-4.3-19 19zM411.8 256l-25.5 8.3V291l-15.7-21.7-25.6 8.3 15.8-21.7-15.8-21.7 25.6 8.3 15.7-21.7v26.8zm-45.6-110.2-12.2 24 19 18.9-26.5-4.2-12.2 23.9-4.2-26.5-26.5-4.2 24-12.2-4.3-26.5 19 19z" })] })] });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/icons/currencies/GBPIcon.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var GBPIcon = (props) => {
  return (0, import_jsx_runtime24.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", version: "1.1", id: "Layer_1", x: "0px", y: "0px", width: props.size, height: props.size, viewBox: "0 0 512 512", "aria-hidden": "true", children: [(0, import_jsx_runtime24.jsx)("circle", { fill: "#F0F0F0", cx: "256", cy: "256", r: "256" }), (0, import_jsx_runtime24.jsxs)("g", { children: [(0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M52.92,100.142c-20.109,26.163-35.272,56.318-44.101,89.077h133.178L52.92,100.142z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M503.181,189.219c-8.829-32.758-23.993-62.913-44.101-89.076l-89.075,89.076H503.181z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M8.819,322.784c8.83,32.758,23.993,62.913,44.101,89.075l89.074-89.075L8.819,322.784L8.819,322.784   z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M411.858,52.921c-26.163-20.109-56.317-35.272-89.076-44.102v133.177L411.858,52.921z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M100.142,459.079c26.163,20.109,56.318,35.272,89.076,44.102V370.005L100.142,459.079z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M189.217,8.819c-32.758,8.83-62.913,23.993-89.075,44.101l89.075,89.075V8.819z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M322.783,503.181c32.758-8.83,62.913-23.993,89.075-44.101l-89.075-89.075V503.181z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#0052B4", d: "M370.005,322.784l89.075,89.076c20.108-26.162,35.272-56.318,44.101-89.076H370.005z" })] }), (0, import_jsx_runtime24.jsxs)("g", { children: [(0, import_jsx_runtime24.jsx)("path", { fill: "#D80027", d: "M509.833,222.609h-220.44h-0.001V2.167C278.461,0.744,267.317,0,256,0   c-11.319,0-22.461,0.744-33.391,2.167v220.44v0.001H2.167C0.744,233.539,0,244.683,0,256c0,11.319,0.744,22.461,2.167,33.391   h220.44h0.001v220.442C233.539,511.256,244.681,512,256,512c11.317,0,22.461-0.743,33.391-2.167v-220.44v-0.001h220.442   C511.256,278.461,512,267.319,512,256C512,244.683,511.256,233.539,509.833,222.609z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#D80027", d: "M322.783,322.784L322.783,322.784L437.019,437.02c5.254-5.252,10.266-10.743,15.048-16.435   l-97.802-97.802h-31.482V322.784z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#D80027", d: "M189.217,322.784h-0.002L74.98,437.019c5.252,5.254,10.743,10.266,16.435,15.048l97.802-97.804   V322.784z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#D80027", d: "M189.217,189.219v-0.002L74.981,74.98c-5.254,5.252-10.266,10.743-15.048,16.435l97.803,97.803   H189.217z" }), (0, import_jsx_runtime24.jsx)("path", { fill: "#D80027", d: "M322.783,189.219L322.783,189.219L437.02,74.981c-5.252-5.254-10.743-10.266-16.435-15.047   l-97.802,97.803V189.219z" })] })] });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/icons/currencies/USDIcon.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var USDIcon = (props) => {
  return (0, import_jsx_runtime25.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: props.size, height: props.size, x: "0px", y: "0px", viewBox: "0 0 512 512", "aria-hidden": "true", children: [(0, import_jsx_runtime25.jsx)("circle", { fill: "#F0F0F0", cx: "256", cy: "256", r: "256" }), (0, import_jsx_runtime25.jsxs)("g", { children: [(0, import_jsx_runtime25.jsx)("path", { fill: "#D80027", d: "M244.87,256H512c0-23.106-3.08-45.49-8.819-66.783H244.87V256z" }), (0, import_jsx_runtime25.jsx)("path", { fill: "#D80027", d: "M244.87,122.435h229.556c-15.671-25.572-35.708-48.175-59.07-66.783H244.87V122.435z" }), (0, import_jsx_runtime25.jsx)("path", { fill: "#D80027", d: "M256,512c60.249,0,115.626-20.824,159.356-55.652H96.644C140.374,491.176,195.751,512,256,512z" }), (0, import_jsx_runtime25.jsx)("path", { fill: "#D80027", d: "M37.574,389.565h436.852c12.581-20.529,22.338-42.969,28.755-66.783H8.819   C15.236,346.596,24.993,369.036,37.574,389.565z" })] }), (0, import_jsx_runtime25.jsx)("path", { fill: "#0052B4", d: "M118.584,39.978h23.329l-21.7,15.765l8.289,25.509l-21.699-15.765L85.104,81.252l7.16-22.037  C73.158,75.13,56.412,93.776,42.612,114.552h7.475l-13.813,10.035c-2.152,3.59-4.216,7.237-6.194,10.938l6.596,20.301l-12.306-8.941  c-3.059,6.481-5.857,13.108-8.372,19.873l7.267,22.368h26.822l-21.7,15.765l8.289,25.509l-21.699-15.765l-12.998,9.444  C0.678,234.537,0,245.189,0,256h256c0-141.384,0-158.052,0-256C205.428,0,158.285,14.67,118.584,39.978z M128.502,230.4  l-21.699-15.765L85.104,230.4l8.289-25.509l-21.7-15.765h26.822l8.288-25.509l8.288,25.509h26.822l-21.7,15.765L128.502,230.4z   M120.213,130.317l8.289,25.509l-21.699-15.765l-21.699,15.765l8.289-25.509l-21.7-15.765h26.822l8.288-25.509l8.288,25.509h26.822  L120.213,130.317z M220.328,230.4l-21.699-15.765L176.93,230.4l8.289-25.509l-21.7-15.765h26.822l8.288-25.509l8.288,25.509h26.822  l-21.7,15.765L220.328,230.4z M212.039,130.317l8.289,25.509l-21.699-15.765l-21.699,15.765l8.289-25.509l-21.7-15.765h26.822  l8.288-25.509l8.288,25.509h26.822L212.039,130.317z M212.039,55.743l8.289,25.509l-21.699-15.765L176.93,81.252l8.289-25.509  l-21.7-15.765h26.822l8.288-25.509l8.288,25.509h26.822L212.039,55.743z" })] });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/currencies.js
var defaultSelectedCurrency = {
  shorthand: "USD",
  name: "US Dollar",
  icon: USDIcon
};
var currencies = [
  defaultSelectedCurrency,
  {
    shorthand: "CAD",
    name: "Canadian Dollar",
    icon: CADIcon
  },
  {
    shorthand: "GBP",
    name: "British Pound",
    icon: GBPIcon
  },
  {
    shorthand: "EUR",
    name: "Euro",
    icon: EURIcon
  }
];
function getCurrencyMeta(shorthand) {
  return currencies.find((currency) => currency.shorthand.toLowerCase() === shorthand.toLowerCase()) ?? {
    // This should never happen
    icon: UnknownCurrencyIcon,
    name: shorthand,
    shorthand
  };
}
var UnknownCurrencyIcon = (props) => {
  return (0, import_jsx_runtime26.jsx)(RadiobuttonIcon, { width: props.size, height: props.size });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/CurrencySelection.js
function CurrencySelection(props) {
  return (0, import_jsx_runtime27.jsxs)(Container, { children: [(0, import_jsx_runtime27.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime27.jsx)(ModalHeader, { title: "Pay with", onBack: props.onBack }) }), (0, import_jsx_runtime27.jsx)(Line, {}), (0, import_jsx_runtime27.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime27.jsx)(Container, { flex: "column", gap: "xs", px: "lg", children: currencies.map((c) => {
    return (0, import_jsx_runtime27.jsxs)(SelectCurrencyButton, { fullWidth: true, variant: "secondary", onClick: () => props.onSelect(c), gap: "sm", children: [(0, import_jsx_runtime27.jsx)(c.icon, { size: iconSize.lg }), (0, import_jsx_runtime27.jsxs)(Container, { flex: "column", gap: "xxs", children: [(0, import_jsx_runtime27.jsx)(Text, { color: "primaryText", children: c.shorthand }), (0, import_jsx_runtime27.jsx)(Text, { size: "sm", children: c.name })] })] }, c.shorthand);
  }) }), (0, import_jsx_runtime27.jsx)(Spacer, { y: "lg" })] });
}
var SelectCurrencyButton = newStyled(Button)(() => {
  const theme = useCustomTheme();
  return {
    background: theme.colors.tertiaryBg,
    justifyContent: "flex-start",
    gap: spacing.sm,
    padding: spacing.sm,
    "&:hover": {
      background: theme.colors.secondaryButtonBg,
      transform: "scale(1.01)"
    },
    transition: "background 200ms ease, transform 150ms ease"
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatFlow.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react24 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/openOnRamppopup.js
function openOnrampPopup(link, theme) {
  const height = 750;
  const width = 500;
  const top = (window.innerHeight - height) / 2;
  const left = (window.innerWidth - width) / 2;
  return window.open(`${link}&theme=${theme}`, "thirdweb Pay", `width=${width}, height=${height}, top=${top}, left=${left}`);
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/pendingSwapTx.js
var pendingTransactions = createStore([]);
var addPendingTx = (txInfo) => {
  const currentValue = pendingTransactions.getValue();
  pendingTransactions.setValue([txInfo, ...currentValue]);
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatStatusScreen.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/pay/buyWithFiat/getStatus.js
async function getBuyWithFiatStatus(params) {
  var _a;
  try {
    const queryParams = new URLSearchParams({
      intentId: params.intentId
    });
    const queryString = queryParams.toString();
    const url = `${getPayBuyWithFiatStatusEndpoint()}?${queryString}`;
    const response = await getClientFetch(params.client)(url);
    if (!response.ok) {
      (_a = response.body) == null ? void 0 : _a.cancel();
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return (await response.json()).result;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithFiatStatus.js
function useBuyWithFiatStatus(params) {
  return useQuery({
    queryKey: ["useBuyWithFiatStatus", params],
    queryFn: async () => {
      if (!params) {
        throw new Error("No params provided");
      }
      return getBuyWithFiatStatus(params);
    },
    enabled: !!params,
    refetchInterval: 5e3,
    refetchIntervalInBackground: true,
    retry: true
  });
}

// node_modules/thirdweb/dist/esm/react/core/providers/invalidateWalletBalance.js
function invalidateWalletBalance(queryClient, chainId) {
  return queryClient.invalidateQueries({
    // invalidate any walletBalance queries for this chainId
    // TODO: add wallet address in here if we can get it somehow
    queryKey: ["walletBalance", chainId]
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/StepBar.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
function StepBar(props) {
  return (0, import_jsx_runtime28.jsx)(Container, { bg: "tertiaryBg", flex: "row", style: {
    height: "8px",
    borderRadius: radius.lg
  }, children: (0, import_jsx_runtime28.jsx)(Container, { bg: "accentText", style: {
    width: `${props.currentStep / props.steps * 95}%`,
    borderRadius: radius.lg
  }, children: null }) });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/tx-history/statusMeta.js
function getBuyWithCryptoStatusMeta(cryptoStatus) {
  if (cryptoStatus.status === "NOT_FOUND") {
    return {
      status: "Unknown",
      color: "secondaryText"
    };
  }
  const subStatus = cryptoStatus.subStatus;
  const status = cryptoStatus.status;
  if (subStatus === "WAITING_BRIDGE") {
    return {
      status: "Bridging",
      color: "accentText",
      loading: true
    };
  }
  if (subStatus === "PARTIAL_SUCCESS") {
    return {
      status: "Incomplete",
      color: "secondaryText"
    };
  }
  if (status === "PENDING") {
    return {
      status: "Pending",
      color: "accentText",
      loading: true
    };
  }
  if (status === "FAILED") {
    return {
      status: "Failed",
      color: "danger"
    };
  }
  if (status === "COMPLETED") {
    return {
      status: "Completed",
      color: "success"
    };
  }
  return {
    status: "Unknown",
    color: "secondaryText"
  };
}
function getBuyWithFiatStatusMeta(fiatStatus) {
  const status = fiatStatus.status;
  switch (status) {
    case "CRYPTO_SWAP_FALLBACK": {
      return {
        status: "Incomplete",
        color: "danger",
        step: 2,
        progressStatus: "partialSuccess"
      };
    }
    case "CRYPTO_SWAP_IN_PROGRESS":
    case "PENDING_ON_RAMP_TRANSFER":
    case "ON_RAMP_TRANSFER_IN_PROGRESS":
    case "PENDING_PAYMENT": {
      return {
        status: "Pending",
        color: "accentText",
        loading: true,
        step: status === "CRYPTO_SWAP_IN_PROGRESS" ? 2 : 1,
        progressStatus: "pending"
      };
    }
    case "ON_RAMP_TRANSFER_COMPLETED":
    case "CRYPTO_SWAP_COMPLETED": {
      return {
        status: "Completed",
        // Is this actually completed though?
        color: "success",
        loading: true,
        step: status === "CRYPTO_SWAP_COMPLETED" ? 2 : 1,
        progressStatus: "completed"
      };
    }
    case "CRYPTO_SWAP_FAILED":
    case "CRYPTO_SWAP_REQUIRED": {
      return {
        status: "Action Required",
        color: "accentText",
        step: 2,
        progressStatus: "actionRequired"
      };
    }
    case "PAYMENT_FAILED":
    case "ON_RAMP_TRANSFER_FAILED": {
      return {
        status: "Failed",
        color: "danger",
        step: 1,
        progressStatus: "failed"
      };
    }
  }
  return {
    status: "Unknown",
    color: "secondaryText",
    step: 1,
    progressStatus: "unknown"
  };
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatTxDetailsTable.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/tx-history/TokenInfoRow.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
function TokenInfoRow(props) {
  var _a;
  const chainObj = (0, import_react15.useMemo)(() => getCachedChain(props.chainId), [props.chainId]);
  const chainQuery = useChainQuery(chainObj);
  return (0, import_jsx_runtime29.jsxs)(Container, { flex: "row", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime29.jsx)(Text, { children: props.label }), (0, import_jsx_runtime29.jsxs)(Container, { flex: "column", gap: "xxs", style: {
    alignItems: "flex-end"
  }, children: [(0, import_jsx_runtime29.jsxs)(Container, { flex: "row", gap: "xs", center: "y", children: [(0, import_jsx_runtime29.jsx)(PayTokenIcon, { chain: chainObj, size: "sm", token: {
    address: props.tokenAddress
  }, client: props.client }), (0, import_jsx_runtime29.jsxs)(Text, { color: "primaryText", children: [formatNumber(Number(props.tokenAmount), 4), " ", props.tokenSymbol] })] }), (0, import_jsx_runtime29.jsx)(Text, { size: "sm", children: (_a = chainQuery.data) == null ? void 0 : _a.name })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatTxDetailsTable.js
function OnRampTxDetailsTable(props) {
  var _a, _b, _c, _d;
  const onRampChainQuery = useChainQuery(getCachedChain(props.token.chainId));
  const onrampTxHash = (_a = props.statusMeta) == null ? void 0 : _a.txHash;
  const currencyMeta = getCurrencyMeta(props.fiat.currencySymbol);
  const lineSpacer = (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [(0, import_jsx_runtime30.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime30.jsx)(Line, {}), (0, import_jsx_runtime30.jsx)(Spacer, { y: "md" })] });
  return (0, import_jsx_runtime30.jsxs)("div", { children: [(0, import_jsx_runtime30.jsxs)(Container, { flex: "row", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime30.jsx)(Text, { children: "Pay" }), (0, import_jsx_runtime30.jsx)(Container, { flex: "column", gap: "xxs", style: {
    alignItems: "flex-end"
  }, children: (0, import_jsx_runtime30.jsxs)(Container, { flex: "row", gap: "xs", center: "y", children: [(0, import_jsx_runtime30.jsx)(currencyMeta.icon, { size: iconSize.sm }), (0, import_jsx_runtime30.jsxs)(Text, { color: "primaryText", children: [formatNumber(Number(props.fiat.amount), 4), " ", props.fiat.currencySymbol] })] }) })] }), lineSpacer, (0, import_jsx_runtime30.jsx)(TokenInfoRow, { chainId: props.token.chainId, client: props.client, label: "Receive", tokenAmount: props.token.amount, tokenSymbol: props.token.symbol, tokenAddress: props.token.address }), props.statusMeta && (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [lineSpacer, (0, import_jsx_runtime30.jsxs)(Container, { flex: "row", center: "y", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime30.jsx)(Text, { children: "Status" }), (0, import_jsx_runtime30.jsx)(Container, { flex: "row", gap: "xs", center: "y", children: (0, import_jsx_runtime30.jsx)(Text, { color: props.statusMeta.color, children: props.statusMeta.text }) })] })] }), lineSpacer, onrampTxHash && ((_d = (_c = (_b = onRampChainQuery.data) == null ? void 0 : _b.explorers) == null ? void 0 : _c[0]) == null ? void 0 : _d.url) && (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [(0, import_jsx_runtime30.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime30.jsxs)(ButtonLink, { fullWidth: true, variant: "outline", href: `${onRampChainQuery.data.explorers[0].url || ""}/tx/${onrampTxHash}`, target: "_blank", gap: "xs", style: {
    fontSize: fontSize.sm
  }, children: ["View on Explorer", (0, import_jsx_runtime30.jsx)(ExternalLinkIcon, { width: iconSize.sm, height: iconSize.sm })] })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatStatusScreen.js
function OnrampStatusScreen(props) {
  var _a, _b, _c, _d;
  const queryClient = useQueryClient();
  const { openedWindow } = props;
  const statusQuery = useBuyWithFiatStatus({
    intentId: props.intentId,
    client: props.client
  });
  let uiStatus = "loading";
  if (((_a = statusQuery.data) == null ? void 0 : _a.status) === "ON_RAMP_TRANSFER_FAILED" || ((_b = statusQuery.data) == null ? void 0 : _b.status) === "PAYMENT_FAILED") {
    uiStatus = "failed";
  } else if (((_c = statusQuery.data) == null ? void 0 : _c.status) === "CRYPTO_SWAP_FALLBACK") {
    uiStatus = "partialSuccess";
  } else if (((_d = statusQuery.data) == null ? void 0 : _d.status) === "ON_RAMP_TRANSFER_COMPLETED") {
    uiStatus = "completed";
  }
  (0, import_react16.useEffect)(() => {
    var _a2, _b2;
    if (!openedWindow || !statusQuery.data) {
      return;
    }
    if (((_a2 = statusQuery.data) == null ? void 0 : _a2.status) === "CRYPTO_SWAP_REQUIRED" || ((_b2 = statusQuery.data) == null ? void 0 : _b2.status) === "ON_RAMP_TRANSFER_COMPLETED") {
      openedWindow.close();
    }
  }, [statusQuery.data, openedWindow]);
  const invalidatedBalance = (0, import_react16.useRef)(false);
  (0, import_react16.useEffect)(() => {
    var _a2;
    if (!invalidatedBalance.current && ((_a2 = statusQuery.data) == null ? void 0 : _a2.status) === "ON_RAMP_TRANSFER_COMPLETED") {
      invalidatedBalance.current = true;
      invalidateWalletBalance(queryClient);
    }
  }, [statusQuery.data, queryClient]);
  (0, import_react16.useEffect)(() => {
    var _a2;
    if (((_a2 = statusQuery.data) == null ? void 0 : _a2.status) === "CRYPTO_SWAP_REQUIRED") {
      props.onShowSwapFlow(statusQuery.data);
    }
  }, [statusQuery.data, props.onShowSwapFlow]);
  return (0, import_jsx_runtime31.jsxs)(Container, { p: "lg", children: [(0, import_jsx_runtime31.jsx)(ModalHeader, { title: "Buy", onBack: props.onBack }), props.hasTwoSteps && (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, { children: [(0, import_jsx_runtime31.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime31.jsx)(StepBar, { steps: 2, currentStep: 1 }), (0, import_jsx_runtime31.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime31.jsxs)(Text, { size: "xs", children: ["Step 1 of 2 - Buying ", props.quote.onRampToken.token.symbol, " with", " ", props.quote.fromCurrencyWithFees.currencySymbol] })] }), (0, import_jsx_runtime31.jsx)(OnrampStatusScreenUI, { uiStatus, onDone: props.onDone, fiatStatus: statusQuery.data, client: props.client, isBuyForTx: props.isBuyForTx, quote: props.quote, isEmbed: props.isEmbed })] });
}
function OnrampStatusScreenUI(props) {
  const { uiStatus } = props;
  const statusMeta = props.fiatStatus ? getBuyWithFiatStatusMeta(props.fiatStatus) : void 0;
  const fiatStatus = props.fiatStatus && props.fiatStatus.status !== "NOT_FOUND" ? props.fiatStatus : void 0;
  const onRampTokenQuote = props.quote.onRampToken;
  const txDetails = (0, import_jsx_runtime31.jsx)(OnRampTxDetailsTable, { client: props.client, token: (fiatStatus == null ? void 0 : fiatStatus.source) ? {
    chainId: fiatStatus.source.token.chainId,
    address: fiatStatus.source.token.tokenAddress,
    symbol: fiatStatus.source.token.symbol || "",
    amount: fiatStatus.source.amount
  } : {
    chainId: onRampTokenQuote.token.chainId,
    address: onRampTokenQuote.token.tokenAddress,
    symbol: onRampTokenQuote.token.symbol,
    amount: onRampTokenQuote.amount
  }, fiat: {
    amount: props.quote.fromCurrencyWithFees.amount,
    currencySymbol: props.quote.fromCurrencyWithFees.currencySymbol
  }, statusMeta: (fiatStatus == null ? void 0 : fiatStatus.source) && statusMeta ? {
    color: statusMeta == null ? void 0 : statusMeta.color,
    text: statusMeta == null ? void 0 : statusMeta.status,
    txHash: fiatStatus.source.transactionHash
  } : void 0 });
  return (0, import_jsx_runtime31.jsxs)(Container, { children: [(0, import_jsx_runtime31.jsx)(Spacer, { y: "xl" }), uiStatus === "loading" && (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, { children: [(0, import_jsx_runtime31.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime31.jsx)(Container, { flex: "row", center: "x", children: (0, import_jsx_runtime31.jsx)(Spinner, { size: "3xl", color: "accentText" }) }), (0, import_jsx_runtime31.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime31.jsx)(Text, { color: "primaryText", size: "lg", center: true, children: "Buy Pending" }), (0, import_jsx_runtime31.jsx)(Spacer, { y: "sm" }), !isMobile() && (0, import_jsx_runtime31.jsx)(Text, { center: true, children: "Complete the purchase in popup" }), (0, import_jsx_runtime31.jsx)(Spacer, { y: "xxl" }), txDetails] }), uiStatus === "failed" && (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, { children: [(0, import_jsx_runtime31.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime31.jsx)(Container, { flex: "row", center: "x", children: (0, import_jsx_runtime31.jsx)(AccentFailIcon, { size: iconSize["3xl"] }) }), (0, import_jsx_runtime31.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime31.jsx)(Text, { color: "primaryText", size: "lg", center: true, children: "Transaction Failed" }), (0, import_jsx_runtime31.jsx)(Spacer, { y: "xxl" }), txDetails] }), uiStatus === "completed" && (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, { children: [(0, import_jsx_runtime31.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime31.jsx)(Container, { flex: "row", center: "x", color: "success", children: (0, import_jsx_runtime31.jsx)(CheckCircledIcon, { width: iconSize["3xl"], height: iconSize["3xl"] }) }), (0, import_jsx_runtime31.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime31.jsx)(Text, { color: "primaryText", size: "lg", center: true, children: "Buy Complete" }), props.fiatStatus && props.fiatStatus.status !== "NOT_FOUND" && (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, { children: [(0, import_jsx_runtime31.jsx)(Spacer, { y: "xxl" }), txDetails, (0, import_jsx_runtime31.jsx)(Spacer, { y: "sm" })] }), !props.isEmbed && (0, import_jsx_runtime31.jsx)(Button, { variant: "accent", fullWidth: true, onClick: props.onDone, children: props.isBuyForTx ? "Continue Transaction" : "Done" })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatSteps.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/Stepper.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
function StepIcon(props) {
  return (0, import_jsx_runtime32.jsx)(Container, { flex: "row", center: "both", color: props.isDone ? "success" : props.isActive ? "accentText" : "secondaryText", children: (0, import_jsx_runtime32.jsx)(Circle, { children: props.isDone ? (0, import_jsx_runtime32.jsx)(CheckIcon, { width: iconSize.sm, height: iconSize.sm }) : (0, import_jsx_runtime32.jsx)(PulsingDot, { "data-active": props.isActive }) }) });
}
function Step(props) {
  return (0, import_jsx_runtime32.jsxs)(Container, { flex: "row", center: "y", gap: "xs", style: {
    fontSize: fontSize.sm
  }, color: props.isDone ? "success" : props.isActive ? "accentText" : "secondaryText", children: [(0, import_jsx_runtime32.jsx)(StepIcon, { isDone: props.isDone, isActive: props.isActive }), props.label] });
}
var pulseAnimation = keyframes`
0% {
  opacity: 1;
  transform: scale(0.5);
}
100% {
  opacity: 0;
  transform: scale(1.5);
}
`;
var PulsingDot = StyledDiv(() => {
  return {
    background: "currentColor",
    width: "9px",
    height: "9px",
    borderRadius: "50%",
    '&[data-active="true"]': {
      animation: `${pulseAnimation} 1s infinite`
    }
  };
});
var Circle = StyledDiv(() => {
  return {
    border: "1px solid currentColor",
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatSteps.js
function fiatQuoteToPartialQuote(quote) {
  const data = {
    fromCurrencyAmount: quote.fromCurrencyWithFees.amount,
    fromCurrencySymbol: quote.fromCurrencyWithFees.currencySymbol,
    onRampTokenAmount: quote.onRampToken.amount,
    toTokenAmount: quote.estimatedToAmountMin,
    onRampToken: {
      chainId: quote.onRampToken.token.chainId,
      tokenAddress: quote.onRampToken.token.tokenAddress,
      name: quote.onRampToken.token.name,
      symbol: quote.onRampToken.token.symbol
    },
    toToken: {
      chainId: quote.toToken.chainId,
      tokenAddress: quote.toToken.tokenAddress,
      name: quote.toToken.name,
      symbol: quote.toToken.symbol
    }
  };
  return data;
}
function FiatSteps(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
  const statusMeta = props.status ? getBuyWithFiatStatusMeta(props.status) : void 0;
  const { toToken: toTokenMeta, onRampToken: onRampTokenMeta, onRampTokenAmount, fromCurrencySymbol, fromCurrencyAmount, toTokenAmount } = props.partialQuote;
  const currency = getCurrencyMeta(fromCurrencySymbol);
  const isPartialSuccess = (statusMeta == null ? void 0 : statusMeta.progressStatus) === "partialSuccess";
  const toChain = (0, import_react18.useMemo)(() => getCachedChain(toTokenMeta.chainId), [toTokenMeta.chainId]);
  const destinationChain = (0, import_react18.useMemo)(() => {
    var _a2, _b2, _c2;
    if (((_a2 = props.status) == null ? void 0 : _a2.status) !== "NOT_FOUND" && ((_b2 = props.status) == null ? void 0 : _b2.destination)) {
      return getCachedChain((_c2 = props.status) == null ? void 0 : _c2.destination.token.chainId);
    }
    return void 0;
  }, [props.status]);
  const toToken = (0, import_react18.useMemo)(() => {
    if (toTokenMeta.tokenAddress === NATIVE_TOKEN_ADDRESS) {
      return NATIVE_TOKEN;
    }
    const tokenInfo = {
      address: toTokenMeta.tokenAddress,
      name: toTokenMeta.name || "",
      symbol: toTokenMeta.symbol || ""
      // TODO: when icon is available in endpoint
      // icon: toTokenMeta.icon
    };
    return tokenInfo;
  }, [toTokenMeta]);
  const onRampChain = (0, import_react18.useMemo)(() => getCachedChain(onRampTokenMeta.chainId), [onRampTokenMeta.chainId]);
  const onRampToken = (0, import_react18.useMemo)(() => {
    if (onRampTokenMeta.tokenAddress === NATIVE_TOKEN_ADDRESS) {
      return NATIVE_TOKEN;
    }
    const tokenInfo = {
      address: onRampTokenMeta.tokenAddress,
      name: onRampTokenMeta.name || "",
      symbol: onRampTokenMeta.symbol || ""
      // TODO: when icon is available in endpoint
      // icon: onRampTokenMeta.icon,
    };
    return tokenInfo;
  }, [onRampTokenMeta]);
  const onRampChainMetaQuery = useChainQuery(onRampChain);
  const toChainMetaQuery = useChainQuery(toChain);
  const destinationChainMetaQuery = useChainQuery(destinationChain);
  const onRampTokenInfo = (0, import_jsx_runtime33.jsx)("div", { children: (0, import_jsx_runtime33.jsxs)(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(onRampTokenAmount), 4), " ", (0, import_jsx_runtime33.jsx)(TokenSymbol, { token: onRampToken, chain: onRampChain, size: "sm", inline: true })] }) });
  const fiatIcon = (0, import_jsx_runtime33.jsx)(currency.icon, { size: iconSize.sm });
  const onRampTokenIcon = (0, import_jsx_runtime33.jsx)(PayTokenIcon, { token: onRampToken, chain: onRampChain, size: "sm", client: props.client });
  const toTokenIcon = (0, import_jsx_runtime33.jsx)(PayTokenIcon, { token: toToken, chain: toChain, size: "sm", client: props.client });
  const onRampChainInfo = (0, import_jsx_runtime33.jsx)(Text, { size: "xs", children: (_a = onRampChainMetaQuery.data) == null ? void 0 : _a.name });
  const partialSuccessToTokenInfo = ((_b = props.status) == null ? void 0 : _b.status) === "CRYPTO_SWAP_FALLBACK" && props.status.destination ? (0, import_jsx_runtime33.jsxs)("div", { children: [(0, import_jsx_runtime33.jsxs)(Text, { color: "secondaryText", size: "sm", inline: true, style: {
    textDecoration: "line-through"
  }, children: [formatNumber(Number(toTokenAmount), 4), " ", (0, import_jsx_runtime33.jsx)(TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true, color: "secondaryText" })] }), " ", (0, import_jsx_runtime33.jsxs)(Text, { color: "danger", size: "sm", inline: true, children: [formatNumber(Number(props.status.destination.amount), 4), " ", (0, import_jsx_runtime33.jsx)(TokenSymbol, { token: {
    address: props.status.destination.token.tokenAddress,
    name: props.status.destination.token.name || "",
    symbol: props.status.destination.token.symbol || ""
  }, chain: toChain, size: "sm", inline: true, color: "danger" })] })] }) : null;
  const toTokenInfo = partialSuccessToTokenInfo || (0, import_jsx_runtime33.jsxs)(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(toTokenAmount), 4), " ", (0, import_jsx_runtime33.jsx)(TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true })] });
  const partialSuccessToChainInfo = ((_c = props.status) == null ? void 0 : _c.status) === "CRYPTO_SWAP_FALLBACK" && props.status.destination && props.status.destination.token.chainId !== props.status.quote.toToken.chainId ? (0, import_jsx_runtime33.jsxs)("div", { children: [(0, import_jsx_runtime33.jsx)(Text, { size: "xs", inline: true, style: {
    textDecoration: "line-through"
  }, children: (_d = toChainMetaQuery.data) == null ? void 0 : _d.name }), " ", (0, import_jsx_runtime33.jsx)(Text, { size: "xs", inline: true, children: (_e = destinationChainMetaQuery.data) == null ? void 0 : _e.name })] }) : null;
  const toTokehChainInfo = partialSuccessToChainInfo || (0, import_jsx_runtime33.jsx)(Text, { size: "xs", children: (_f = toChainMetaQuery.data) == null ? void 0 : _f.name });
  const onRampTxHash = ((_g = props.status) == null ? void 0 : _g.status) !== "NOT_FOUND" ? (_i = (_h = props.status) == null ? void 0 : _h.source) == null ? void 0 : _i.transactionHash : void 0;
  const toTokenTxHash = ((_j = props.status) == null ? void 0 : _j.status) !== "NOT_FOUND" ? (_l = (_k = props.status) == null ? void 0 : _k.destination) == null ? void 0 : _l.transactionHash : void 0;
  const showContinueBtn = !props.status || props.status.status === "CRYPTO_SWAP_REQUIRED" || props.status.status === "CRYPTO_SWAP_FAILED";
  function getStep1State() {
    if (!statusMeta) {
      if (props.step === 2) {
        return "completed";
      }
      return "actionRequired";
    }
    if (statusMeta.step === 2) {
      return "completed";
    }
    return statusMeta.progressStatus;
  }
  function getStep2State() {
    if (!statusMeta) {
      if (props.step === 2) {
        return "actionRequired";
      }
      return void 0;
    }
    if (statusMeta.step === 2) {
      return statusMeta.progressStatus;
    }
    return void 0;
  }
  return (0, import_jsx_runtime33.jsxs)(Container, { p: "lg", children: [(0, import_jsx_runtime33.jsx)(ModalHeader, { title: "Buy", onBack: props.onBack }), (0, import_jsx_runtime33.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime33.jsx)(PaymentStep, { title: (0, import_jsx_runtime33.jsxs)(Text, { color: "primaryText", size: "md", children: ["Get", " ", (0, import_jsx_runtime33.jsx)(TokenSymbol, { token: onRampToken, chain: onRampChain, size: "md", inline: true }), " ", "with ", props.partialQuote.fromCurrencySymbol] }), step: 1, from: {
    icon: fiatIcon,
    primaryText: (0, import_jsx_runtime33.jsxs)(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(fromCurrencyAmount), 4), " ", fromCurrencySymbol] })
  }, to: {
    icon: onRampTokenIcon,
    primaryText: onRampTokenInfo,
    secondaryText: onRampChainInfo
  }, state: getStep1State(), explorer: ((_o = (_n = (_m = onRampChainMetaQuery.data) == null ? void 0 : _m.explorers) == null ? void 0 : _n[0]) == null ? void 0 : _o.url) && onRampTxHash ? {
    label: "View on Explorer",
    url: `${onRampChainMetaQuery.data.explorers[0].url}/tx/${onRampTxHash}`
  } : void 0 }), (0, import_jsx_runtime33.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime33.jsx)(PaymentStep, { title: (0, import_jsx_runtime33.jsxs)(Text, { color: "primaryText", size: "md", children: ["Convert", " ", (0, import_jsx_runtime33.jsx)(TokenSymbol, { token: onRampToken, chain: onRampChain, size: "md", inline: true }), " ", "to ", (0, import_jsx_runtime33.jsx)(TokenSymbol, { token: toToken, chain: toChain, size: "md", inline: true })] }), step: 2, from: {
    icon: onRampTokenIcon,
    primaryText: onRampTokenInfo,
    secondaryText: onRampChainInfo
  }, to: {
    icon: toTokenIcon,
    primaryText: toTokenInfo,
    secondaryText: toTokehChainInfo
  }, state: getStep2State(), explorer: ((_r = (_q = (_p = toChainMetaQuery.data) == null ? void 0 : _p.explorers) == null ? void 0 : _q[0]) == null ? void 0 : _r.url) && toTokenTxHash ? {
    label: "View on Explorer",
    url: `${toChainMetaQuery.data.explorers[0].url}/tx/${toTokenTxHash}`
  } : void 0 }), isPartialSuccess && props.status && props.status.status !== "NOT_FOUND" && props.status.source && props.status.destination && (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [(0, import_jsx_runtime33.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime33.jsxs)(Text, { color: "danger", size: "sm", center: true, children: ["Expected ", (_s = props.status.source) == null ? void 0 : _s.token.symbol, ", Got", " ", (_t = props.status.destination) == null ? void 0 : _t.token.symbol, " instead"] }), (0, import_jsx_runtime33.jsx)(Spacer, { y: "sm" })] }), showContinueBtn && (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [(0, import_jsx_runtime33.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime33.jsx)(Button, { variant: "accent", onClick: props.onContinue, fullWidth: true, children: "Continue" })] })] });
}
function PaymentStep(props) {
  return (0, import_jsx_runtime33.jsxs)(StepContainer, { state: props.state, children: [(0, import_jsx_runtime33.jsxs)(Text, { size: "sm", children: ["Step ", props.step] }), (0, import_jsx_runtime33.jsx)(Spacer, { y: "sm" }), props.title, (0, import_jsx_runtime33.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime33.jsx)(Line, {}), (0, import_jsx_runtime33.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime33.jsx)(PaymentSubStep, { ...props.from }), (0, import_jsx_runtime33.jsxs)(Container, { color: "borderColor", style: {
    paddingLeft: "18px",
    position: "relative",
    marginBlock: "3px"
  }, children: [(0, import_jsx_runtime33.jsx)("div", { style: {
    height: "18px",
    width: "2px",
    backgroundColor: "currentColor",
    transform: "translateX(-50%)"
  } }), (0, import_jsx_runtime33.jsx)(TriangleDownIcon, { width: iconSize.sm, height: iconSize.sm, style: {
    position: "absolute",
    bottom: "0",
    transform: "translate(-50%, 50%)"
  } })] }), (0, import_jsx_runtime33.jsx)(PaymentSubStep, { ...props.to }), props.explorer && (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [(0, import_jsx_runtime33.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime33.jsxs)(ButtonLink, { variant: "outline", fullWidth: true, href: props.explorer.url, style: {
    fontSize: fontSize.xs,
    padding: spacing.xs
  }, gap: "xxs", target: "_blank", children: [props.explorer.label, " ", (0, import_jsx_runtime33.jsx)(ExternalLinkIcon, { width: iconSize.xs, height: iconSize.xs })] })] })] });
}
function PaymentSubStep(props) {
  return (0, import_jsx_runtime33.jsxs)(Container, { flex: "row", gap: "sm", center: "y", style: {
    flexWrap: "nowrap"
  }, children: [(0, import_jsx_runtime33.jsx)(Container, { p: "xs", borderColor: "borderColor", flex: "row", center: "both", style: {
    borderStyle: "solid",
    borderWidth: "1.5px",
    borderRadius: radius.lg
  }, children: props.icon }), (0, import_jsx_runtime33.jsxs)(Container, { flex: "column", gap: "xxs", children: [props.primaryText, props.secondaryText] })] });
}
function StepContainer(props) {
  let color = "borderColor";
  let text;
  if (props.state === "pending") {
    text = "Pending";
    color = "accentText";
  } else if (props.state === "actionRequired") {
    color = "accentText";
  } else if (props.state === "completed") {
    text = "Completed";
    color = "success";
  } else if (props.state === "failed") {
    color = "danger";
    text = "Failed";
  } else if (props.state === "partialSuccess") {
    color = "danger";
    text = "Incomplete";
  }
  return (0, import_jsx_runtime33.jsxs)(Container, { bg: "tertiaryBg", borderColor: color === "success" ? "borderColor" : color, py: "sm", px: "md", style: {
    borderRadius: radius.lg,
    alignItems: "flex-start",
    borderWidth: "1px",
    borderStyle: "solid",
    position: "relative"
  }, children: [props.children, (0, import_jsx_runtime33.jsxs)("div", { style: {
    position: "absolute",
    right: spacing.sm,
    top: spacing.sm,
    display: "flex",
    gap: spacing.xs,
    alignItems: "center"
  }, children: [props.state && text && (0, import_jsx_runtime33.jsx)(Text, { size: "sm", color, children: text }), (props.state === "actionRequired" || props.state === "completed") && (0, import_jsx_runtime33.jsx)(StepIcon, { isActive: props.state === "actionRequired", isDone: props.state === "completed" }), props.state === "pending" && (0, import_jsx_runtime33.jsx)(Spinner, { color: "accentText", size: "sm" }), props.state === "failed" && (0, import_jsx_runtime33.jsx)(Container, { color: "danger", flex: "row", center: "both", children: (0, import_jsx_runtime33.jsx)(Cross1Icon, { width: iconSize.sm, height: iconSize.sm }) })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/PostOnRampSwapFlow.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/PostOnRampSwap.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/pay/buyWithFiat/getPostOnRampQuote.js
async function getPostOnRampQuote({ client, buyWithFiatStatus }) {
  if (buyWithFiatStatus.status === "NOT_FOUND") {
    throw new Error("Invalid buyWithFiatStatus");
  }
  return getBuyWithCryptoQuote({
    client,
    intentId: buyWithFiatStatus.intentId,
    fromAddress: buyWithFiatStatus.toAddress,
    fromChainId: buyWithFiatStatus.quote.onRampToken.chainId,
    fromTokenAddress: buyWithFiatStatus.quote.onRampToken.tokenAddress,
    toChainId: buyWithFiatStatus.quote.toToken.chainId,
    toTokenAddress: buyWithFiatStatus.quote.toToken.tokenAddress,
    toAmount: buyWithFiatStatus.quote.estimatedToTokenAmount
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/SwapFlow.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react21 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/ConfirmationScreen.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/chains/chain-definitions/base-sepolia.js
var baseSepolia = defineChain({
  id: 84532,
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  ],
  testnet: true
});

// node_modules/thirdweb/dist/esm/chains/chain-definitions/base.js
var base = defineChain({
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  ]
});

// node_modules/thirdweb/dist/esm/chains/chain-definitions/optimism-sepolia.js
var optimismSepolia = defineChain({
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  ],
  testnet: true
});

// node_modules/thirdweb/dist/esm/chains/chain-definitions/optimism.js
var optimism = defineChain({
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io"
    }
  ]
});

// node_modules/thirdweb/dist/esm/chains/chain-definitions/zora-sepolia.js
var zoraSepolia = defineChain({
  id: 999999999,
  name: "Zora Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  blockExplorers: [
    {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  ],
  testnet: true
});

// node_modules/thirdweb/dist/esm/chains/chain-definitions/zora.js
var zora = defineChain({
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  blockExplorers: [
    {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  ]
});

// node_modules/thirdweb/dist/esm/chains/constants.js
var opChains = [
  base.id,
  baseSepolia.id,
  optimism.id,
  optimismSepolia.id,
  zora.id,
  zoraSepolia.id,
  34443,
  // mode
  919,
  // mode testnet
  42220,
  // celo
  44787,
  // celo testnet
  204,
  // opBNB
  5611
  // opBNB testnet
];
function isOpStackChain(chain) {
  return opChains.includes(chain.id);
}

// node_modules/thirdweb/dist/esm/transaction/actions/estimate-gas-cost.js
async function estimateGasCost(options) {
  var _a;
  const { transaction } = options;
  const from = options.from ?? ((_a = options.account) == null ? void 0 : _a.address) ?? void 0;
  const gasLimit = await resolvePromisedValue(transaction.gas) || await estimateGas({ transaction, from });
  const gasPrice = await getGasPrice({
    client: transaction.client,
    chain: transaction.chain
  });
  let l1Fee;
  if (isOpStackChain(transaction.chain)) {
    const { estimateL1Fee } = await import("./estimate-l1-fee-B7SMHQLE.js");
    l1Fee = await estimateL1Fee({
      transaction
    });
  } else {
    l1Fee = 0n;
  }
  const wei = gasLimit * gasPrice + l1Fee;
  return {
    ether: toEther(wei),
    wei
  };
}

// node_modules/thirdweb/dist/esm/react/core/hooks/transaction/useSendTransaction.js
function useSendTransactionCore(args) {
  const { showPayModal, gasless, wallet, switchChain } = args;
  let _account = wallet == null ? void 0 : wallet.getAccount();
  return useMutation({
    mutationFn: async (tx) => {
      var _a;
      if (wallet && tx.chain.id !== ((_a = wallet.getChain()) == null ? void 0 : _a.id)) {
        await switchChain(tx.chain);
        _account = wallet.getAccount();
      }
      const account = _account;
      if (!account) {
        throw new Error("No active account");
      }
      if (!showPayModal) {
        return sendTransaction({
          transaction: tx,
          account,
          gasless
        });
      }
      return new Promise((resolve, reject) => {
        const sendTx = async () => {
          try {
            const res = await sendTransaction({
              transaction: tx,
              account,
              gasless
            });
            resolve(res);
          } catch (e) {
            reject(e);
          }
        };
        (async () => {
          try {
            const destinations = await fetchBuySupportedDestinations(tx.client);
            const isBuySupported = destinations.find((c) => c.chain.id === tx.chain.id);
            if (!isBuySupported) {
              sendTx();
              return;
            }
            const [walletBalance, totalCostWei] = await Promise.all([
              getWalletBalance({
                address: account.address,
                chain: tx.chain,
                client: tx.client
              }),
              getTotalTxCostForBuy(tx, account == null ? void 0 : account.address)
            ]);
            const walletBalanceWei = walletBalance.value;
            if (totalCostWei < walletBalanceWei) {
              sendTx();
              return;
            }
            showPayModal({
              tx,
              sendTx,
              rejectTx: () => {
                reject(new Error("Not enough balance"));
              },
              totalCostWei,
              walletBalance
            });
          } catch (e) {
            console.error("Failed to estimate cost", e);
            sendTx();
          }
        })();
      });
    }
  });
}
async function getTotalTxCostForBuy(tx, from) {
  try {
    const gasCost = await estimateGasCost({
      transaction: tx,
      from
    });
    const bufferCost = gasCost.wei / 10n;
    const txValue = await resolvePromisedValue(tx.value);
    return gasCost.wei + bufferCost + (txValue || 0n);
  } catch (e) {
    if (from) {
      return await getTotalTxCostForBuy(tx);
    }
    const value = await resolvePromisedValue(tx.value);
    if (!value) {
      return 0n;
    }
    return value + value / 100n;
  }
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/Fees.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
function SwapFees(props) {
  return (0, import_jsx_runtime34.jsx)(Container, { flex: "column", gap: "xs", style: {
    alignItems: props.align === "right" ? "flex-end" : "flex-start"
  }, children: props.quote.processingFees.map((fee) => {
    const feeAmount = formatNumber(Number(fee.amount), 4);
    return (0, import_jsx_runtime34.jsxs)(Container, { flex: "row", gap: "xxs", children: [(0, import_jsx_runtime34.jsxs)(Text, { color: "primaryText", size: "sm", children: [feeAmount === 0 ? "~" : "", feeAmount, " ", fee.token.symbol] }), (0, import_jsx_runtime34.jsxs)(Text, { color: "secondaryText", size: "sm", children: ["($", (fee.amountUSDCents / 100).toFixed(2), ")"] })] }, `${fee.token.chainId}_${fee.token.tokenAddress}_${feeAmount}`);
  }) });
}
function FiatFees(props) {
  return (0, import_jsx_runtime34.jsxs)(Container, { flex: "column", gap: "xs", children: [(0, import_jsx_runtime34.jsxs)("div", { style: {
    display: "flex",
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime34.jsx)(Text, { inline: true, color: "secondaryText", children: "Amount" }), (0, import_jsx_runtime34.jsxs)(Text, { color: "primaryText", inline: true, children: [formatNumber(Number(props.quote.fromCurrency.amount), 4), " ", props.quote.fromCurrency.currencySymbol] })] }), props.quote.processingFees.map((fee, i) => {
    const feeAmount = formatNumber(Number(fee.amount), 4);
    return (0, import_jsx_runtime34.jsxs)("div", { style: {
      display: "flex",
      justifyContent: "space-between"
    }, children: [(0, import_jsx_runtime34.jsx)(Text, { inline: true, color: "secondaryText", children: fee.feeType === "NETWORK" ? "Network Fee" : "Processing Fee" }), (0, import_jsx_runtime34.jsxs)(Text, { color: "primaryText", inline: true, children: [feeAmount === 0 ? "~" : "", feeAmount, " ", fee.currencySymbol, " "] })] }, i);
  }), (0, import_jsx_runtime34.jsx)(Spacer, { y: "xxs" }), (0, import_jsx_runtime34.jsx)(Line, {}), (0, import_jsx_runtime34.jsx)(Spacer, { y: "xxs" }), (0, import_jsx_runtime34.jsxs)("div", { style: {
    display: "flex",
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime34.jsx)(Text, { inline: true, color: "secondaryText", children: "Total" }), (0, import_jsx_runtime34.jsxs)(Text, { color: "primaryText", inline: true, children: [formatNumber(Number(props.quote.fromCurrencyWithFees.amount), 4), " ", props.quote.fromCurrencyWithFees.currencySymbol] })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/ConfirmationScreen.js
function SwapConfirmationScreen(props) {
  const activeChain = useActiveWalletChain();
  const activeWallet = useActiveWallet();
  const switchChain = useSwitchActiveWalletChain();
  const sendTransactionMutation = useSendTransactionCore({
    wallet: activeWallet,
    switchChain
  });
  const isApprovalRequired = props.quote.approval !== void 0;
  const initialStep = isApprovalRequired ? "approval" : "swap";
  const [step, setStep] = (0, import_react19.useState)(initialStep);
  const [status, setStatus] = (0, import_react19.useState)("idle");
  return (0, import_jsx_runtime35.jsxs)(Container, { p: "lg", children: [(0, import_jsx_runtime35.jsx)(ModalHeader, { title: "Buy", onBack: props.onBack }), props.isFiatFlow ? (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, { children: [(0, import_jsx_runtime35.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime35.jsx)(StepBar, { steps: 2, currentStep: 2 }), (0, import_jsx_runtime35.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime35.jsxs)(Text, { size: "xs", children: ["Step 2 of 2 - Converting ", props.fromTokenSymbol, " to", " ", props.toTokenSymbol] }), (0, import_jsx_runtime35.jsx)(Spacer, { y: "md" })] }) : (0, import_jsx_runtime35.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime35.jsx)(ConfirmItem, { label: "Receive", children: (0, import_jsx_runtime35.jsx)(RenderTokenInfo, { chain: props.toChain, amount: String(formatNumber(Number(props.toAmount), 4)), symbol: props.toTokenSymbol, token: props.toToken, client: props.client }) }), (0, import_jsx_runtime35.jsx)(ConfirmItem, { label: "Pay", children: (0, import_jsx_runtime35.jsx)(RenderTokenInfo, { chain: props.fromChain, amount: String(formatNumber(Number(props.fromAmount), 4)), symbol: props.fromTokenSymbol || "", token: props.fromToken, client: props.client }) }), (0, import_jsx_runtime35.jsx)(ConfirmItem, { label: "Fees", children: (0, import_jsx_runtime35.jsx)(SwapFees, { quote: props.quote, align: "right" }) }), (0, import_jsx_runtime35.jsx)(ConfirmItem, { label: "Time", children: (0, import_jsx_runtime35.jsxs)(Text, { color: "primaryText", children: ["~", formatSeconds(props.quote.swapDetails.estimated.durationSeconds || 0)] }) }), (0, import_jsx_runtime35.jsx)(Spacer, { y: "xl" }), isApprovalRequired && (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, { children: [(0, import_jsx_runtime35.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime35.jsxs)(Container, { gap: "sm", flex: "row", style: {
    justifyContent: "space-between"
  }, center: "y", color: "accentText", children: [(0, import_jsx_runtime35.jsx)(Step, { isDone: step === "swap", isActive: step === "approval", label: step === "approval" ? "Approve" : "Approved" }), (0, import_jsx_runtime35.jsx)(ConnectorLine, {}), (0, import_jsx_runtime35.jsx)(Step, { isDone: false, label: "Confirm", isActive: step === "swap" })] }), (0, import_jsx_runtime35.jsx)(Spacer, { y: "lg" })] }), status === "error" && (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, { children: [(0, import_jsx_runtime35.jsxs)(Container, { flex: "row", gap: "xs", center: "both", color: "danger", children: [(0, import_jsx_runtime35.jsx)(CrossCircledIcon, { width: iconSize.sm, height: iconSize.sm }), (0, import_jsx_runtime35.jsx)(Text, { color: "danger", size: "sm", children: step === "approval" ? "Failed to Approve" : "Failed to Confirm" })] }), (0, import_jsx_runtime35.jsx)(Spacer, { y: "md" })] }), activeChain && activeChain.id !== props.fromChain.id ? (0, import_jsx_runtime35.jsx)(SwitchNetworkButton, { fullWidth: true, chain: props.fromChain, variant: "accent" }) : (0, import_jsx_runtime35.jsxs)(Button, { variant: "accent", fullWidth: true, disabled: status === "pending", onClick: async () => {
    if (step === "approval" && props.quote.approval) {
      try {
        setStatus("pending");
        const tx = await sendTransactionMutation.mutateAsync(props.quote.approval);
        await waitForReceipt({ ...tx, maxBlocksWaitTime: 50 });
        setStep("swap");
        setStatus("idle");
      } catch (e) {
        console.error(e);
        setStatus("error");
      }
    }
    if (step === "swap") {
      setStatus("pending");
      try {
        let tx = props.quote.transactionRequest;
        if ((activeWallet == null ? void 0 : activeWallet.id) === "inApp" || (activeWallet == null ? void 0 : activeWallet.id) === "embedded") {
          tx = {
            ...props.quote.transactionRequest,
            gasPrice: void 0
          };
        }
        const _swapTx = await sendTransactionMutation.mutateAsync(tx);
        await waitForReceipt({ ..._swapTx, maxBlocksWaitTime: 50 });
        if (!props.isFiatFlow) {
          addPendingTx({
            type: "swap",
            txHash: _swapTx.transactionHash
          });
        }
        props.setSwapTxHash(_swapTx.transactionHash);
      } catch (e) {
        console.error(e);
        setStatus("error");
      }
    }
  }, gap: "xs", children: [step === "approval" && (status === "pending" ? "Approving" : "Approve"), step === "swap" && (status === "pending" ? "Confirming" : "Confirm"), status === "pending" && (0, import_jsx_runtime35.jsx)(Spinner, { size: "sm", color: "accentButtonText" })] })] });
}
var ConnectorLine = StyledDiv(() => {
  const theme = useCustomTheme();
  return {
    height: "4px",
    background: theme.colors.borderColor,
    flex: 1
  };
});
function RenderTokenInfo(props) {
  const chainQuery = useChainQuery(props.chain);
  return (0, import_jsx_runtime35.jsxs)(Container, { flex: "column", gap: "xxs", style: {
    alignItems: "flex-end"
  }, children: [(0, import_jsx_runtime35.jsxs)(Container, { flex: "row", center: "y", gap: "xs", children: [(0, import_jsx_runtime35.jsxs)(Text, { color: "primaryText", size: "md", children: [props.amount, " ", props.symbol] }), (0, import_jsx_runtime35.jsx)(PayTokenIcon, { token: props.token, chain: props.chain, size: "sm", client: props.client })] }), chainQuery.data ? (0, import_jsx_runtime35.jsx)(Text, { size: "sm", children: chainQuery.data.name }) : (0, import_jsx_runtime35.jsx)(Skeleton, { width: "100px", height: fontSize.sm })] });
}
function ConfirmItem(props) {
  return (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, { children: [(0, import_jsx_runtime35.jsxs)(Container, { flex: "row", gap: "md", py: "md", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime35.jsx)(Text, { size: "md", color: "secondaryText", children: props.label }), props.children] }), (0, import_jsx_runtime35.jsx)(Line, {})] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/SwapStatusScreen.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getStatus.js
async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
  var _a;
  try {
    if (!buyWithCryptoTransaction.transactionHash) {
      throw new Error("Transaction hash is required");
    }
    const queryString = new URLSearchParams({
      transactionHash: buyWithCryptoTransaction.transactionHash
    }).toString();
    const url = `${getPayBuyWithCryptoStatusUrl()}?${queryString}`;
    const response = await getClientFetch(buyWithCryptoTransaction.client)(url);
    if (!response.ok) {
      (_a = response.body) == null ? void 0 : _a.cancel();
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    return data;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithCryptoStatus.js
function useBuyWithCryptoStatus(params) {
  return useQuery({
    queryKey: ["getBuyWithCryptoStatus", params == null ? void 0 : params.transactionHash],
    queryFn: async () => {
      if (!params) {
        throw new Error("No params");
      }
      return getBuyWithCryptoStatus(params);
    },
    enabled: !!params,
    refetchInterval: 5e3,
    refetchIntervalInBackground: true,
    retry: true
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/tx-history/SwapDetailsScreen.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
function SwapDetailsScreen(props) {
  var _a, _b;
  const { status: initialStatus, client } = props;
  const statusQuery = useBuyWithCryptoStatus(((_a = initialStatus.source) == null ? void 0 : _a.transactionHash) ? {
    client,
    transactionHash: initialStatus.source.transactionHash
  } : void 0);
  const status = (((_b = statusQuery.data) == null ? void 0 : _b.status) !== "NOT_FOUND" ? statusQuery.data : void 0) || initialStatus;
  return (0, import_jsx_runtime36.jsxs)(Container, { children: [(0, import_jsx_runtime36.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime36.jsx)(ModalHeader, { title: "Transaction Details", onBack: props.onBack }) }), (0, import_jsx_runtime36.jsx)(Line, {}), (0, import_jsx_runtime36.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime36.jsx)(SwapTxDetailsTable, { type: "status", status, client }) })] });
}
function SwapTxDetailsTable(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let uiData;
  let showStatusRow = true;
  if (props.type === "status") {
    const status = props.status;
    if (props.hideStatusRow) {
      showStatusRow = false;
    }
    const isPartialSuccess2 = status.status === "COMPLETED" && status.subStatus === "PARTIAL_SUCCESS";
    uiData = {
      fromToken: {
        chainId: status.quote.fromToken.chainId,
        symbol: status.quote.fromToken.symbol || "",
        address: status.quote.fromToken.tokenAddress,
        amount: status.quote.fromAmount
      },
      quotedToToken: {
        chainId: status.quote.toToken.chainId,
        symbol: status.quote.toToken.symbol || "",
        address: status.quote.toToken.tokenAddress,
        amount: status.quote.toAmount
      },
      gotToken: status.destination ? {
        chainId: status.destination.token.chainId,
        symbol: status.destination.token.symbol || "",
        address: status.destination.token.tokenAddress,
        amount: status.destination.amount
      } : void 0,
      statusMeta: getBuyWithCryptoStatusMeta(status),
      estimatedDuration: status.quote.estimated.durationSeconds || 0,
      isPartialSuccess: isPartialSuccess2,
      destinationTxHash: (_a = status.destination) == null ? void 0 : _a.transactionHash,
      sourceTxHash: (_b = status.source) == null ? void 0 : _b.transactionHash
    };
  } else {
    const quote = props.quote;
    uiData = {
      fromToken: {
        chainId: quote.swapDetails.fromToken.chainId,
        symbol: quote.swapDetails.fromToken.symbol || "",
        address: quote.swapDetails.fromToken.tokenAddress,
        amount: quote.swapDetails.fromAmount
      },
      quotedToToken: {
        chainId: quote.swapDetails.toToken.chainId,
        symbol: quote.swapDetails.toToken.symbol || "",
        address: quote.swapDetails.toToken.tokenAddress,
        amount: quote.swapDetails.toAmount
      },
      isPartialSuccess: false,
      estimatedDuration: quote.swapDetails.estimated.durationSeconds || 0
    };
  }
  const { client } = props;
  const { fromToken, quotedToToken: toToken, statusMeta, sourceTxHash, destinationTxHash, isPartialSuccess, gotToken, estimatedDuration } = uiData;
  const fromChainId = fromToken.chainId;
  const toChainId = toToken.chainId;
  const fromChainQuery = useChainQuery(getCachedChain(fromChainId));
  const toChainQuery = useChainQuery(getCachedChain(toChainId));
  const lineSpacer = (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [(0, import_jsx_runtime36.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime36.jsx)(Line, {}), (0, import_jsx_runtime36.jsx)(Spacer, { y: "md" })] });
  return (0, import_jsx_runtime36.jsxs)("div", { children: [isPartialSuccess && gotToken ? (
    // Expected + Got
    (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [(0, import_jsx_runtime36.jsx)(TokenInfoRow, { chainId: toToken.chainId, client, label: isPartialSuccess ? "Expected" : "Received", tokenAmount: toToken.amount, tokenSymbol: toToken.symbol || "", tokenAddress: toToken.address }), lineSpacer, (0, import_jsx_runtime36.jsx)(TokenInfoRow, { chainId: gotToken.chainId, client, label: "Got", tokenAmount: gotToken.amount, tokenSymbol: gotToken.symbol || "", tokenAddress: gotToken.address })] })
  ) : (
    // Receive
    (0, import_jsx_runtime36.jsx)(TokenInfoRow, { chainId: toToken.chainId, client, label: "Receive", tokenAmount: toToken.amount, tokenSymbol: toToken.symbol || "", tokenAddress: toToken.address })
  ), lineSpacer, (0, import_jsx_runtime36.jsx)(TokenInfoRow, { chainId: fromToken.chainId, client, label: "Pay", tokenAmount: fromToken.amount, tokenSymbol: fromToken.symbol || "", tokenAddress: fromToken.address }), lineSpacer, (0, import_jsx_runtime36.jsxs)(Container, { flex: "row", center: "y", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime36.jsx)(Text, { children: " Time " }), (0, import_jsx_runtime36.jsx)(Container, { flex: "row", gap: "xs", center: "y", children: (0, import_jsx_runtime36.jsxs)(Text, { color: "primaryText", children: ["~", formatSeconds(estimatedDuration || 0)] }) })] }), statusMeta && showStatusRow && (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [lineSpacer, (0, import_jsx_runtime36.jsxs)(Container, { flex: "row", center: "y", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime36.jsx)(Text, { children: "Status" }), (0, import_jsx_runtime36.jsx)(Container, { flex: "row", gap: "xs", center: "y", children: (0, import_jsx_runtime36.jsx)(Text, { color: statusMeta.color, children: statusMeta.status }) })] })] }), lineSpacer, ((_e = (_d = (_c = fromChainQuery.data) == null ? void 0 : _c.explorers) == null ? void 0 : _d[0]) == null ? void 0 : _e.url) && sourceTxHash && (0, import_jsx_runtime36.jsxs)(ButtonLink, { fullWidth: true, variant: "outline", href: `${fromChainQuery.data.explorers[0].url}/tx/${sourceTxHash}`, target: "_blank", gap: "xs", style: {
    fontSize: fontSize.sm,
    padding: spacing.sm
  }, children: ["View on ", fromChainQuery.data.name, " Explorer", (0, import_jsx_runtime36.jsx)(ExternalLinkIcon, { width: iconSize.sm, height: iconSize.sm })] }), destinationTxHash && sourceTxHash !== destinationTxHash && ((_h = (_g = (_f = toChainQuery.data) == null ? void 0 : _f.explorers) == null ? void 0 : _g[0]) == null ? void 0 : _h.url) && (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [(0, import_jsx_runtime36.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime36.jsxs)(ButtonLink, { fullWidth: true, variant: "outline", href: `${toChainQuery.data.explorers[0].url}/tx/${destinationTxHash}`, target: "_blank", gap: "xs", style: {
    fontSize: fontSize.sm,
    padding: spacing.sm
  }, children: ["View on ", toChainQuery.data.name, " Explorer", (0, import_jsx_runtime36.jsx)(ExternalLinkIcon, { width: iconSize.sm, height: iconSize.sm })] })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/SwapStatusScreen.js
function SwapStatusScreen(props) {
  var _a, _b, _c, _d, _e, _f;
  const swapStatus = useBuyWithCryptoStatus({
    client: props.client,
    transactionHash: props.swapTxHash
  });
  let uiStatus = "pending";
  if (((_a = swapStatus.data) == null ? void 0 : _a.status) === "COMPLETED") {
    uiStatus = "success";
  } else if (((_b = swapStatus.data) == null ? void 0 : _b.status) === "FAILED") {
    uiStatus = "failed";
  }
  if (((_c = swapStatus.data) == null ? void 0 : _c.status) === "COMPLETED" && ((_d = swapStatus.data) == null ? void 0 : _d.subStatus) === "PARTIAL_SUCCESS") {
    uiStatus = "partialSuccess";
  }
  const queryClient = useQueryClient();
  const balanceInvalidated = (0, import_react20.useRef)(false);
  (0, import_react20.useEffect)(() => {
    if ((uiStatus === "success" || uiStatus === "partialSuccess") && !balanceInvalidated.current) {
      balanceInvalidated.current = true;
      invalidateWalletBalance(queryClient);
    }
  }, [queryClient, uiStatus]);
  const swapDetails = swapStatus.data && swapStatus.data.status !== "NOT_FOUND" ? (0, import_jsx_runtime37.jsx)(SwapTxDetailsTable, { status: swapStatus.data, type: "status", hideStatusRow: true, client: props.client }) : (0, import_jsx_runtime37.jsx)(SwapTxDetailsTable, { type: "quote", quote: props.quote, client: props.client });
  return (0, import_jsx_runtime37.jsx)(Container, { animate: "fadein", children: (0, import_jsx_runtime37.jsxs)(Container, { p: "lg", children: [(0, import_jsx_runtime37.jsx)(ModalHeader, { title: "Buy", onBack: props.onBack }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "sm" }), uiStatus === "success" && (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [(0, import_jsx_runtime37.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime37.jsxs)(Container, { color: "success", flex: "column", center: "x", children: [(0, import_jsx_runtime37.jsx)(CheckCircledIcon, { width: iconSize["3xl"], height: iconSize["3xl"] }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime37.jsx)(Text, { color: "primaryText", size: "lg", children: "Buy Success" })] }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "xl" }), swapDetails, (0, import_jsx_runtime37.jsx)(Spacer, { y: "sm" }), !props.isEmbed && (0, import_jsx_runtime37.jsx)(Button, { variant: "accent", fullWidth: true, onClick: props.onDone, children: props.isBuyForTx ? "Continue Transaction" : "Done" })] }), uiStatus === "partialSuccess" && ((_e = swapStatus.data) == null ? void 0 : _e.status) !== "NOT_FOUND" && ((_f = swapStatus.data) == null ? void 0 : _f.destination) && (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [(0, import_jsx_runtime37.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime37.jsxs)(Container, { color: "success", flex: "column", center: "x", children: [(0, import_jsx_runtime37.jsx)(AccentFailIcon, { size: iconSize["3xl"] }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime37.jsx)(Text, { color: "primaryText", size: "lg", children: "Incomplete" }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime37.jsxs)(Text, { size: "sm", color: "danger", children: ["Expected ", swapStatus.data.quote.toToken.symbol, ", Got", " ", swapStatus.data.destination.token.symbol, " instead"] })] }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "xl" }), swapDetails] }), uiStatus === "failed" && (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [(0, import_jsx_runtime37.jsx)(Spacer, { y: "xxl" }), (0, import_jsx_runtime37.jsxs)(Container, { flex: "column", children: [(0, import_jsx_runtime37.jsxs)(Container, { flex: "column", center: "both", children: [(0, import_jsx_runtime37.jsx)(AccentFailIcon, { size: iconSize["3xl"] }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime37.jsx)(Text, { color: "primaryText", size: "lg", children: "Transaction Failed" }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime37.jsxs)(Text, { size: "sm", children: ["Your transaction ", `couldn't`, " be processed"] })] }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime37.jsx)(Button, { variant: "accent", fullWidth: true, onClick: props.onTryAgain, children: "Try Again" }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "xl" }), swapDetails] })] }), uiStatus === "pending" && (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [(0, import_jsx_runtime37.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime37.jsxs)(Container, { flex: "column", animate: "fadein", center: "both", children: [(0, import_jsx_runtime37.jsx)("div", { style: {
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }, children: (0, import_jsx_runtime37.jsx)(Spinner, { size: "3xl", color: "accentText" }) }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime37.jsx)(Text, { color: "primaryText", size: "lg", children: "Buy Pending" })] }), (0, import_jsx_runtime37.jsx)(Spacer, { y: "xxl" }), swapDetails] })] }) });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/SwapFlow.js
function SwapFlow(props) {
  const [swapTxHash, setSwapTxHash] = (0, import_react21.useState)();
  const quote = props.buyWithCryptoQuote;
  const fromChain = (0, import_react21.useMemo)(() => getCachedChain(quote.swapDetails.fromToken.chainId), [quote]);
  const toChain = (0, import_react21.useMemo)(() => getCachedChain(quote.swapDetails.toToken.chainId), [quote]);
  const fromTokenSymbol = quote.swapDetails.fromToken.symbol || "";
  const toTokenSymbol = quote.swapDetails.toToken.symbol || "";
  const fromAmount = quote.swapDetails.fromAmount;
  const toAmount = quote.swapDetails.toAmount;
  const _toToken = quote.swapDetails.toToken;
  const _fromToken = quote.swapDetails.fromToken;
  const toToken = (0, import_react21.useMemo)(() => {
    if (_toToken.tokenAddress === NATIVE_TOKEN_ADDRESS) {
      return NATIVE_TOKEN;
    }
    const tokenInfo = {
      address: _toToken.tokenAddress,
      name: _toToken.name || "",
      symbol: _toToken.symbol || ""
    };
    return tokenInfo;
  }, [_toToken]);
  const fromToken = (0, import_react21.useMemo)(() => {
    if (_fromToken.tokenAddress === NATIVE_TOKEN_ADDRESS) {
      return NATIVE_TOKEN;
    }
    const tokenInfo = {
      address: _fromToken.tokenAddress,
      name: _fromToken.name || "",
      symbol: _fromToken.symbol || ""
    };
    return tokenInfo;
  }, [_fromToken]);
  if (swapTxHash) {
    return (0, import_jsx_runtime38.jsx)(SwapStatusScreen, { onBack: props.onBack, onTryAgain: props.onTryAgain, onViewPendingTx: props.onViewPendingTx, swapTxHash, client: props.client, onDone: props.onDone, isBuyForTx: props.isBuyForTx, isEmbed: props.isEmbed, quote });
  }
  return (0, import_jsx_runtime38.jsx)(SwapConfirmationScreen, { setSwapTxHash, toChain, toAmount, toTokenSymbol, fromChain, toToken, fromAmount, fromToken, fromTokenSymbol, client: props.client, onBack: props.onBack, onTryAgain: props.onTryAgain, quote, isFiatFlow: props.isFiatFlow });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/PostOnRampSwap.js
function PostOnRampSwap(props) {
  const account = useActiveAccount();
  const [lockedOnRampQuote, setLockedOnRampQuote] = (0, import_react22.useState)(void 0);
  const postOnRampQuoteQuery = useQuery({
    queryKey: ["getPostOnRampQuote", props.buyWithFiatStatus],
    queryFn: async () => {
      return await getPostOnRampQuote({
        client: props.client,
        buyWithFiatStatus: props.buyWithFiatStatus
      });
    },
    // stop fetching if a quote is already locked
    enabled: !lockedOnRampQuote,
    refetchOnWindowFocus: false
  });
  (0, import_react22.useEffect)(() => {
    if (postOnRampQuoteQuery.data && !lockedOnRampQuote && !postOnRampQuoteQuery.isRefetching) {
      setLockedOnRampQuote(postOnRampQuoteQuery.data);
    }
  }, [
    postOnRampQuoteQuery.data,
    lockedOnRampQuote,
    postOnRampQuoteQuery.isRefetching
  ]);
  if (postOnRampQuoteQuery.isError) {
    return (0, import_jsx_runtime39.jsxs)(Container, { fullHeight: true, children: [(0, import_jsx_runtime39.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime39.jsx)(ModalHeader, { title: "Buy", onBack: props.onBack }) }), (0, import_jsx_runtime39.jsxs)(Container, { style: {
      minHeight: "300px"
    }, flex: "column", center: "both", p: "lg", children: [(0, import_jsx_runtime39.jsx)(AccentFailIcon, { size: iconSize["3xl"] }), (0, import_jsx_runtime39.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime39.jsx)(Text, { color: "primaryText", children: "Failed to get a price quote" }), (0, import_jsx_runtime39.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime39.jsx)(Button, { fullWidth: true, variant: "primary", onClick: () => {
      postOnRampQuoteQuery.refetch();
    }, children: "Try Again" })] }), (0, import_jsx_runtime39.jsx)(Spacer, { y: "xxl" })] });
  }
  if (!lockedOnRampQuote || !account) {
    return (0, import_jsx_runtime39.jsxs)(Container, { fullHeight: true, children: [(0, import_jsx_runtime39.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime39.jsx)(ModalHeader, { title: "Buy", onBack: props.onBack }) }), (0, import_jsx_runtime39.jsxs)(Container, { style: {
      minHeight: "300px"
    }, flex: "column", center: "both", children: [(0, import_jsx_runtime39.jsx)(Spinner, { size: "xxl", color: "accentText" }), (0, import_jsx_runtime39.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime39.jsx)(Text, { color: "primaryText", children: "Getting price quote" })] }), (0, import_jsx_runtime39.jsx)(Spacer, { y: "xxl" })] });
  }
  return (0, import_jsx_runtime39.jsx)(SwapFlow, { account, buyWithCryptoQuote: lockedOnRampQuote, client: props.client, onBack: props.onBack, onViewPendingTx: props.onViewPendingTx, isFiatFlow: true, onDone: props.onDone, onTryAgain: () => {
    setLockedOnRampQuote(void 0);
    postOnRampQuoteQuery.refetch();
  }, isBuyForTx: props.isBuyForTx, isEmbed: props.isEmbed });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/PostOnRampSwapFlow.js
function PostOnRampSwapFlow(props) {
  const [statusForSwap, setStatusForSwap] = (0, import_react23.useState)();
  if (statusForSwap) {
    return (0, import_jsx_runtime40.jsx)(PostOnRampSwap, { buyWithFiatStatus: statusForSwap, client: props.client, onViewPendingTx: props.onViewPendingTx, onDone: props.onDone, isBuyForTx: props.isBuyForTx, isEmbed: props.isEmbed });
  }
  return (0, import_jsx_runtime40.jsx)(FiatSteps, { client: props.client, onBack: props.onBack, partialQuote: props.quote, step: 2, onContinue: () => {
    props.onSwapFlowStarted();
    setStatusForSwap(props.status);
  }, status: props.status });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatFlow.js
function FiatFlow(props) {
  const hasTwoSteps = isSwapRequiredPostOnramp(props.quote);
  const [screen, setScreen] = (0, import_react24.useState)(hasTwoSteps ? {
    id: "step-1"
  } : {
    id: "onramp-status"
  });
  const [popupWindow, setPopupWindow] = (0, import_react24.useState)(props.openedWindow);
  if (screen.id === "step-1") {
    return (0, import_jsx_runtime41.jsx)(FiatSteps, { client: props.client, onBack: props.onBack, partialQuote: fiatQuoteToPartialQuote(props.quote), step: 1, onContinue: () => {
      const popup = openOnrampPopup(props.quote.onRampLink, props.theme);
      addPendingTx({
        type: "fiat",
        intentId: props.quote.intentId
      });
      setPopupWindow(popup);
      setScreen({ id: "onramp-status" });
    } });
  }
  if (screen.id === "onramp-status") {
    return (0, import_jsx_runtime41.jsx)(OnrampStatusScreen, { client: props.client, intentId: props.quote.intentId, onBack: props.onBack, onViewPendingTx: props.onViewPendingTx, hasTwoSteps, openedWindow: popupWindow, quote: props.quote, onDone: props.onDone, onShowSwapFlow: (_status) => {
      setScreen({ id: "postonramp-swap", data: _status });
    }, isBuyForTx: props.isBuyForTx, isEmbed: props.isEmbed });
  }
  if (screen.id === "postonramp-swap") {
    return (0, import_jsx_runtime41.jsx)(PostOnRampSwapFlow, { status: screen.data, quote: fiatQuoteToPartialQuote(props.quote), client: props.client, onBack: props.onBack, onViewPendingTx: props.onViewPendingTx, onDone: props.onDone, onSwapFlowStarted: () => {
    }, isBuyForTx: props.isBuyForTx, isEmbed: props.isEmbed });
  }
  return null;
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useBuyTxStates.js
var import_react25 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/react/core/utils/wait.js
var wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useBuyTxStates.js
function useBuyTxStates(options) {
  const { buyForTx, hasEditedAmount, setTokenAmount, account } = options;
  const shouldRefreshTokenAmount = !hasEditedAmount;
  const [amountNeeded, setAmountNeeded] = (0, import_react25.useState)(buyForTx == null ? void 0 : buyForTx.cost);
  (0, import_react25.useEffect)(() => {
    if (!buyForTx) {
      return;
    }
    let mounted = true;
    async function pollTxCost() {
      if (!buyForTx || !mounted) {
        return;
      }
      try {
        const totalCost = await getTotalTxCostForBuy(buyForTx.tx, account == null ? void 0 : account.address);
        if (!mounted) {
          return;
        }
        setAmountNeeded(totalCost);
        if (shouldRefreshTokenAmount) {
          if (totalCost > buyForTx.balance) {
            const _tokenAmount = String(formatNumber(Number(toEther(totalCost - buyForTx.balance)), 4));
            setTokenAmount(_tokenAmount);
          }
        }
      } catch {
      }
      await wait(3e4);
      pollTxCost();
    }
    pollTxCost();
    return () => {
      mounted = false;
    };
  }, [buyForTx, shouldRefreshTokenAmount, setTokenAmount, account]);
  return {
    amountNeeded
  };
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useEnabledPaymentMethods.js
function useEnabledPaymentMethods(options) {
  const { payOptions, supportedDestinations, toChain, toToken } = options;
  function getEnabledPayMethodsForSelectedToken() {
    const chain = supportedDestinations.find((c) => c.chain.id === toChain.id);
    if (!chain) {
      return {
        fiat: true,
        swap: true
      };
    }
    const toTokenAddress = isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address;
    const tokenInfo = chain.tokens.find((t) => t.address.toLowerCase() === toTokenAddress.toLowerCase());
    if (!tokenInfo) {
      return {
        fiat: true,
        swap: true
      };
    }
    return {
      fiat: tokenInfo.buyWithFiatEnabled,
      swap: tokenInfo.buyWithCryptoEnabled
    };
  }
  const { fiat, swap } = getEnabledPayMethodsForSelectedToken();
  const buyWithFiatEnabled = payOptions.buyWithFiat !== false && fiat;
  const buyWithCryptoEnabled = payOptions.buyWithCrypto !== false && swap;
  const showPaymentSelection = buyWithFiatEnabled && buyWithCryptoEnabled;
  return {
    buyWithFiatEnabled,
    buyWithCryptoEnabled,
    showPaymentSelection
  };
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useUISelectionStates.js
var import_react26 = __toESM(require_react(), 1);

// node_modules/thirdweb/dist/esm/chains/chain-definitions/polygon.js
var polygon = defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  blockExplorers: [
    {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  ]
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useUISelectionStates.js
function useUISelectionStates(options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const activeChain = useActiveWalletChain();
  const { payOptions, buyForTx, supportedDestinations } = options;
  const initialTokenAmount = ((_a = payOptions.prefillBuy) == null ? void 0 : _a.amount) || (buyForTx ? String(formatNumber(Number(toEther(buyForTx.cost - buyForTx.balance)), 4)) : "");
  const [tokenAmount, setTokenAmount] = (0, import_react26.useState)(initialTokenAmount);
  const deferredTokenAmount = useDebouncedValue(tokenAmount, 300);
  const [toChain, setToChain] = (0, import_react26.useState)(
    // use prefill chain if available
    ((_b = payOptions.prefillBuy) == null ? void 0 : _b.chain) || // use buyForTx chain if available
    (buyForTx == null ? void 0 : buyForTx.tx.chain) || // use active chain if its supported as destination
    ((_c = supportedDestinations.find((x) => x.chain.id === (activeChain == null ? void 0 : activeChain.id))) == null ? void 0 : _c.chain) || // default to polygon
    polygon
  );
  const [toToken, setToToken] = (0, import_react26.useState)(((_d = payOptions.prefillBuy) == null ? void 0 : _d.token) || NATIVE_TOKEN);
  const [fromChain, setFromChain] = (0, import_react26.useState)(
    // use prefill chain if available
    payOptions.buyWithCrypto !== false && ((_f = (_e = payOptions.buyWithCrypto) == null ? void 0 : _e.prefillSource) == null ? void 0 : _f.chain) || // default to polygon
    polygon
  );
  const [fromToken, setFromToken] = (0, import_react26.useState)(
    // use prefill token if available
    payOptions.buyWithCrypto !== false && ((_h = (_g = payOptions.buyWithCrypto) == null ? void 0 : _g.prefillSource) == null ? void 0 : _h.token) || // default to native token
    NATIVE_TOKEN
  );
  const [selectedCurrency, setSelectedCurrency] = (0, import_react26.useState)(defaultSelectedCurrency);
  return {
    tokenAmount,
    setTokenAmount,
    toChain,
    setToChain,
    deferredTokenAmount,
    fromChain,
    setFromChain,
    toToken,
    setToToken,
    fromToken,
    setFromToken,
    selectedCurrency,
    setSelectedCurrency
  };
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/BuyTokenInput.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/utils.js
function getBuyTokenAmountFontSize(value) {
  return value.length > 10 ? "26px" : value.length > 6 ? "34px" : "50px";
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/BuyTokenInput.js
function BuyTokenInput(props) {
  var _a;
  const chainQuery = useChainQuery(props.chain);
  const getWidth = () => {
    let chars = props.value.replace(".", "").length;
    const hasDot = props.value.includes(".");
    if (hasDot) {
      chars += 0.3;
    }
    return `calc(${`${Math.max(1, chars)}ch`} + 6px)`;
  };
  return (0, import_jsx_runtime42.jsxs)(Container, { children: [(0, import_jsx_runtime42.jsx)("div", { onClick: (e) => {
    var _a2;
    (_a2 = e.currentTarget.querySelector("input")) == null ? void 0 : _a2.focus();
  }, children: (0, import_jsx_runtime42.jsxs)(Container, { flex: "row", center: "both", gap: "xs", style: {
    flexWrap: "nowrap"
  }, children: [(0, import_jsx_runtime42.jsx)(Input, { variant: "outline", pattern: "^[0-9]*[.,]?[0-9]*$", inputMode: "decimal", tabIndex: -1, placeholder: "0", type: "text", "data-placeholder": props.value === "", value: props.value || "0", disabled: props.freezeAmount, onClick: (e) => {
    if (props.value === "") {
      e.currentTarget.setSelectionRange(e.currentTarget.value.length, e.currentTarget.value.length);
    }
  }, onChange: (e) => {
    let value = e.target.value;
    if (value.startsWith(".")) {
      value = `0${value}`;
    }
    const numValue = Number(value);
    if (Number.isNaN(numValue)) {
      return;
    }
    if (value.startsWith("0") && !value.startsWith("0.")) {
      props.onChange(value.slice(1));
    } else {
      props.onChange(value);
    }
  }, style: {
    border: "none",
    fontSize: getBuyTokenAmountFontSize(props.value),
    boxShadow: "none",
    borderRadius: "0",
    padding: "0",
    paddingBlock: "2px",
    fontWeight: 600,
    textAlign: "right",
    width: getWidth(),
    maxWidth: "calc(100% - 100px)"
  } }), (0, import_jsx_runtime42.jsx)(TokenSymbol, { token: props.token, chain: props.chain, size: "lg", color: "secondaryText" })] }) }), !props.hideTokenSelector && (0, import_jsx_runtime42.jsxs)(import_jsx_runtime42.Fragment, { children: [(0, import_jsx_runtime42.jsx)(Spacer, { y: "sm" }), (0, import_jsx_runtime42.jsx)(Container, { flex: "row", center: "x", children: (0, import_jsx_runtime42.jsxs)(TokenButton, { variant: "secondary", fullWidth: true, style: {
    fontSize: fontSize.sm
  }, gap: "xxs", onClick: props.onSelectToken, disabled: props.freezeChainAndToken, children: [(0, import_jsx_runtime42.jsxs)(Container, { flex: "row", center: "y", gap: "sm", children: [(0, import_jsx_runtime42.jsx)(TokenIcon, { token: props.token, chain: props.chain, size: "md", client: props.client }), (0, import_jsx_runtime42.jsxs)(Container, { flex: "column", style: {
    gap: "4px"
  }, children: [(0, import_jsx_runtime42.jsx)(TokenSymbol, { token: props.token, chain: props.chain, size: "sm" }), ((_a = chainQuery.data) == null ? void 0 : _a.name) ? (0, import_jsx_runtime42.jsx)(Text, { size: "xs", color: "secondaryText", children: chainQuery.data.name }) : (0, import_jsx_runtime42.jsx)(Skeleton, { width: "90px", height: fontSize.xs })] })] }), (0, import_jsx_runtime42.jsx)(ChevronDownIcon, { width: iconSize.sm, height: iconSize.sm, style: {
    marginLeft: "auto"
  } })] }) })] })] });
}
var TokenButton = newStyled(Button)(() => {
  const theme = useCustomTheme();
  return {
    background: theme.colors.tertiaryBg,
    border: `1px solid ${theme.colors.borderColor}`,
    justifyContent: "flex-start",
    transition: "background 0.3s",
    padding: spacing.sm
  };
});

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/PayWithCrypto.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/icons/GenericWalletIcon.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var GenericWalletIcon = (props) => {
  return (0, import_jsx_runtime43.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 18 18", width: props.size, height: props.size, role: "presentation", children: (0, import_jsx_runtime43.jsx)("path", { fill: "currentColor", d: "M15.6 4.6H1.85v-.55l12.1-.968v.968h1.65V2.4c0-1.21-.98-2.059-2.177-1.888L2.378 2.089C1.18 2.26.2 3.39.2 4.6v11a2.2 2.2 0 002.2 2.2h13.2a2.2 2.2 0 002.2-2.2V6.8a2.2 2.2 0 00-2.2-2.2zm-1.65 7.707a1.65 1.65 0 01-.63-3.176 1.65 1.65 0 11.63 3.176z" }) });
};

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/PayWithCrypto.js
function PayWithCrypto(props) {
  var _a;
  const chainQuery = useChainQuery(props.chain);
  const activeAccount = useActiveAccount();
  const balanceQuery = useWalletBalance({
    address: activeAccount == null ? void 0 : activeAccount.address,
    chain: props.chain,
    tokenAddress: isNativeToken(props.token) ? void 0 : props.token.address,
    client: props.client
  });
  return (0, import_jsx_runtime44.jsxs)(Container, { bg: "tertiaryBg", borderColor: "borderColor", flex: "row", style: {
    borderRadius: radius.md,
    borderBottomRightRadius: 0,
    borderBottomLeftRadius: 0,
    borderWidth: "1px",
    borderStyle: "solid",
    borderBottom: "none",
    flexWrap: "nowrap",
    justifyContent: "space-between",
    minHeight: "64px",
    alignItems: "center"
  }, children: [(0, import_jsx_runtime44.jsxs)(Button, { variant: "ghost", onClick: props.onSelectToken, gap: "sm", style: {
    paddingInline: spacing.sm,
    paddingBlock: spacing.sm,
    minWidth: "50%",
    justifyContent: "flex-start"
  }, disabled: props.freezeChainAndTokenSelection, children: [(0, import_jsx_runtime44.jsx)(PayTokenIcon, { token: props.token, chain: props.chain, size: "md", client: props.client }), (0, import_jsx_runtime44.jsxs)(Container, { flex: "column", gap: "xxs", children: [(0, import_jsx_runtime44.jsxs)(Container, { flex: "row", gap: "xs", center: "y", color: "primaryText", children: [(0, import_jsx_runtime44.jsx)(TokenSymbol, { token: props.token, chain: props.chain, size: "sm" }), (0, import_jsx_runtime44.jsx)(ChevronDownIcon, { width: iconSize.sm, height: iconSize.sm })] }), ((_a = chainQuery.data) == null ? void 0 : _a.name) ? (0, import_jsx_runtime44.jsxs)(Text, { size: "xs", children: [" ", chainQuery.data.name] }) : (0, import_jsx_runtime44.jsx)(Skeleton, { width: "90px", height: fontSize.xs })] })] }), (0, import_jsx_runtime44.jsxs)("div", { style: {
    flexGrow: 1,
    flexShrink: 1,
    display: "flex",
    flexDirection: "column",
    alignItems: "flex-end",
    gap: spacing.xxs,
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    justifyContent: "center",
    paddingRight: spacing.sm
  }, children: [props.isLoading ? (0, import_jsx_runtime44.jsx)(Skeleton, { width: "120px", height: fontSize.md, color: "borderColor" }) : (0, import_jsx_runtime44.jsx)(Text, { size: "md", color: props.value ? "primaryText" : "secondaryText", style: {}, children: formatNumber(Number(props.value), 4) || "--" }), (0, import_jsx_runtime44.jsxs)(Container, { flex: "row", gap: "xxs", center: "y", color: "secondaryText", children: [(0, import_jsx_runtime44.jsx)(GenericWalletIcon, { size: fontSize.xs }), balanceQuery.data ? (0, import_jsx_runtime44.jsx)(Text, { size: "xs", color: "secondaryText", weight: 500, children: formatTokenBalance(balanceQuery.data, true) }) : (0, import_jsx_runtime44.jsx)(Skeleton, { width: "70px", height: fontSize.xs })] })] })] });
}

// node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/BuyScreen.js
function BuyScreen(props) {
  const supportedDestinationsQuery = useBuySupportedDestinations(props.client);
  if (!supportedDestinationsQuery.data) {
    return (0, import_jsx_runtime45.jsx)(LoadingScreen, {});
  }
  return (0, import_jsx_runtime45.jsx)(BuyScreenContent, { ...props, onViewPendingTx: props.onViewPendingTx, supportedDestinations: supportedDestinationsQuery.data, buyForTx: props.buyForTx });
}
function useBuyScreenStates() {
  const [screen, setScreen] = (0, import_react27.useState)({
    id: "main"
  });
  const [drawerScreen, setDrawerScreen] = (0, import_react27.useState)();
  const { drawerRef, drawerOverlayRef, onClose } = useDrawer();
  function closeDrawer() {
    onClose(() => {
      setDrawerScreen(void 0);
    });
  }
  return {
    screen,
    setScreen,
    drawerScreen,
    setDrawerScreen,
    drawerRef,
    drawerOverlayRef,
    closeDrawer
  };
}
function BuyScreenContent(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const { client, supportedDestinations, connectLocale, payOptions, buyForTx } = props;
  const account = useActiveAccount();
  const activeChain = useActiveWalletChain();
  useChainsQuery(supportedDestinations.map((x) => x.chain) || [], 50);
  const { screen, setScreen, drawerScreen, setDrawerScreen, drawerRef, drawerOverlayRef, closeDrawer } = useBuyScreenStates();
  const { tokenAmount, setTokenAmount, toChain, setToChain, deferredTokenAmount, fromChain, setFromChain, toToken, setToToken, fromToken, setFromToken, selectedCurrency, setSelectedCurrency } = useUISelectionStates({
    payOptions,
    buyForTx,
    supportedDestinations
  });
  const supportedSourcesQuery = useBuySupportedSources({
    client: props.client,
    destinationChainId: toChain.id,
    destinationTokenAddress: isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address
  });
  const destinationSupportedTokens = (0, import_react27.useMemo)(() => {
    return createSupportedTokens(supportedDestinations, payOptions, props.supportedTokens);
  }, [props.supportedTokens, supportedDestinations, payOptions]);
  const sourceSupportedTokens = (0, import_react27.useMemo)(() => {
    if (!supportedSourcesQuery.data) {
      return void 0;
    }
    return createSupportedTokens(supportedSourcesQuery.data, payOptions, props.supportedTokens);
  }, [props.supportedTokens, supportedSourcesQuery.data, payOptions]);
  if (screen.id === "node") {
    return screen.node;
  }
  if (screen.id === "select-currency") {
    const goBack = () => setScreen(screen.backScreen);
    return (0, import_jsx_runtime45.jsx)(CurrencySelection, { onSelect: (currency) => {
      goBack();
      setSelectedCurrency(currency);
    }, onBack: goBack });
  }
  if (screen.id === "select-to-token") {
    const chains = supportedDestinations.map((x) => x.chain);
    const goBack = () => setScreen(screen.backScreen);
    if (((_b = (_a = payOptions.prefillBuy) == null ? void 0 : _a.allowEdits) == null ? void 0 : _b.token) === false) {
      return (0, import_jsx_runtime45.jsx)(ChainSelectionScreen, { chains, client: props.client, connectLocale: props.connectLocale, setChain: setToChain, goBack });
    }
    return (0, import_jsx_runtime45.jsx)(TokenSelector, { onBack: goBack, tokenList: (((toChain == null ? void 0 : toChain.id) ? destinationSupportedTokens[toChain.id] : void 0) || []).filter((x) => x.address !== NATIVE_TOKEN_ADDRESS), onTokenSelect: (tokenInfo) => {
      setToToken(tokenInfo);
      goBack();
    }, chain: toChain, chainSelection: (
      // hide chain selection if it's disabled
      ((_d = (_c = payOptions.prefillBuy) == null ? void 0 : _c.allowEdits) == null ? void 0 : _d.chain) !== false ? {
        chains,
        select: (c) => {
          setToChain(c);
        }
      } : void 0
    ), connectLocale, client, modalTitle: "Buy" });
  }
  if (screen.id === "select-from-token" && supportedSourcesQuery.data && sourceSupportedTokens) {
    const chains = supportedSourcesQuery.data.map((x) => x.chain);
    const goBack = () => setScreen(screen.backScreen);
    if (payOptions.buyWithCrypto !== false && ((_g = (_f = (_e = payOptions.buyWithCrypto) == null ? void 0 : _e.prefillSource) == null ? void 0 : _f.allowEdits) == null ? void 0 : _g.token) === false) {
      return (0, import_jsx_runtime45.jsx)(ChainSelectionScreen, { chains, client: props.client, connectLocale: props.connectLocale, setChain: setFromChain, goBack });
    }
    return (0, import_jsx_runtime45.jsx)(TokenSelector, { onBack: goBack, tokenList: (((fromChain == null ? void 0 : fromChain.id) ? sourceSupportedTokens[fromChain.id] : void 0) || []).filter((x) => x.address !== NATIVE_TOKEN_ADDRESS), onTokenSelect: (tokenInfo) => {
      setFromToken(tokenInfo);
      goBack();
    }, chain: fromChain, chainSelection: (
      // hide chain selection if it's disabled
      payOptions.buyWithCrypto !== false && ((_j = (_i = (_h = payOptions.buyWithCrypto) == null ? void 0 : _h.prefillSource) == null ? void 0 : _i.allowEdits) == null ? void 0 : _j.chain) !== false ? {
        chains: supportedSourcesQuery.data.map((x) => x.chain),
        select: (c) => setFromChain(c)
      } : void 0
    ), connectLocale, client, modalTitle: "Pay with" });
  }
  return (0, import_jsx_runtime45.jsx)(Container, { animate: "fadein", children: (0, import_jsx_runtime45.jsxs)("div", { onClick: (e) => {
    if (drawerScreen && drawerRef.current && !drawerRef.current.contains(e.target)) {
      e.preventDefault();
      e.stopPropagation();
      closeDrawer();
    }
  }, children: [drawerScreen && (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [(0, import_jsx_runtime45.jsx)(DrawerOverlay, { ref: drawerOverlayRef }), (0, import_jsx_runtime45.jsx)(Drawer, { ref: drawerRef, close: closeDrawer, children: (0, import_jsx_runtime45.jsx)(DynamicHeight, { children: drawerScreen }) })] }), screen.id === "main" && (0, import_jsx_runtime45.jsx)(MainScreen, { account: account || null, buyForTx: buyForTx || null, client, onSelectBuyToken: () => setScreen({ id: "select-to-token", backScreen: screen }), payOptions, setTokenAmount, toChain, toToken, tokenAmount, connectButton: props.connectButton, onViewPendingTx: props.onViewPendingTx, setScreen, supportedDestinations }), (screen.id === "select-payment-method" || screen.id === "buy-with-crypto" || screen.id === "buy-with-fiat") && (0, import_jsx_runtime45.jsxs)(TokenSelectedLayout, { selectedChain: toChain, selectedToken: toToken, tokenAmount, client, onBack: () => {
    if (screen.id === "buy-with-crypto" || screen.id === "buy-with-fiat") {
      setScreen({ id: "select-payment-method" });
    } else if (screen.id === "select-payment-method") {
      setScreen({ id: "main" });
    }
  }, children: [screen.id === "select-payment-method" && (0, import_jsx_runtime45.jsx)(PaymentMethodSelection, { setScreen: (id) => setScreen({ id }) }), screen.id === "buy-with-crypto" && account && activeChain && (0, import_jsx_runtime45.jsx)(SwapScreenContent, { setScreen, setDrawerScreen, tokenAmount: deferredTokenAmount, toChain, toToken, fromChain, fromToken, showFromTokenSelector: () => {
    setScreen({
      id: "select-from-token",
      backScreen: screen
    });
  }, account, activeChain, buyForTx: buyForTx || null, client, isEmbed: props.isEmbed, onDone: props.onDone, onViewPendingTx: props.onViewPendingTx, payOptions }), screen.id === "buy-with-fiat" && account && activeChain && (0, import_jsx_runtime45.jsx)(FiatScreenContent, { setScreen, setDrawerScreen, tokenAmount: deferredTokenAmount, toChain, toToken, selectedCurrency, buyForTx: buyForTx || null, client, isEmbed: props.isEmbed, onDone: props.onDone, onViewPendingTx: props.onViewPendingTx, payOptions, theme: props.theme, showCurrencySelector: () => {
    setScreen({
      id: "select-currency",
      backScreen: screen
    });
  }, account })] })] }) });
}
function SelectedTokenInfo(props) {
  return (0, import_jsx_runtime45.jsx)("div", { children: (0, import_jsx_runtime45.jsxs)(Container, { flex: "row", gap: "sm", center: "y", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime45.jsxs)(Container, { flex: "row", gap: "xs", center: "y", children: [(0, import_jsx_runtime45.jsx)(Text, { color: "primaryText", "data-testid": "tokenAmount", size: "xxl", children: formatNumber(Number(props.tokenAmount), 3) }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "row", gap: "xxs", center: "y", children: [(0, import_jsx_runtime45.jsx)(TokenSymbol, { token: props.selectedToken, chain: props.selectedChain, size: "md", color: "secondaryText" }), (0, import_jsx_runtime45.jsx)(PayTokenIcon, { chain: props.selectedChain, client: props.client, size: "sm", token: props.selectedToken })] })] }), (0, import_jsx_runtime45.jsx)(ChainName, { chain: props.selectedChain, client: props.client, size: "sm", short: true })] }) });
}
function MainScreen(props) {
  var _a, _b, _c, _d, _e, _f;
  const { showPaymentSelection, buyWithCryptoEnabled, buyWithFiatEnabled } = useEnabledPaymentMethods({
    payOptions: props.payOptions,
    supportedDestinations: props.supportedDestinations,
    toChain: props.toChain,
    toToken: props.toToken
  });
  const [hasEditedAmount, setHasEditedAmount] = (0, import_react27.useState)(false);
  const { buyForTx, setTokenAmount, account, client, tokenAmount, payOptions, toToken, toChain } = props;
  const { amountNeeded } = useBuyTxStates({
    setTokenAmount,
    buyForTx,
    hasEditedAmount,
    account
  });
  const disableContinue = !tokenAmount;
  return (0, import_jsx_runtime45.jsxs)(Container, { p: "lg", children: [(0, import_jsx_runtime45.jsx)(ModalHeader, { title: props.buyForTx ? `Not enough ${props.buyForTx.tokenSymbol}` : "Buy" }), amountNeeded && props.buyForTx ? (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [(0, import_jsx_runtime45.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime45.jsx)(BuyForTxUI, { amountNeeded: String(formatNumber(Number(toEther(amountNeeded)), 4)), buyForTx: props.buyForTx, client })] }) : (0, import_jsx_runtime45.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime45.jsx)(BuyTokenInput, { value: tokenAmount, onChange: async (value) => {
    setHasEditedAmount(true);
    setTokenAmount(value);
  }, freezeAmount: ((_b = (_a = payOptions.prefillBuy) == null ? void 0 : _a.allowEdits) == null ? void 0 : _b.amount) === false, freezeChainAndToken: ((_d = (_c = payOptions.prefillBuy) == null ? void 0 : _c.allowEdits) == null ? void 0 : _d.chain) === false && ((_f = (_e = payOptions.prefillBuy) == null ? void 0 : _e.allowEdits) == null ? void 0 : _f.token) === false, token: toToken, chain: toChain, onSelectToken: props.onSelectBuyToken, client: props.client, hideTokenSelector: !!props.buyForTx }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "column", gap: "sm", children: [!account && props.connectButton ? (0, import_jsx_runtime45.jsx)("div", { children: props.connectButton }) : (0, import_jsx_runtime45.jsx)(Button, { variant: "accent", fullWidth: true, disabled: disableContinue, "data-disabled": disableContinue, onClick: () => {
    if (showPaymentSelection) {
      props.setScreen({ id: "select-payment-method" });
    } else if (buyWithCryptoEnabled) {
      props.setScreen({ id: "buy-with-crypto" });
    } else if (buyWithFiatEnabled) {
      props.setScreen({ id: "buy-with-fiat" });
    } else {
      console.error("No payment method enabled");
    }
  }, children: "Continue" }), account && (0, import_jsx_runtime45.jsx)(Button, { variant: "outline", fullWidth: true, style: {
    padding: spacing.xs,
    fontSize: fontSize.sm
  }, onClick: props.onViewPendingTx, children: "View all transactions" })] })] });
}
function TokenSelectedLayout(props) {
  return (0, import_jsx_runtime45.jsxs)(Container, { children: [(0, import_jsx_runtime45.jsx)(Container, { p: "lg", children: (0, import_jsx_runtime45.jsx)(ModalHeader, { title: "Buy", onBack: props.onBack }) }), (0, import_jsx_runtime45.jsxs)(Container, { px: "lg", style: {
    paddingBottom: spacing.lg
  }, children: [(0, import_jsx_runtime45.jsx)(Spacer, { y: "xs" }), (0, import_jsx_runtime45.jsx)(SelectedTokenInfo, { selectedToken: props.selectedToken, selectedChain: props.selectedChain, tokenAmount: props.tokenAmount, client: props.client }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime45.jsx)(Line, {}), (0, import_jsx_runtime45.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime45.jsx)(Text, { size: "sm", children: " Pay with " }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "sm" }), props.children] })] });
}
function PaymentMethodSelection(props) {
  return (0, import_jsx_runtime45.jsx)(Container, { animate: "fadein", children: (0, import_jsx_runtime45.jsxs)(Container, { flex: "column", gap: "sm", children: [(0, import_jsx_runtime45.jsxs)(Button, { variant: "outline", bg: "tertiaryBg", onClick: () => props.setScreen("buy-with-fiat"), gap: "sm", style: {
    justifyContent: "flex-start",
    textAlign: "left"
  }, children: [(0, import_jsx_runtime45.jsx)(Container, { color: "secondaryText", flex: "row", center: "both", children: (0, import_jsx_runtime45.jsx)(IdCardIcon, { style: {
    width: iconSize.md,
    height: iconSize.md
  } }) }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "column", gap: "xxs", children: [(0, import_jsx_runtime45.jsx)(Text, { size: "md", color: "primaryText", children: "Credit Card" }), (0, import_jsx_runtime45.jsx)(Text, { size: "xs", children: "Easily and securely make payments" })] })] }), (0, import_jsx_runtime45.jsxs)(Button, { variant: "outline", bg: "tertiaryBg", onClick: () => props.setScreen("buy-with-crypto"), style: {
    justifyContent: "flex-start"
  }, gap: "sm", children: [(0, import_jsx_runtime45.jsx)(Container, { color: "secondaryText", flex: "row", center: "both", children: (0, import_jsx_runtime45.jsx)(CoinsIcon, { size: iconSize.md }) }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "column", gap: "xxs", children: [(0, import_jsx_runtime45.jsx)(Text, { size: "md", color: "primaryText", children: "Crypto" }), (0, import_jsx_runtime45.jsx)(Text, { size: "xs", children: "Pay with confidence using crypto" })] })] })] }) });
}
function SwapScreenContent(props) {
  var _a, _b, _c, _d, _e;
  const { setDrawerScreen, setScreen, account, client, toChain, tokenAmount, toToken, fromChain, fromToken, showFromTokenSelector, payOptions } = props;
  const fromTokenBalanceQuery = useWalletBalance({
    address: account.address,
    chain: fromChain,
    tokenAddress: isNativeToken(fromToken) ? void 0 : fromToken.address,
    client
  });
  const quoteParams = tokenAmount && !(fromChain.id === toChain.id && fromToken === toToken) ? {
    // wallet
    fromAddress: account.address,
    // from
    fromChainId: fromChain.id,
    fromTokenAddress: isNativeToken(fromToken) ? NATIVE_TOKEN_ADDRESS : fromToken.address,
    // to
    toChainId: toChain.id,
    toTokenAddress: isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address,
    toAmount: tokenAmount,
    client,
    purchaseData: payOptions.purchaseData
  } : void 0;
  const quoteQuery = useBuyWithCryptoQuote(quoteParams, {
    // refetch every 30 seconds
    staleTime: 30 * 1e3,
    refetchInterval: 30 * 1e3,
    gcTime: 30 * 1e3
  });
  const sourceTokenAmount = (_a = quoteQuery.data) == null ? void 0 : _a.swapDetails.fromAmount;
  const isNotEnoughBalance = !!sourceTokenAmount && !!fromTokenBalanceQuery.data && Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
  const disableContinue = !quoteQuery.data || isNotEnoughBalance;
  const switchChainRequired = props.activeChain.id !== fromChain.id;
  function getErrorMessage(err) {
    const defaultMessage = "Unable to get price quote";
    try {
      if (err instanceof Error) {
        if (err.message.includes("Minimum")) {
          const msg = err.message;
          return msg.replace("Fetch failed: Error: ", "");
        }
      }
      return defaultMessage;
    } catch {
      return defaultMessage;
    }
  }
  function showSwapFlow() {
    if (!quoteQuery.data) {
      return;
    }
    setScreen({
      id: "node",
      node: (0, import_jsx_runtime45.jsx)(SwapFlow, { isBuyForTx: !!props.buyForTx, isEmbed: props.isEmbed, client, onBack: () => {
        setScreen({
          id: "buy-with-crypto"
        });
      }, buyWithCryptoQuote: quoteQuery.data, account, onViewPendingTx: props.onViewPendingTx, isFiatFlow: false, onDone: props.onDone, onTryAgain: () => {
        setScreen({
          id: "buy-with-crypto"
        });
        quoteQuery.refetch();
      } })
    });
  }
  function showFees() {
    if (!quoteQuery.data) {
      return;
    }
    setDrawerScreen((0, import_jsx_runtime45.jsxs)("div", { children: [(0, import_jsx_runtime45.jsx)(Text, { size: "lg", color: "primaryText", children: "Fees" }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime45.jsx)(SwapFees, { quote: quoteQuery.data, align: "left" })] }));
  }
  const prefillSource = payOptions.buyWithCrypto !== false ? (_b = payOptions.buyWithCrypto) == null ? void 0 : _b.prefillSource : void 0;
  return (0, import_jsx_runtime45.jsxs)(Container, { flex: "column", gap: "md", animate: "fadein", children: [(0, import_jsx_runtime45.jsxs)("div", { children: [(0, import_jsx_runtime45.jsx)(PayWithCrypto, { value: sourceTokenAmount || "", onSelectToken: showFromTokenSelector, chain: fromChain, token: fromToken, isLoading: quoteQuery.isLoading && !sourceTokenAmount, client, freezeChainAndTokenSelection: ((_c = prefillSource == null ? void 0 : prefillSource.allowEdits) == null ? void 0 : _c.chain) === false && ((_d = prefillSource == null ? void 0 : prefillSource.allowEdits) == null ? void 0 : _d.token) === false }), (0, import_jsx_runtime45.jsx)(EstimatedTimeAndFees, { quoteIsLoading: quoteQuery.isLoading, estimatedSeconds: (_e = quoteQuery.data) == null ? void 0 : _e.swapDetails.estimated.durationSeconds, onViewFees: showFees })] }), quoteQuery.error && (0, import_jsx_runtime45.jsx)(Text, { color: "danger", size: "sm", center: true, children: getErrorMessage(quoteQuery.error) }), switchChainRequired && !quoteQuery.isLoading && !isNotEnoughBalance && !quoteQuery.error ? (0, import_jsx_runtime45.jsx)(SwitchNetworkButton, { variant: "accent", fullWidth: true, chain: fromChain }) : (0, import_jsx_runtime45.jsx)(Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
    if (!disableContinue) {
      showSwapFlow();
    }
  }, gap: "xs", children: isNotEnoughBalance ? (0, import_jsx_runtime45.jsx)(Text, { color: "danger", children: "Not Enough Funds" }) : quoteQuery.isLoading ? (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: ["Getting price quote", (0, import_jsx_runtime45.jsx)(Spinner, { size: "sm", color: "accentText" })] }) : "Continue" })] });
}
function FiatScreenContent(props) {
  var _a, _b;
  const { toToken, tokenAmount, account, client, setScreen, setDrawerScreen, toChain, showCurrencySelector, selectedCurrency } = props;
  const buyWithFiatOptions = props.payOptions.buyWithFiat;
  const fiatQuoteQuery = useBuyWithFiatQuote(buyWithFiatOptions !== false && tokenAmount ? {
    fromCurrencySymbol: selectedCurrency.shorthand,
    toChainId: toChain.id,
    toAddress: account.address,
    toTokenAddress: isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address,
    toAmount: tokenAmount,
    client,
    isTestMode: buyWithFiatOptions == null ? void 0 : buyWithFiatOptions.testMode,
    purchaseData: props.payOptions.purchaseData,
    fromAddress: account.address
  } : void 0);
  function handleSubmit() {
    if (!fiatQuoteQuery.data) {
      return;
    }
    const hasTwoSteps = isSwapRequiredPostOnramp(fiatQuoteQuery.data);
    let openedWindow = null;
    if (!hasTwoSteps) {
      openedWindow = openOnrampPopup(fiatQuoteQuery.data.onRampLink, typeof props.theme === "string" ? props.theme : props.theme.type);
      addPendingTx({
        type: "fiat",
        intentId: fiatQuoteQuery.data.intentId
      });
    }
    setScreen({
      id: "node",
      node: (0, import_jsx_runtime45.jsx)(FiatFlow, { isBuyForTx: !!props.buyForTx, quote: fiatQuoteQuery.data, onBack: () => {
        setScreen({
          id: "buy-with-fiat"
        });
      }, client, testMode: buyWithFiatOptions !== false ? (buyWithFiatOptions == null ? void 0 : buyWithFiatOptions.testMode) || false : false, theme: typeof props.theme === "string" ? props.theme : props.theme.type, onViewPendingTx: props.onViewPendingTx, openedWindow, onDone: props.onDone, isEmbed: props.isEmbed })
    });
  }
  function showFees() {
    if (!fiatQuoteQuery.data) {
      return;
    }
    setDrawerScreen((0, import_jsx_runtime45.jsxs)("div", { children: [(0, import_jsx_runtime45.jsx)(Text, { size: "lg", color: "primaryText", children: "Fees" }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "lg" }), (0, import_jsx_runtime45.jsx)(FiatFees, { quote: fiatQuoteQuery.data })] }));
  }
  function getErrorMessage(err) {
    const defaultMessage = "Unable to get price quote";
    try {
      if (err.error.code === "MINIMUM_PURCHASE_AMOUNT") {
        const obj = err.error;
        return [
          `Minimum purchase amount is $${obj.data.minimumAmountUSDCents / 100}`,
          `Requested amount is $${obj.data.requestedAmountUSDCents / 100}`
        ];
      }
    } catch {
    }
    return [defaultMessage];
  }
  const disableSubmit = !fiatQuoteQuery.data;
  return (0, import_jsx_runtime45.jsxs)(Container, { flex: "column", gap: "md", animate: "fadein", children: [(0, import_jsx_runtime45.jsxs)("div", { children: [(0, import_jsx_runtime45.jsx)(PayWithCreditCard, { isLoading: fiatQuoteQuery.isLoading, value: (_a = fiatQuoteQuery.data) == null ? void 0 : _a.fromCurrencyWithFees.amount, client, currency: selectedCurrency, onSelectCurrency: showCurrencySelector }), (0, import_jsx_runtime45.jsx)(EstimatedTimeAndFees, { quoteIsLoading: fiatQuoteQuery.isLoading, estimatedSeconds: (_b = fiatQuoteQuery.data) == null ? void 0 : _b.estimatedDurationSeconds, onViewFees: showFees })] }), fiatQuoteQuery.error && (0, import_jsx_runtime45.jsx)("div", { children: getErrorMessage(fiatQuoteQuery.error).map((msg) => (0, import_jsx_runtime45.jsx)(Text, { color: "danger", size: "sm", center: true, multiline: true, children: msg }, msg)) }), (0, import_jsx_runtime45.jsx)(Button, { variant: disableSubmit ? "outline" : "accent", "data-disabled": disableSubmit, disabled: disableSubmit, fullWidth: true, onClick: handleSubmit, gap: "xs", children: fiatQuoteQuery.isLoading ? (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: ["Getting price quote", (0, import_jsx_runtime45.jsx)(Spinner, { size: "sm", color: "accentText" })] }) : "Continue" })] });
}
function BuyForTxUI(props) {
  const chainQuery = useChainQuery(props.buyForTx.tx.chain);
  return (0, import_jsx_runtime45.jsxs)(Container, { children: [(0, import_jsx_runtime45.jsx)(Spacer, { y: "xs" }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "row", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime45.jsx)(Text, { size: "sm", children: "Amount Needed" }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "column", style: {
    alignItems: "flex-end"
  }, children: [(0, import_jsx_runtime45.jsxs)(Container, { flex: "row", gap: "xs", center: "y", children: [(0, import_jsx_runtime45.jsxs)(Text, { color: "primaryText", size: "sm", children: [props.amountNeeded, " ", props.buyForTx.tokenSymbol] }), (0, import_jsx_runtime45.jsx)(TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: NATIVE_TOKEN })] }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "xxs" }), chainQuery.data ? (0, import_jsx_runtime45.jsxs)(Text, { size: "sm", children: [" ", chainQuery.data.name] }) : (0, import_jsx_runtime45.jsx)(Skeleton, { height: fontSize.sm, width: "50px" })] })] }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime45.jsx)(Line, {}), (0, import_jsx_runtime45.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "row", style: {
    justifyContent: "space-between"
  }, children: [(0, import_jsx_runtime45.jsx)(Text, { size: "sm", children: "Your Balance" }), (0, import_jsx_runtime45.jsxs)(Container, { flex: "row", gap: "xs", children: [(0, import_jsx_runtime45.jsxs)(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(toEther(props.buyForTx.balance)), 4), " ", props.buyForTx.tokenSymbol] }), (0, import_jsx_runtime45.jsx)(TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: NATIVE_TOKEN })] })] }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "md" }), (0, import_jsx_runtime45.jsx)(Line, {}), (0, import_jsx_runtime45.jsx)(Spacer, { y: "xl" }), (0, import_jsx_runtime45.jsx)(Text, { center: true, size: "sm", children: "Purchase" }), (0, import_jsx_runtime45.jsx)(Spacer, { y: "xxs" })] });
}
function createSupportedTokens(data, payOptions, supportedTokensOverrides) {
  const tokens = {};
  const isBuyWithFiatDisabled = payOptions.buyWithFiat === false;
  const isBuyWithCryptoDisabled = payOptions.buyWithCrypto === false;
  for (const x of data) {
    tokens[x.chain.id] = x.tokens.filter((t) => {
      if (t.buyWithCryptoEnabled && t.buyWithFiatEnabled) {
        return true;
      }
      if (!t.buyWithCryptoEnabled && isBuyWithFiatDisabled) {
        return false;
      }
      if (!t.buyWithFiatEnabled && isBuyWithCryptoDisabled) {
        return false;
      }
      return true;
    });
  }
  if (supportedTokensOverrides) {
    for (const k in supportedTokensOverrides) {
      const key = Number(k);
      const tokenList = supportedTokensOverrides[key];
      if (tokenList) {
        tokens[key] = tokenList;
      }
    }
  }
  return tokens;
}
function ChainSelectionScreen(props) {
  return (0, import_jsx_runtime45.jsx)(NetworkSelectorContent, { client: props.client, connectLocale: props.connectLocale, showTabs: false, onBack: props.goBack, chains: props.chains, closeModal: props.goBack, networkSelector: {
    renderChain(renderChainProps) {
      return (0, import_jsx_runtime45.jsx)(ChainButton, { chain: renderChainProps.chain, confirming: false, switchingFailed: false, onClick: () => {
        props.setChain(renderChainProps.chain);
        props.goBack();
      }, client: props.client, connectLocale: props.connectLocale });
    }
  } });
}

export {
  composeEventHandlers,
  useComposedRefs,
  createContextScope,
  useLayoutEffect2,
  useId,
  useCallbackRef,
  useControllableState,
  Slottable,
  Primitive,
  DismissableLayer,
  Portal,
  Presence,
  DynamicHeight,
  Modal,
  useChainQuery,
  useChainsQuery,
  useActiveWalletChain,
  useSwitchActiveWalletChain,
  ChainIcon,
  NetworkSelectorContent,
  CoinsIcon,
  GenericWalletIcon,
  formatNumber,
  once,
  getPayBuyWithFiatHistoryEndpoint,
  getPayBuyWithCryptoHistoryEndpoint,
  getPayBuyHistoryEndpoint,
  useBuyWithCryptoQuote,
  useBuyWithFiatQuote,
  ChainName,
  NATIVE_TOKEN,
  isNativeToken,
  TokenIcon,
  formatTokenBalance,
  TokenSelector,
  PayTokenIcon,
  pendingTransactions,
  getBuyWithFiatStatus,
  useBuyWithFiatStatus,
  invalidateWalletBalance,
  getBuyWithCryptoStatusMeta,
  getBuyWithFiatStatusMeta,
  OnRampTxDetailsTable,
  getPostOnRampQuote,
  estimateGasCost,
  useSendTransactionCore,
  getBuyWithCryptoStatus,
  useBuyWithCryptoStatus,
  SwapDetailsScreen,
  PostOnRampSwapFlow,
  wait,
  BuyScreen
};
//# sourceMappingURL=chunk-O5K3KCWK.js.map
