{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/base64/base64.ts", "../../thirdweb/src/utils/nft/fetchTokenMetadata.ts", "../../thirdweb/src/utils/nft/parseNft.ts"],
  "sourcesContent": ["import { base64ToString } from \"../uint8-array.js\";\n\ntype Base64Prefix = \"data:application/json;base64\";\ntype Base64String = `${Base64Prefix},${string}`;\n\n/**\n * Checks if a given string is a base64 encoded JSON string.\n * @param input - The string to be checked.\n * @returns True if the input string starts with \"data:application/json;base64\", false otherwise.\n * @example\n * ```ts\n * isBase64JSON(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // true\n * ```\n */\nexport function isBase64JSON(input: string): input is Base64String {\n  if (input.startsWith(\"data:application/json;base64\")) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Parses a base64 string and returns the decoded string.\n * @param input - The base64 string to parse.\n * @returns The decoded string.\n * @example\n * ```ts\n * parseBase64String(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // '{\"test\":\"base64\"}'\n * ```\n */\nexport function parseBase64String(input: Base64String) {\n  const [, base64] = input.split(\",\") as [Base64Prefix, string];\n  return base64ToString(base64);\n}\n", "import type { ThirdwebClient } from \"../../client/client.js\";\nimport { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\nimport type { NFTMetadata } from \"./parseNft.js\";\n\n/**\n * @internal\n */\nexport type FetchTokenMetadataOptions = {\n  client: ThirdwebClient;\n  tokenId: bigint;\n  tokenUri: string;\n};\n\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(\n  options: FetchTokenMetadataOptions,\n): Promise<NFTMetadata> {\n  const { client, tokenId, tokenUri } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\n        \"Failed to fetch base64 encoded NFT\",\n        { tokenId, tokenUri },\n        e,\n      );\n      throw e;\n    }\n  }\n\n  // in all other cases we will need the `download` function from storage\n  const { download } = await import(\"../../storage/download.js\");\n\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({ client, uri: tokenUri })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\n            \"{id}\",\n            numberToHex(tokenId, { size: 32 }).slice(2),\n          ),\n        })\n      ).json();\n    } catch (err) {\n      // otherwise attempt the second format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\"{id}\", tokenId.toString()),\n        })\n      ).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n}\n", "import type { FileOrBufferOrString } from \"../../storage/upload/types.js\";\nimport type { Prettify } from \"../type-utils.js\";\n\n/**\n * Represents the input data for creating an NFT (Non-Fungible Token).\n */\nexport type NFTInput = Prettify<\n  {\n    name?: string;\n    description?: string;\n    image?: FileOrBufferOrString;\n    animation_url?: FileOrBufferOrString;\n    external_url?: FileOrBufferOrString;\n    background_color?: string;\n    // TODO check if we truly need both of these?\n    properties?: Record<string, unknown> | Array<Record<string, unknown>>;\n  } & Record<string, unknown>\n>;\n\nexport type NFTMetadata = {\n  id: bigint;\n  uri: string;\n  name?: string;\n  description?: string;\n  image?: string;\n  animation_url?: string;\n  external_url?: string;\n  background_color?: string;\n  properties?: Record<string, unknown>;\n  attributes?: Record<string, unknown>;\n} & Record<string, unknown>;\n\nexport type NFT =\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC721\";\n    }\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC1155\";\n      supply: bigint;\n    };\n\n/**\n * @internal\n */\nexport type ParseNFTOptions =\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC721\";\n      owner?: string | null;\n    }\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC1155\";\n      owner?: string | null;\n      supply: bigint;\n    };\n\n/**\n * Parses the NFT metadata and options to create an NFT object.\n * @param base - The base NFT metadata.\n * @param options - The options for parsing the NFT.\n * @returns The parsed NFT object.\n * @internal\n */\nexport function parseNFT(base: NFTMetadata, options: ParseNFTOptions): NFT {\n  switch (options.type) {\n    case \"ERC721\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n      };\n    case \"ERC1155\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n        supply: options.supply,\n      };\n    default:\n      throw new Error(\"Invalid NFT type\");\n  }\n}\n"],
  "mappings": ";;;;;;;;AAeM,SAAU,aAAa,OAAa;AACxC,MAAI,MAAM,WAAW,8BAA8B,GAAG;AACpD,WAAO;EACT;AACA,SAAO;AACT;AAYM,SAAU,kBAAkB,OAAmB;AACnD,QAAM,CAAC,EAAE,MAAM,IAAI,MAAM,MAAM,GAAG;AAClC,SAAO,eAAe,MAAM;AAC9B;;;ACdA,eAAsB,mBACpB,SAAkC;AAElC,QAAM,EAAE,QAAQ,SAAS,SAAQ,IAAK;AAEtC,MAAI,aAAa,QAAQ,GAAG;AAC1B,QAAI;AACF,aAAO,KAAK,MAAM,kBAAkB,QAAQ,CAAC;IAC/C,SAAS,GAAG;AACV,cAAQ,MACN,sCACA,EAAE,SAAS,SAAQ,GACnB,CAAC;AAEH,YAAM;IACR;EACF;AAGA,QAAM,EAAE,SAAQ,IAAK,MAAM,OAAO,wBAA2B;AAG7D,MAAI;AACF,QAAI,CAAC,SAAS,SAAS,MAAM,GAAG;AAC9B,aAAO,OAAO,MAAM,SAAS,EAAE,QAAQ,KAAK,SAAQ,CAAE,GAAG,KAAI;IAC/D;EACF,SAAS,GAAG;AACV,YAAQ,MAAM,mCAAmC,EAAE,SAAS,SAAQ,GAAI,CAAC;AACzE,UAAM;EACR;AAGA,MAAI;AACF,QAAI;AAEF,aAAO,OACL,MAAM,SAAS;QACb;QACA,KAAK,SAAS,QACZ,QACA,YAAY,SAAS,EAAE,MAAM,GAAE,CAAE,EAAE,MAAM,CAAC,CAAC;OAE9C,GACD,KAAI;IACR,SAAS,KAAK;AAEZ,aAAO,OACL,MAAM,SAAS;QACb;QACA,KAAK,SAAS,QAAQ,QAAQ,QAAQ,SAAQ,CAAE;OACjD,GACD,KAAI;IACR;EACF,SAAS,GAAG;AACV,YAAQ,MAAM,+BAA+B,EAAE,SAAS,SAAQ,GAAI,CAAC;AACrE,UAAM;EACR;AACF;;;ACJM,SAAU,SAAS,MAAmB,SAAwB;AAClE,UAAQ,QAAQ,MAAM;IACpB,KAAK;AACH,aAAO;QACL,UAAU;QACV,QAAO,mCAAS,UAAS;QACzB,IAAI,QAAQ;QACZ,UAAU,QAAQ;QAClB,MAAM,QAAQ;;IAElB,KAAK;AACH,aAAO;QACL,UAAU;QACV,QAAO,mCAAS,UAAS;QACzB,IAAI,QAAQ;QACZ,UAAU,QAAQ;QAClB,MAAM,QAAQ;QACd,QAAQ,QAAQ;;IAEpB;AACE,YAAM,IAAI,MAAM,kBAAkB;EACtC;AACF;",
  "names": []
}
