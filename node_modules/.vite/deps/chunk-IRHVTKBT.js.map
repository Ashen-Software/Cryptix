{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/ens/avatar.ts", "../../thirdweb/src/utils/ens/encodeLabelToLabelhash.ts", "../../thirdweb/src/utils/ens/namehash.ts", "../../thirdweb/src/utils/ens/encodeLabelhash.ts", "../../thirdweb/src/utils/ens/packetToBytes.ts", "../../thirdweb/src/extensions/ens/__generated__/AddressResolver/read/text.ts", "../../thirdweb/src/extensions/ens/__generated__/UniversalResolver/read/resolve.ts", "../../thirdweb/src/extensions/ens/constants.ts", "../../thirdweb/src/extensions/ens/resolve-text.ts", "../../thirdweb/src/extensions/ens/resolve-avatar.ts", "../../thirdweb/src/extensions/ens/__generated__/UniversalResolver/read/reverse.ts", "../../thirdweb/src/extensions/ens/resolve-name.ts", "../../thirdweb/src/react/core/utils/addresses.ts", "../../thirdweb/src/react/core/utils/wallet.ts", "../../thirdweb/src/react/web/ui/components/WalletImage.tsx"],
  "sourcesContent": ["import { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { isAddress } from \"../address.js\";\nimport { getClientFetch } from \"../fetch.js\";\nimport { resolveScheme } from \"../ipfs.js\";\n\ntype AvatarOptions = {\n  client: ThirdwebClient;\n  uri: string;\n};\n\n/**\n * @internal\n */\nexport async function parseAvatarRecord(\n  options: AvatarOptions,\n): Promise<string | null> {\n  let uri: string | null = options.uri;\n  if (/eip155:/i.test(options.uri)) {\n    // do nft uri parsing\n    uri = await parseNftUri(options);\n  }\n  if (!uri) {\n    return null;\n  }\n  const resolvedScheme = resolveScheme({\n    client: options.client,\n    uri,\n  });\n\n  // check if it's an image\n  if (await isImageUri({ client: options.client, uri: resolvedScheme })) {\n    return resolvedScheme;\n  }\n  return null;\n}\n\n/**\n * @internal\n */\nasync function parseNftUri(options: AvatarOptions): Promise<string | null> {\n  let uri = options.uri;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith(\"did:nft:\")) {\n    // convert DID to CAIP\n    uri = uri.replace(\"did:nft:\", \"\").replace(/_/g, \"/\");\n  }\n\n  const [reference = \"\", asset_namespace = \"\", tokenID = \"\"] = uri.split(\"/\");\n  const [eip_namespace, chainID] = reference.split(\":\");\n  const [erc_namespace, contractAddress] = asset_namespace.split(\":\");\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== \"eip155\") {\n    throw new Error(\n      `Invalid EIP namespace, expected EIP155, got: \"${eip_namespace}\"`,\n    );\n  }\n  if (!chainID) {\n    throw new Error(\"Chain ID not found\");\n  }\n  if (!contractAddress || !isAddress(contractAddress)) {\n    throw new Error(\"Contract address not found\");\n  }\n  if (!tokenID) {\n    throw new Error(\"Token ID not found\");\n  }\n  const chain = getCachedChain(Number(chainID));\n  const contract = getContract({\n    client: options.client,\n    chain,\n    address: contractAddress,\n  });\n  switch (erc_namespace) {\n    case \"erc721\": {\n      const { getNFT } = await import(\"../../extensions/erc721/read/getNFT.js\");\n      const nft = await getNFT({\n        contract,\n        tokenId: BigInt(tokenID),\n      });\n      return nft.metadata.image ?? null;\n    }\n    case \"erc1155\": {\n      const { getNFT } = await import(\n        \"../../extensions/erc1155/read/getNFT.js\"\n      );\n      const nft = await getNFT({\n        contract,\n        tokenId: BigInt(tokenID),\n      });\n      return nft.metadata.image ?? null;\n    }\n\n    default: {\n      throw new Error(\n        `Invalid ERC namespace, expected ERC721 or ERC1155, got: \"${erc_namespace}\"`,\n      );\n    }\n  }\n}\n\nasync function isImageUri(options: AvatarOptions): Promise<boolean> {\n  try {\n    const res = await getClientFetch(options.client)(options.uri, {\n      method: \"HEAD\",\n    });\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get(\"content-type\");\n      return !!contentType?.startsWith(\"image/\");\n    }\n    return false;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === \"object\" && typeof error.response !== \"undefined\") {\n      return false;\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (Object.hasOwn(globalThis, \"Image\")) {\n      return false;\n    }\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(true);\n      };\n      img.onerror = () => {\n        resolve(false);\n      };\n      img.src = options.uri;\n    });\n  }\n}\n", "import { type Hex, isHex } from \"../encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function encodedLabelToLabelhash(label: string): Hex | null {\n  if (label.length !== 66) {\n    return null;\n  }\n  if (label.indexOf(\"[\") !== 0) {\n    return null;\n  }\n  if (label.indexOf(\"]\") !== 65) {\n    return null;\n  }\n  const hash = `0x${label.slice(1, 65)}`;\n  if (!isHex(hash)) {\n    return null;\n  }\n  return hash;\n}\n", "import { bytesToHex, concat } from \"viem/utils\";\nimport { stringToBytes, toBytes } from \"../encoding/to-bytes.js\";\nimport { keccak256 } from \"../hashing/keccak256.js\";\nimport { encodedLabelToLabelhash } from \"./encodeLabelToLabelhash.js\";\n\n/**\n * @internal\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0);\n  if (!name) {\n    return bytesToHex(result);\n  }\n\n  const labels = name.split(\".\");\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const item = labels[i] as string;\n    const hashFromEncodedLabel = encodedLabelToLabelhash(item);\n    const hashed = hashFromEncodedLabel\n      ? toBytes(hashFromEncodedLabel)\n      : keccak256(stringToBytes(item), \"bytes\");\n    result = keccak256(concat([result, hashed]), \"bytes\");\n  }\n\n  return bytesToHex(result);\n}\n", "import type { Hex } from \"../encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function encodeLabelhash(hash: Hex): `[${string}]` {\n  return `[${hash.slice(2)}]`;\n}\n", "import { type ByteArray, labelhash } from \"viem\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { encodeLabelhash } from \"./encodeLabelhash.js\";\n\n/**\n * Encodes a DNS packet into a ByteArray containing a UDP payload.\n * @param packet\n * @internal\n */\nexport function packetToBytes(packet: string): ByteArray {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, \"\");\n  if (value.length === 0) {\n    return new Uint8Array(1);\n  }\n\n  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);\n\n  let offset = 0;\n  const list = value.split(\".\");\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i] as string;\n    let encoded = stringToBytes(item);\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255) {\n      encoded = stringToBytes(encodeLabelhash(labelhash(item)));\n    }\n    bytes[offset] = encoded.length;\n    bytes.set(encoded, offset + 1);\n    offset += encoded.length + 1;\n  }\n\n  if (bytes.byteLength !== offset + 1) {\n    return bytes.slice(0, offset + 1);\n  }\n\n  return bytes;\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"text\" function.\n */\nexport type TextParams = {\n  name: AbiParameterToPrimitiveType<{ type: \"bytes32\"; name: \"name\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"string\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x59d1d43c\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes32\",\n    name: \"name\",\n  },\n  {\n    type: \"string\",\n    name: \"key\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `text` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `text` method is supported.\n * @extension ENS\n * @example\n * ```ts\n * import { isTextSupported } from \"thirdweb/extensions/ens\";\n *\n * const supported = await isTextSupported(contract);\n * ```\n */\nexport async function isTextSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"text\" function.\n * @param options - The options for the text function.\n * @returns The encoded ABI parameters.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeTextParams } \"thirdweb/extensions/ens\";\n * const result = encodeTextParams({\n *  name: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeTextParams(options: TextParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.name, options.key]);\n}\n\n/**\n * Encodes the \"text\" function into a Hex string with its parameters.\n * @param options - The options for the text function.\n * @returns The encoded hexadecimal string.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeText } \"thirdweb/extensions/ens\";\n * const result = encodeText({\n *  name: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeText(options: TextParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeTextParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the text function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ENS\n * @example\n * ```ts\n * import { decodeTextResult } from \"thirdweb/extensions/ens\";\n * const result = decodeTextResult(\"...\");\n * ```\n */\nexport function decodeTextResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"text\" function on the contract.\n * @param options - The options for the text function.\n * @returns The parsed result of the function call.\n * @extension ENS\n * @example\n * ```ts\n * import { text } from \"thirdweb/extensions/ens\";\n *\n * const result = await text({\n *  contract,\n *  name: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function text(options: BaseTransactionOptions<TextParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.name, options.key],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"resolve\" function.\n */\nexport type ResolveParams = {\n  name: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"name\" }>;\n  data: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"data\" }>;\n};\n\nexport const FN_SELECTOR = \"0x9061b923\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes\",\n    name: \"name\",\n  },\n  {\n    type: \"bytes\",\n    name: \"data\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes\",\n  },\n  {\n    type: \"address\",\n  },\n] as const;\n\n/**\n * Checks if the `resolve` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `resolve` method is supported.\n * @extension ENS\n * @example\n * ```ts\n * import { isResolveSupported } from \"thirdweb/extensions/ens\";\n *\n * const supported = await isResolveSupported(contract);\n * ```\n */\nexport async function isResolveSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"resolve\" function.\n * @param options - The options for the resolve function.\n * @returns The encoded ABI parameters.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeResolveParams } \"thirdweb/extensions/ens\";\n * const result = encodeResolveParams({\n *  name: ...,\n *  data: ...,\n * });\n * ```\n */\nexport function encodeResolveParams(options: ResolveParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.name, options.data]);\n}\n\n/**\n * Encodes the \"resolve\" function into a Hex string with its parameters.\n * @param options - The options for the resolve function.\n * @returns The encoded hexadecimal string.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeResolve } \"thirdweb/extensions/ens\";\n * const result = encodeResolve({\n *  name: ...,\n *  data: ...,\n * });\n * ```\n */\nexport function encodeResolve(options: ResolveParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeResolveParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the resolve function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ENS\n * @example\n * ```ts\n * import { decodeResolveResult } from \"thirdweb/extensions/ens\";\n * const result = decodeResolveResult(\"...\");\n * ```\n */\nexport function decodeResolveResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"resolve\" function on the contract.\n * @param options - The options for the resolve function.\n * @returns The parsed result of the function call.\n * @extension ENS\n * @example\n * ```ts\n * import { resolve } from \"thirdweb/extensions/ens\";\n *\n * const result = await resolve({\n *  contract,\n *  name: ...,\n *  data: ...,\n * });\n *\n * ```\n */\nexport async function resolve(options: BaseTransactionOptions<ResolveParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.name, options.data],\n  });\n}\n", "export const UNIVERSAL_RESOLVER_ADDRESS =\n  \"0xce01f8eee7E479C928F8919abD53E553a36CeF67\";\n", "import { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { namehash } from \"../../utils/ens/namehash.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport {\n  decodeTextResult,\n  encodeText,\n} from \"./__generated__/AddressResolver/read/text.js\";\nimport { resolve } from \"./__generated__/UniversalResolver/read/resolve.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n\nexport type ResolveTextOptions = {\n  client: ThirdwebClient;\n  name: string;\n  key: string;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves an ENS name and key to the specified record.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveText } from \"thirdweb/extensions/ens\";\n * const twitterUsername = await resolveText({\n *    client,\n *    name: \"vitalik.eth\",\n *    key: \"com.twitter\"\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the text record.\n */\nexport async function resolveText(options: ResolveTextOptions) {\n  const { client, name, key, resolverAddress, resolverChain } = options;\n  return withCache(\n    async () => {\n      const contract = getContract({\n        client,\n        chain: resolverChain || ethereum,\n        address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n      });\n\n      const data = encodeText({ name: namehash(name), key });\n\n      const result = await resolve({\n        contract,\n        name: toHex(packetToBytes(name)),\n        data,\n      });\n\n      if (result[0] === \"0x\") {\n        return null;\n      }\n\n      const record = decodeTextResult(result[0]);\n\n      return record === \"\" ? null : record;\n    },\n    {\n      cacheKey: `ens:text:${name}:${key}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n", "import type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { parseAvatarRecord } from \"../../utils/ens/avatar.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { resolveText } from \"./resolve-text.js\";\n\nexport type ResolveAvatarOptions = {\n  client: ThirdwebClient;\n  name: string;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves an ENS name to the avatar URL.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveAvatar } from \"thirdweb/extensions/ens\";\n * const address = await resolveAvatar({\n *    client,\n *    name: \"vitalik.eth\",\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the avatar url, or null if not set.\n */\nexport async function resolveAvatar(options: ResolveAvatarOptions) {\n  const { client, name, resolverAddress, resolverChain } = options;\n  return withCache(\n    async () => {\n      const record = await resolveText({\n        client,\n        key: \"avatar\",\n        name,\n        resolverAddress,\n        resolverChain,\n      });\n\n      if (!record) {\n        return null;\n      }\n      try {\n        return parseAvatarRecord({ uri: record, client });\n      } catch (e) {\n        console.error(\"Error parsing avatar record\", e);\n        return null;\n      }\n    },\n    {\n      cacheKey: `ens:avatar:${name}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"reverse\" function.\n */\nexport type ReverseParams = {\n  reverseName: AbiParameterToPrimitiveType<{\n    type: \"bytes\";\n    name: \"reverseName\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xec11c823\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes\",\n    name: \"reverseName\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n  {\n    type: \"address\",\n  },\n  {\n    type: \"address\",\n  },\n  {\n    type: \"address\",\n  },\n] as const;\n\n/**\n * Checks if the `reverse` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `reverse` method is supported.\n * @extension ENS\n * @example\n * ```ts\n * import { isReverseSupported } from \"thirdweb/extensions/ens\";\n *\n * const supported = await isReverseSupported(contract);\n * ```\n */\nexport async function isReverseSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"reverse\" function.\n * @param options - The options for the reverse function.\n * @returns The encoded ABI parameters.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeReverseParams } \"thirdweb/extensions/ens\";\n * const result = encodeReverseParams({\n *  reverseName: ...,\n * });\n * ```\n */\nexport function encodeReverseParams(options: ReverseParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.reverseName]);\n}\n\n/**\n * Encodes the \"reverse\" function into a Hex string with its parameters.\n * @param options - The options for the reverse function.\n * @returns The encoded hexadecimal string.\n * @extension ENS\n * @example\n * ```ts\n * import { encodeReverse } \"thirdweb/extensions/ens\";\n * const result = encodeReverse({\n *  reverseName: ...,\n * });\n * ```\n */\nexport function encodeReverse(options: ReverseParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeReverseParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the reverse function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ENS\n * @example\n * ```ts\n * import { decodeReverseResult } from \"thirdweb/extensions/ens\";\n * const result = decodeReverseResult(\"...\");\n * ```\n */\nexport function decodeReverseResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"reverse\" function on the contract.\n * @param options - The options for the reverse function.\n * @returns The parsed result of the function call.\n * @extension ENS\n * @example\n * ```ts\n * import { reverse } from \"thirdweb/extensions/ens\";\n *\n * const result = await reverse({\n *  contract,\n *  reverseName: ...,\n * });\n *\n * ```\n */\nexport async function reverse(options: BaseTransactionOptions<ReverseParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.reverseName],\n  });\n}\n", "import type { Address } from \"abitype\";\nimport { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { reverse } from \"./__generated__/UniversalResolver/read/reverse.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n\nexport type ResolveNameOptions = {\n  client: ThirdwebClient;\n  address: Address;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves the primary name for a specified address.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveName } from \"thirdweb/extensions/ens\";\n * const name = await resolveName({\n *    client,\n *    address: \"0x1234...\",\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the Ethereum address.\n */\nexport async function resolveName(options: ResolveNameOptions) {\n  const { client, address, resolverAddress, resolverChain } = options;\n\n  return withCache(\n    async () => {\n      const contract = getContract({\n        client,\n        chain: resolverChain || ethereum,\n        address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n      });\n\n      const reverseName = toHex(\n        packetToBytes(`${address.toLowerCase().substring(2)}.addr.reverse`),\n      );\n\n      const [name, resolvedAddress] = await reverse({\n        contract,\n        reverseName,\n      }).catch((e) => {\n        if (\"data\" in e && e.data === \"0x7199966d\") {\n          return [null, address] as const;\n        }\n        throw e;\n      });\n\n      if (address.toLowerCase() !== resolvedAddress.toLowerCase()) {\n        return null;\n      }\n\n      return name;\n    },\n    {\n      cacheKey: `ens:name:${address}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n", "/**\n * @internal\n */\nexport function shortenString(str: string, extraShort = true) {\n  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(\n    str.length - (extraShort ? 3 : 4),\n  )}`;\n}\n", "import { useQuery } from \"@tanstack/react-query\";\nimport { ethereum } from \"../../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { resolveAvatar } from \"../../../extensions/ens/resolve-avatar.js\";\nimport { resolveName } from \"../../../extensions/ens/resolve-name.js\";\nimport { getWalletInfo } from \"../../../wallets/__generated__/getWalletInfo.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { WalletInfo } from \"../../../wallets/wallet-info.js\";\nimport type { WalletId } from \"../../../wallets/wallet-types.js\";\nimport { useWalletBalance } from \"../hooks/others/useWalletBalance.js\";\nimport { shortenString } from \"./addresses.js\";\n\n/**\n * @internal\n */\nexport function useConnectedWalletDetails(\n  client: ThirdwebClient,\n  walletChain: Chain | undefined,\n  activeAccount: Account | undefined,\n  displayBalanceToken?: Record<number, string>,\n) {\n  const tokenAddress =\n    walletChain && displayBalanceToken\n      ? displayBalanceToken[Number(walletChain.id)]\n      : undefined;\n\n  const ensNameQuery = useQuery({\n    queryKey: [\"ens-name\", activeAccount?.address],\n    enabled: !!activeAccount?.address,\n    queryFn: () =>\n      resolveName({\n        client,\n        address: activeAccount?.address || \"\",\n        resolverChain: ethereum,\n      }),\n  });\n\n  const ensAvatarQuery = useQuery({\n    queryKey: [\"ens-avatar\", ensNameQuery.data],\n    enabled: !!ensNameQuery.data,\n    queryFn: async () =>\n      resolveAvatar({\n        client,\n        name: ensNameQuery.data || \"\",\n      }),\n  });\n\n  const shortAddress = activeAccount?.address\n    ? shortenString(activeAccount.address, false)\n    : \"\";\n\n  const balanceQuery = useWalletBalance({\n    chain: walletChain ? walletChain : undefined,\n    tokenAddress,\n    address: activeAccount?.address,\n    client,\n  });\n\n  const addressOrENS = ensNameQuery.data || shortAddress;\n\n  return {\n    ensNameQuery,\n    ensAvatarQuery,\n    addressOrENS,\n    shortAddress,\n    balanceQuery,\n  };\n}\n\n/**\n * Returns the wallet info for the provided wallet id.\n * @wallet\n */\nexport function useWalletInfo(id: WalletId) {\n  return useQuery<WalletInfo>({\n    queryKey: [\"wallet-info\", id],\n    queryFn: () => {\n      return getWalletInfo(id, false);\n    },\n    retry: false,\n    refetchOnWindowFocus: false,\n    refetchOnMount: false,\n  });\n}\n\n/**\n * Returns the wallet image for the provided wallet id.\n * @wallet\n */\nexport function useWalletImage(id: WalletId) {\n  return useQuery({\n    queryKey: [\"wallet-image\", id],\n    queryFn: () => {\n      return getWalletInfo(id, true);\n    },\n    retry: false,\n    refetchOnWindowFocus: false,\n    refetchOnMount: false,\n  });\n}\n", "\"use client\";\nimport { useEffect, useState } from \"react\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport { getWalletInfo } from \"../../../../wallets/__generated__/getWalletInfo.js\";\nimport { getInstalledWalletProviders } from \"../../../../wallets/injected/mipdStore.js\";\nimport { getStoredActiveWalletId } from \"../../../../wallets/manager/index.js\";\nimport type { WalletId } from \"../../../../wallets/wallet-types.js\";\nimport { radius } from \"../../../core/design-system/index.js\";\nimport {\n  appleIconUri,\n  emailIcon,\n  facebookIconUri,\n  genericWalletIcon,\n  googleIconUri,\n  passkeyIcon,\n  phoneIcon,\n} from \"../../../core/utils/socialIcons.js\";\nimport { getLastAuthProvider } from \"../../../core/utils/storage.js\";\nimport { useWalletImage } from \"../../../core/utils/wallet.js\";\nimport { useActiveWallet } from \"../../hooks/wallets/useActiveWallet.js\";\nimport { Img } from \"./Img.js\";\n\n// Note: Must not use useConnectUI here\n\n/**\n * @internal\n */\nexport function WalletImage(props: {\n  id: WalletId;\n  size: string;\n  client: ThirdwebClient;\n}) {\n  const [image, setImage] = useState<string | undefined>(undefined);\n  const activeWallet = useActiveWallet();\n  useEffect(() => {\n    async function fetchImage() {\n      // show EOA icon for external wallets\n      // show auth provider icon for in-app wallets\n      // show the admin EOA icon for smart\n      const storage = webLocalStorage;\n      let activeEOAId = props.id;\n      if (props.id === \"smart\") {\n        const storedId = await getStoredActiveWalletId(storage);\n        if (storedId) {\n          activeEOAId = storedId;\n        }\n      }\n      let image: string | undefined;\n\n      if (\n        activeEOAId === \"inApp\" &&\n        activeWallet &&\n        (activeWallet.id === \"inApp\" || activeWallet.id === \"smart\")\n      ) {\n        // when showing an active wallet icon - check last auth provider and override the IAW icon\n        const lastAuthProvider = await getLastAuthProvider(storage);\n        switch (lastAuthProvider) {\n          case \"google\":\n            image = googleIconUri;\n            break;\n          case \"apple\":\n            image = appleIconUri;\n            break;\n          case \"facebook\":\n            image = facebookIconUri;\n            break;\n          case \"phone\":\n            image = phoneIcon;\n            break;\n          case \"email\":\n            image = emailIcon;\n            break;\n          case \"passkey\":\n            image = passkeyIcon;\n            break;\n        }\n      } else {\n        const mipdImage = getInstalledWalletProviders().find(\n          (x) => x.info.rdns === activeEOAId,\n        )?.info.icon;\n\n        if (mipdImage) {\n          image = mipdImage;\n        } else {\n          image = await getWalletInfo(activeEOAId, true);\n        }\n      }\n\n      setImage(image);\n    }\n    fetchImage();\n  }, [props.id, activeWallet]);\n\n  if (image) {\n    return (\n      <Img\n        src={image}\n        width={props.size}\n        height={props.size}\n        loading=\"eager\"\n        client={props.client}\n        style={{\n          borderRadius: radius.md,\n        }}\n      />\n    );\n  }\n\n  return (\n    <WalletImageQuery id={props.id} size={props.size} client={props.client} />\n  );\n}\n\nfunction WalletImageQuery(props: {\n  id: WalletId;\n  size: string;\n  client: ThirdwebClient;\n}) {\n  const walletImage = useWalletImage(props.id);\n\n  if (walletImage.isFetched && !walletImage.data) {\n    return (\n      <Img\n        client={props.client}\n        src={genericWalletIcon}\n        width={props.size}\n        height={props.size}\n      />\n    );\n  }\n\n  return (\n    <Img\n      client={props.client}\n      src={walletImage.isLoading ? undefined : walletImage.data}\n      fallbackImage={genericWalletIcon}\n      width={props.size}\n      height={props.size}\n      loading=\"eager\"\n      style={{\n        borderRadius: radius.md,\n      }}\n    />\n  );\n}\n"],
  "mappings": "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",
  "names": ["resolve", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "image", "_jsx"]
}
