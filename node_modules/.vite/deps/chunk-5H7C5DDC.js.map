{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/bigint.ts", "../../thirdweb/src/utils/encoding/helpers/concat-hex.ts", "../../thirdweb/src/transaction/actions/zksync/getEip721Domain.ts", "../../thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts", "../../thirdweb/src/event/actions/parse-logs.ts", "../../thirdweb/src/event/utils.ts", "../../thirdweb/src/event/prepare-event.ts", "../../thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts", "../../thirdweb/src/wallets/smart/lib/utils.ts", "../../thirdweb/src/wallets/smart/lib/bundler.ts", "../../thirdweb/src/wallets/smart/lib/calls.ts", "../../thirdweb/src/wallets/smart/lib/paymaster.ts", "../../thirdweb/src/wallets/smart/lib/userop.ts", "../../thirdweb/src/wallets/smart/index.ts"],
  "sourcesContent": ["import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n", "import type { Hex } from \"./is-hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace(\"0x\", \"\"),\n    \"\",\n  )}`;\n}\n", "import type { TransactionSerializable } from \"viem\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type {\n  EIP712SerializedTransaction,\n  EIP712TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP712TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP712SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    // TODO suport factoryDeps\n    factoryDeps: [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n", "import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\nexport type SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit);\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n", "import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    logs,\n    abi: events.map((e) => e.abiEvent),\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n", "import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n", "import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { type Hex, encodeEventTopics, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n", "import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n", "import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport { isHex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type { UserOperation, UserOperationHexed } from \"../types.js\";\n\nconst generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport const randomNonce = () => {\n  return BigInt(\n    concat([numberToHex(generateRandomUint192()), \"0x0000000000000000\"]),\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(userOp: UserOperation): UserOperationHexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationHexed;\n}\n\nexport function isNativeAAChain(chain: Chain) {\n  return chain.id === 324 || chain.id === 300 || chain.id === 302;\n}\n", "import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport type {\n  BundlerOptions,\n  EstimationResult,\n  GasPriceResult,\n  PmTransactionData,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * @internal\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: hexToBigInt(res.verificationGas),\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n  };\n}\n\n/**\n * @internal\n */\nexport async function getUserOpGasPrice(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * @internal\n */\nexport async function getUserOpReceipt(args: {\n  userOpHash: Hex;\n  options: BundlerOptions;\n}): Promise<TransactionReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(`UserOp failed at txHash: ${res.transactionHash}`);\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const bundlerUrl =\n    options.overrides?.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = JSON.stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n", "import type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\nimport type { SmartAccountOptions, SmartWalletOptions } from \"../types.ts\";\n\n/**\n * @internal\n */\nexport async function predictAddress(\n  factoryContract: ThirdwebContract,\n  options: SmartWalletOptions & { personalAccountAddress?: string },\n): Promise<string> {\n  if (options.overrides?.predictAddress) {\n    return options.overrides.predictAddress(factoryContract);\n  }\n  if (options.overrides?.accountAddress) {\n    return options.overrides.accountAddress;\n  }\n  const adminAddress = options.personalAccountAddress;\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const extraData = stringToHex(options.overrides?.accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, extraData],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n}): PreparedTransaction {\n  const { factoryContract, options } = args;\n  if (options.overrides?.createAccount) {\n    return options.overrides.createAccount(factoryContract);\n  }\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [\n      options.personalAccount.address,\n      stringToHex(options.overrides?.accountSalt ?? \"\"),\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  transaction: SendTransactionOption;\n}): PreparedTransaction {\n  const { accountContract, options, transaction } = args;\n  if (options.overrides?.execute) {\n    return options.overrides.execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  transactions: SendTransactionOption[];\n}): PreparedTransaction {\n  const { accountContract, options, transactions } = args;\n  if (options.overrides?.executeBatch) {\n    return options.overrides.executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n", "import { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport type {\n  PaymasterResult,\n  SmartAccountOptions,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultPaymasterUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * TODO Docs\n * @internal\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperation;\n  options: SmartAccountOptions;\n}): Promise<PaymasterResult> {\n  const { userOp, options } = args;\n\n  if (options.overrides?.paymaster) {\n    return options.overrides?.paymaster(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const client = options.client;\n  const paymasterUrl = getDefaultPaymasterUrl(options.chain);\n  const entrypoint =\n    options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n", "import { concat } from \"viem\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { SmartAccountOptions, UserOperation } from \"../types.js\";\nimport { estimateUserOpGas, getUserOpGasPrice } from \"./bundler.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { randomNonce } from \"./utils.js\";\n\n/**\n * Create an unsigned user operation\n * @internal\n */\n/**\n * Creates an unsigned user operation.\n * @internal\n */\nexport async function createUnsignedUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<UserOperation> {\n  const { executeTx, options } = args;\n  const isDeployed = await isContractDeployed(options.accountContract);\n  const initCode = isDeployed ? \"0x\" : await getAccountInitCode(options);\n  const callData = await encode(executeTx);\n\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n  const bundlerUrl =\n    options.overrides?.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasPrice({\n      options,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(\n        options.client,\n        options.chain,\n      );\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n\n  // const nonce = BigInt(transaction.nonce || randomNonce());\n  const nonce = randomNonce(); // FIXME getNonce should be overrideable by the wallet\n\n  const partialOp: UserOperation = {\n    sender: options.accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (options.sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      options,\n    });\n    const paymasterAndData = paymasterResult.paymasterAndData;\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          options,\n        });\n        if (\n          paymasterResult2.paymasterAndData &&\n          paymasterResult2.paymasterAndData !== \"0x\"\n        ) {\n          partialOp.paymasterAndData = paymasterResult2.paymasterAndData as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\",\n  };\n}\n\n/**\n * Sign the filled userOp.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @internal\n */\nexport async function signUserOp(args: {\n  userOp: UserOperation;\n  options: SmartAccountOptions;\n}): Promise<UserOperation> {\n  const { userOp, options } = args;\n  const userOpHash = getUserOpHash({\n    userOp,\n    entryPoint: options.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n    chainId: options.chain.id,\n  });\n  if (options.personalAccount.signMessage) {\n    const signature = await options.personalAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: SmartAccountOptions): Promise<Hex> {\n  const { factoryContract } = options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    options,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\n/**\n * @internal\n */\nfunction getUserOpHash(args: {\n  userOp: UserOperation;\n  entryPoint: string;\n  chainId: number;\n}): Hex {\n  const { userOp, entryPoint, chainId } = args;\n  const hashedInitCode = keccak256(userOp.initCode);\n  const hashedCallData = keccak256(userOp.callData);\n  const hashedPaymasterAndData = keccak256(userOp.paymasterAndData);\n\n  const packedUserOp = encodeAbiParameters(\n    [\n      { type: \"address\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n      { type: \"bytes32\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n    ],\n    [\n      userOp.sender,\n      userOp.nonce,\n      hashedInitCode,\n      hashedCallData,\n      userOp.callGasLimit,\n      userOp.verificationGasLimit,\n      userOp.preVerificationGas,\n      userOp.maxFeePerGas,\n      userOp.maxPriorityFeePerGas,\n      hashedPaymasterAndData,\n    ],\n  );\n  const encoded = encodeAbiParameters(\n    [{ type: \"bytes32\" }, { type: \"address\" }, { type: \"uint256\" }],\n    [keccak256(packedUserOp), entryPoint, BigInt(chainId)],\n  );\n  return keccak256(encoded);\n}\n", "import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getUserOpReceipt,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { DEFAULT_ACCOUNT_FACTORY } from \"./lib/constants.js\";\nimport { createUnsignedUserOp, signUserOp } from \"./lib/userop.js\";\nimport { isNativeAAChain } from \"./lib/utils.js\";\nimport type {\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nexport const personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const factoryAddress = options.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY;\n  const chain = connectChain ?? options.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (isNativeAAChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress(factoryContract, {\n    personalAccountAddress: personalAccount.address,\n    ...options,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}. Are you on the right chain?`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account: Account = {\n    address: accountContract.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      const executeTx = prepareExecute({\n        accountContract,\n        options,\n        transaction,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        options,\n        transactions,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        console.log(\n          \"Account contract not deployed yet. Deploying account before signing message\",\n        );\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        console.log(\n          \"Account contract not deployed yet. Deploying account before signing message\",\n        );\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n  };\n  return account;\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            overrides: creationOptions.overrides,\n            chain,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          overrides: creationOptions.overrides,\n          chain,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    executeTx,\n    options,\n  });\n  const signedUserOp = await signUserOp({\n    options,\n    userOp: unsignedUserOp,\n  });\n  const userOpHash = await bundleUserOp({\n    options,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    options,\n    userOpHash,\n  });\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n\nasync function waitForUserOpReceipt(args: {\n  options: SmartAccountOptions;\n  userOpHash: Hex;\n}): Promise<TransactionReceipt> {\n  const { options, userOpHash } = args;\n  const timeout = 120000; // 2mins\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt({ options, userOpHash });\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n"],
  "mappings": "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",
  "names": ["parseEventLogs", "parseEventLogs", "error", "isContractDeployed", "readContract", "encodeAbiParameters"]
}
