import {
  base64ToString
} from "./chunk-YRUP5XOX.js";
import {
  numberToHex
} from "./chunk-3JG4JMZX.js";

// node_modules/thirdweb/dist/esm/utils/base64/base64.js
function isBase64JSON(input) {
  if (input.startsWith("data:application/json;base64")) {
    return true;
  }
  return false;
}
function parseBase64String(input) {
  const [, base64] = input.split(",");
  return base64ToString(base64);
}

// node_modules/thirdweb/dist/esm/utils/nft/fetchTokenMetadata.js
async function fetchTokenMetadata(options) {
  const { client, tokenId, tokenUri } = options;
  if (isBase64JSON(tokenUri)) {
    try {
      return JSON.parse(parseBase64String(tokenUri));
    } catch (e) {
      console.error("Failed to fetch base64 encoded NFT", { tokenId, tokenUri }, e);
      throw e;
    }
  }
  const { download } = await import("./download-JR3FYJLC.js");
  try {
    if (!tokenUri.includes("{id}")) {
      return await (await download({ client, uri: tokenUri })).json();
    }
  } catch (e) {
    console.error("Failed to fetch non-dynamic NFT", { tokenId, tokenUri }, e);
    throw e;
  }
  try {
    try {
      return await (await download({
        client,
        uri: tokenUri.replace("{id}", numberToHex(tokenId, { size: 32 }).slice(2))
      })).json();
    } catch (err) {
      return await (await download({
        client,
        uri: tokenUri.replace("{id}", tokenId.toString())
      })).json();
    }
  } catch (e) {
    console.error("Failed to fetch dynamic NFT", { tokenId, tokenUri }, e);
    throw e;
  }
}

// node_modules/thirdweb/dist/esm/utils/nft/parseNft.js
function parseNFT(base, options) {
  switch (options.type) {
    case "ERC721":
      return {
        metadata: base,
        owner: (options == null ? void 0 : options.owner) ?? null,
        id: options.tokenId,
        tokenURI: options.tokenUri,
        type: options.type
      };
    case "ERC1155":
      return {
        metadata: base,
        owner: (options == null ? void 0 : options.owner) ?? null,
        id: options.tokenId,
        tokenURI: options.tokenUri,
        type: options.type,
        supply: options.supply
      };
    default:
      throw new Error("Invalid NFT type");
  }
}

export {
  fetchTokenMetadata,
  parseNFT
};
//# sourceMappingURL=chunk-GV57EYCP.js.map
