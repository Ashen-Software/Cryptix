{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/encoding/helpers/is-hex.ts", "../../thirdweb/src/utils/encoding/helpers/byte-size.ts", "../../thirdweb/src/utils/text-encoder.ts", "../../thirdweb/src/utils/encoding/helpers/assert-size.ts", "../../thirdweb/src/utils/encoding/helpers/charcode-to-base-16.ts", "../../thirdweb/src/utils/encoding/hex.ts"],
  "sourcesContent": ["export type Hex = `0x${string}`;\n\nexport type IsHexOptions = {\n  /** If set to true, the value must start with \"0x\" and only contain hexadecimal characters. If set to false, the value can start with \"0x\" or not. Default is true. */\n  strict?: boolean;\n};\n\n/**\n * Checks if a value is a valid hexadecimal string.\n * @param value - The value to be checked.\n * @param options - Optional configuration for the validation.\n * @returns True if the value is a valid hexadecimal string, false otherwise.\n * @example\n * ```ts\n * import { isHex } from \"thirdweb/utils\";\n * const result = isHex(\"0x1a4\");\n * console.log(result); // true\n * ```\n * @utils\n */\nexport function isHex(\n  value: unknown,\n  options: IsHexOptions = {},\n): value is Hex {\n  if (!value) {\n    return false;\n  }\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  return options.strict\n    ? /^0x[0-9a-fA-F]*$/.test(value)\n    : value.startsWith(\"0x\");\n}\n", "import { type Hex, isHex } from \"./is-hex.js\";\n\n/**\n * Calculates the byte size of a Hex string or Uint8Array.\n * If the value is a Hex string, it accounts for the leading \"0x\" prefix.\n * @param value The Hex string or Uint8Array.\n * @returns The byte size of the value.\n * @example\n * ```ts\n * import { byteSize } from \"thirdweb/utils\";\n * const size = byteSize(\"0x1a4\");\n * console.log(size); // 2\n * ```\n */\nexport function byteSize(value: Hex | Uint8Array) {\n  if (isHex(value, { strict: false })) {\n    return Math.ceil((value.length - 2) / 2);\n  }\n  return value.length;\n}\n", "let textEncoder: TextEncoder;\n\n/**\n * Re-using the same textencoder is faster.\n *\n * @returns\n * @internal\n */\nexport function cachedTextEncoder(): TextEncoder {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder;\n}\n", "import { byteSize } from \"./byte-size.js\";\nimport type { Hex } from \"./is-hex.js\";\n\n/**\n * Asserts that the size of the given hex or bytes is not greater than the specified size.\n * @param hexOrBytes - The hex or bytes to check the size of.\n * @param size - The maximum allowed size.\n * @throws Error if the size of the hex or bytes is greater than the specified size.\n * @example\n * ```ts\n * import { assertSize } from \"thirdweb/utils\";\n * assertSize(\"0x1a4\", { size: 2 });\n * ```\n * @internal\n */\nexport function assertSize(\n  hexOrBytes: Hex | Uint8Array,\n  { size }: { size: number },\n): void {\n  const givenSize = byteSize(hexOrBytes);\n  if (givenSize > size) {\n    throw new Error(`Size overflow: ${givenSize} > ${size}`);\n  }\n}\n", "const charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const;\n\n/**\n * @internal\n */\nexport function charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine) {\n    return char - charCodeMap.zero;\n  }\n  if (char >= charCodeMap.A && char <= charCodeMap.F) {\n    return char - (charCodeMap.A - 10);\n  }\n  if (char >= charCodeMap.a && char <= charCodeMap.f) {\n    return char - (charCodeMap.a - 10);\n  }\n  return undefined;\n}\n", "import { cachedTextDecoder } from \"../text-decoder.js\";\nimport { cachedTextEncoder } from \"../text-encoder.js\";\n// slightly tweaked re-exports from viem for the moment\nimport { assertSize } from \"./helpers/assert-size.js\";\nimport { charCodeToBase16 } from \"./helpers/charcode-to-base-16.js\";\nimport type { Hex } from \"./helpers/is-hex.js\";\n\nexport { type Hex, isHex, type IsHexOptions } from \"./helpers/is-hex.js\";\n\ntype TrimOptions = {\n  dir?: \"left\" | \"right\";\n};\ntype TrimReturnType<TValue extends Uint8Array | Hex> = TValue extends Hex\n  ? Hex\n  : Uint8Array;\n\nfunction trim<TValue extends Uint8Array | Hex>(\n  hexOrBytes: TValue,\n  options: TrimOptions = {},\n): TrimReturnType<TValue> {\n  const dir = options.dir || \"left\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  let data: any =\n    typeof hexOrBytes === \"string\" ? hexOrBytes.replace(\"0x\", \"\") : hexOrBytes;\n\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") {\n      sliceLength++;\n    } else {\n      break;\n    }\n  }\n  data =\n    dir === \"left\"\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength);\n\n  if (typeof hexOrBytes === \"string\") {\n    if (data.length === 1 && dir === \"right\") {\n      data = `${data}0`;\n    }\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<TValue>;\n  }\n  return data as TrimReturnType<TValue>;\n}\n\ntype PadOptions = {\n  dir?: \"left\" | \"right\";\n  size?: number | null;\n};\n\n/**\n * Pads a hexadecimal string with zeros to a specified size.\n * @param hex_ The hexadecimal string to pad.\n * @param options The padding options.\n * @returns The padded hexadecimal string.\n * @throws Error if the resulting padded string exceeds the specified size.\n * @example\n * ```ts\n * import { padHex } from \"thirdweb/utils\";\n * const paddedHex = padHex(\"0x1a4\", { size: 32 });\n * console.log(paddedHex); // \"0x000000000000000000000000000001a4\"\n * ```\n * @utils\n */\nexport function padHex(hex_: Hex, options: PadOptions = {}) {\n  const { dir, size = 32 } = options;\n  if (size === null) {\n    return hex_;\n  }\n  const hex = hex_.replace(\"0x\", \"\");\n  if (hex.length > size * 2) {\n    throw new Error(`Size overflow: ${Math.ceil(hex.length / 2)} > ${size}`);\n  }\n\n  return `0x${hex[dir === \"right\" ? \"padEnd\" : \"padStart\"](\n    size * 2,\n    \"0\",\n  )}` as Hex;\n}\n\n//--------------------------------------------------------------------------\n// FROM HEX\n//--------------------------------------------------------------------------\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number;\n};\n\n/**\n * Converts a hexadecimal string to a UTF-8 string.\n * @param hex The hexadecimal string to convert.\n * @param opts The options for the conversion.\n * @returns The UTF-8 string representation of the hexadecimal string.\n * @example\n * ```ts\n * import { hexToString } from \"thirdweb/utils\";\n * const string = hexToString(\"0x48656c6c6f2c20776f726c6421\");\n * console.log(string); // \"Hello, world!\"\n * ```\n * @utils\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToUint8Array(hex);\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size });\n    bytes = trim(bytes, { dir: \"right\" });\n  }\n  return cachedTextDecoder().decode(bytes);\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean;\n  /** Size (in bytes) of the hex value. */\n  size?: number;\n};\n\n/**\n * Converts a hexadecimal string to a BigInt.\n * @param hex - The hexadecimal string to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The BigInt representation of the hexadecimal string.\n * @example\n * ```ts\n * import { hexToBigInt } from \"thirdweb/utils\";\n * const bigInt = hexToBigInt(\"0x1a4\");\n * console.log(bigInt); // 420n\n * ```\n * @utils\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts;\n\n  if (opts.size) {\n    assertSize(hex, { size: opts.size });\n  }\n\n  const value = BigInt(hex);\n  if (!signed) {\n    return value;\n  }\n\n  const size = (hex.length - 2) / 2;\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n  if (value <= max) {\n    return value;\n  }\n\n  return value - BigInt(`0x${\"f\".padStart(size * 2, \"f\")}`) - 1n;\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts;\n/**\n * Converts a hexadecimal string to a number.\n * @param hex The hexadecimal string to convert.\n * @param opts Optional options for the conversion.\n * @returns The converted number.\n * @example\n * ```ts\n * import { hexToNumber } from \"thirdweb/utils\";\n * const number = hexToNumber(\"0x1a4\");\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts));\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number;\n};\n\n/**\n * Converts a hexadecimal string to a boolean value.\n * @param hex The hexadecimal string to convert.\n * @param opts Optional options for the conversion.\n * @returns The boolean value corresponding to the hexadecimal string.\n * @throws Error if the hexadecimal string is invalid.\n * @example\n * ```ts\n * import { hexToBool } from \"thirdweb/utils\";\n * const bool = hexToBool(\"0x01\");\n * console.log(bool); // true\n * ```\n * @utils\n */\nexport function hexToBool(hex: Hex, opts: HexToBoolOpts = {}): boolean {\n  if (opts.size) {\n    assertSize(hex, { size: opts.size });\n    // biome-ignore lint/style/noParameterAssign: for perf\n    hex = trim(hex);\n  }\n  if (trim(hex) === \"0x00\") {\n    return false;\n  }\n  if (trim(hex) === \"0x01\") {\n    return true;\n  }\n  throw new Error(`Invalid hex boolean: ${hex}`);\n}\n\nexport type HexToUint8ArrayOpts = {\n  /** Size of the output bytes. */\n  size?: number;\n};\n\n/**\n * Converts a hexadecimal string to a Uint8Array.\n * @param hex The hexadecimal string to convert.\n * @param opts Options for the conversion.\n * @returns The Uint8Array representation of the hexadecimal string.\n * @example\n * ```ts\n * import { hexToUint8Array } from \"thirdweb/utils\";\n * const bytes = hexToUint8Array(\"0x48656c6c6f2c20776f726c6421\");\n * console.log(bytes); // Uint8Array([72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33])\n * ```\n * @utils\n */\nexport function hexToUint8Array(\n  hex: Hex,\n  opts: HexToUint8ArrayOpts = {},\n): Uint8Array {\n  if (opts.size) {\n    assertSize(hex, { size: opts.size });\n    // biome-ignore lint/style/noParameterAssign: for perf\n    hex = padHex(hex, { dir: \"right\", size: opts.size });\n  }\n\n  let hexString = hex.slice(2) as string;\n  if (hexString.length % 2) {\n    hexString = `0${hexString}`;\n  }\n\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new Error(`Invalid hex character: ${hexString}`);\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n}\n\nexport type FromHexParameters<\n  TTo extends \"string\" | \"bigint\" | \"number\" | \"bytes\" | \"boolean\",\n> =\n  | TTo\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number;\n      /** Type to convert to. */\n      to: TTo;\n    };\n\nexport type FromHexReturnType<TTo> = TTo extends \"string\"\n  ? string\n  : TTo extends \"bigint\"\n    ? bigint\n    : TTo extends \"number\"\n      ? number\n      : TTo extends \"bytes\"\n        ? Uint8Array\n        : TTo extends \"boolean\"\n          ? boolean\n          : never;\n\n/**\n * Converts a hexadecimal string to the specified type.\n * @param hex - The hexadecimal string to convert.\n * @param toOrOpts - The target type or conversion options.\n * @returns The converted value of the specified type.\n * @example\n * ```ts\n * import { fromHex } from \"thirdweb/utils\";\n * const string = fromHex(\"0x48656c6c6f2c20776f726c6421\", \"string\");\n * console.log(string); // \"Hello, world!\"\n * ```\n * @utils\n */\nexport function fromHex<\n  TTo extends \"string\" | \"bigint\" | \"number\" | \"bytes\" | \"boolean\",\n>(hex: Hex, toOrOpts: FromHexParameters<TTo>): FromHexReturnType<TTo> {\n  const opts = typeof toOrOpts === \"string\" ? { to: toOrOpts } : toOrOpts;\n\n  switch (opts.to) {\n    case \"number\":\n      return hexToNumber(hex, opts) as FromHexReturnType<TTo>;\n    case \"bigint\":\n      return hexToBigInt(hex, opts) as FromHexReturnType<TTo>;\n    case \"string\":\n      return hexToString(hex, opts) as FromHexReturnType<TTo>;\n    case \"boolean\":\n      return hexToBool(hex, opts) as FromHexReturnType<TTo>;\n    default:\n      return hexToUint8Array(hex, opts) as FromHexReturnType<TTo>;\n  }\n}\n\n//--------------------------------------------------------------------------\n// TO HEX\n//--------------------------------------------------------------------------\n\nconst hexes = /* @__PURE__ */ (() =>\n  Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, \"0\")))();\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number;\n};\n\n/**\n * Converts a boolean value to a hexadecimal string representation.\n * @param value - The boolean value to convert.\n * @param opts - Optional options for the conversion.\n * @returns The hexadecimal string representation of the boolean value.\n * @example\n * ```ts\n * import { boolToHex } from \"thirdweb/utils\";\n * const hex = boolToHex(true);\n * console.log(hex); // \"0x01\"\n * ```\n * @utils\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex = `0x${Number(value)}` as const;\n  if (typeof opts.size === \"number\") {\n    assertSize(hex, { size: opts.size });\n    return padHex(hex, { size: opts.size });\n  }\n  return hex;\n}\n\nexport type Uint8ArrayToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number;\n};\n\n/**\n * Converts an array of bytes to a hexadecimal string.\n * @param value - The array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The hexadecimal string representation of the bytes.\n * @example\n * ```ts\n * import { uint8arrayToHex } from \"thirdweb/utils\";\n * const hex = uint8arrayToHex(new Uint8Array([72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100]));\n * console.log(hex); // \"0x48656c6c6f2c20776f726c64\"\n * ```\n * @utils\n */\nexport function uint8ArrayToHex(\n  value: Uint8Array,\n  opts: Uint8ArrayToHexOpts = {},\n): Hex {\n  let string = \"\";\n  for (let i = 0; i < value.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know this is defined\n    string += hexes[value[i]!];\n  }\n  const hex = `0x${string}` as const;\n\n  if (typeof opts.size === \"number\") {\n    assertSize(hex, { size: opts.size });\n    return padHex(hex, { dir: \"right\", size: opts.size });\n  }\n  return hex;\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean;\n      /** The size (in bytes) of the output hex value. */\n      size: number;\n    }\n  | {\n      signed?: never;\n      /** The size (in bytes) of the output hex value. */\n      size?: number;\n    };\n\n/**\n * Converts a number or bigint to a hexadecimal string.\n * @param value_ - The number or bigint value to convert.\n * @param opts - Optional configuration options.\n * @returns The hexadecimal representation of the input value.\n * @throws An error if the input value is not within the safe integer range.\n * @example\n * ```ts\n * import { numberToHex } from \"thirdweb/utils\";\n * const hex = numberToHex(420);\n * console.log(hex); // \"0x1a4\"\n * ```\n * @utils\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts;\n\n  const value = BigInt(value_);\n\n  let maxValue: bigint | number | undefined;\n  if (size) {\n    if (signed) {\n      maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n    } else {\n      maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n  } else if (typeof value_ === \"number\") {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n\n  const minValue = typeof maxValue === \"bigint\" && signed ? -maxValue - 1n : 0;\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === \"bigint\" ? \"n\" : \"\";\n    throw new Error(\n      `Number \"${value_}${suffix}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? \"signed\" : \"unsigned\"} ` : \"\"\n      }integer range ${\n        maxValue ? `(${minValue} to ${maxValue})` : `(above ${minValue})`\n      }`,\n    );\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex;\n  if (size) {\n    return padHex(hex, { size }) as Hex;\n  }\n  return hex;\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number;\n};\n\n/**\n * Converts a string to its hexadecimal representation.\n * @param value_ The string to convert to hexadecimal.\n * @param opts Options for the conversion.\n * @returns The hexadecimal representation of the input string.\n * @example\n * ```ts\n * import { stringToHex } from \"thirdweb/utils\";\n * const hex = stringToHex(\"Hello, world!\");\n * console.log(hex); // \"0x48656c6c6f2c20776f726c6421\"\n * ```\n * @utils\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = cachedTextEncoder().encode(value_);\n  return uint8ArrayToHex(value, opts);\n}\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number;\n};\n\n/**\n * Converts a value to its hexadecimal representation.\n * @param value - The value to convert to hexadecimal.\n * @param opts - Optional parameters for the conversion.\n * @returns The hexadecimal representation of the value.\n * @example\n * ```ts\n * import { toHex } from \"thirdweb/utils\";\n * const hex = toHex(420);\n * console.log(hex); // \"0x1a4\"\n * ```\n * @utils\n */\nexport function toHex(\n  value: string | number | bigint | boolean | Uint8Array,\n  opts: ToHexParameters = {},\n): Hex {\n  switch (typeof value) {\n    case \"number\":\n    case \"bigint\":\n      return numberToHex(value, opts);\n    case \"string\":\n      return stringToHex(value, opts);\n    case \"boolean\":\n      return boolToHex(value, opts);\n    default:\n      return uint8ArrayToHex(value, opts);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
