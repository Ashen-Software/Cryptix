import {
  LocalStorage
} from "./chunk-M7UJHDZW.js";
import {
  getThirdwebBaseUrl
} from "./chunk-MHFR2GDE.js";
import {
  getClientFetch
} from "./chunk-CVWITOXT.js";
import {
  __export
} from "./chunk-SEVZ5PBP.js";

// node_modules/@passwordless-id/webauthn/dist/esm/client.js
var client_exports = {};
__export(client_exports, {
  authenticate: () => authenticate,
  isAvailable: () => isAvailable,
  isLocalAuthenticator: () => isLocalAuthenticator,
  register: () => register
});

// node_modules/@passwordless-id/webauthn/dist/esm/utils.js
function toBuffer(txt) {
  return Uint8Array.from(txt, (c) => c.charCodeAt(0)).buffer;
}
function parseBuffer(buffer) {
  return String.fromCharCode(...new Uint8Array(buffer));
}
function isBase64url(txt) {
  return txt.match(/^[a-zA-Z0-9\-_]+=*$/) !== null;
}
function toBase64url(buffer) {
  const txt = btoa(parseBuffer(buffer));
  return txt.replaceAll("+", "-").replaceAll("/", "_");
}
function parseBase64url(txt) {
  txt = txt.replaceAll("-", "+").replaceAll("_", "/");
  return toBuffer(atob(txt));
}
async function sha256(buffer) {
  return await crypto.subtle.digest("SHA-256", buffer);
}

// node_modules/@passwordless-id/webauthn/dist/esm/client.js
function isAvailable() {
  return !!window.PublicKeyCredential;
}
async function isLocalAuthenticator() {
  return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
}
async function getAuthAttachment(authType) {
  if (authType === "local")
    return "platform";
  if (authType === "roaming" || authType === "extern")
    return "cross-platform";
  if (authType === "both")
    return void 0;
  try {
    if (await isLocalAuthenticator())
      return "platform";
    else
      return "cross-platform";
  } catch (e) {
    return void 0;
  }
}
function getAlgoName(num) {
  switch (num) {
    case -7:
      return "ES256";
    case -257:
      return "RS256";
    default:
      throw new Error(`Unknown algorithm code: ${num}`);
  }
}
async function register(username, challenge, options) {
  options = options ?? {};
  if (!isBase64url(challenge))
    throw new Error("Provided challenge is not properly encoded in Base64url");
  const creationOptions = {
    challenge: parseBase64url(challenge),
    rp: {
      id: options.domain ?? window.location.hostname,
      name: options.domain ?? window.location.hostname
    },
    user: {
      id: options.userHandle ? toBuffer(options.userHandle) : await sha256(new TextEncoder().encode("passwordless.id-user:" + username)),
      name: username,
      displayName: username
    },
    pubKeyCredParams: [
      { alg: -7, type: "public-key" },
      { alg: -257, type: "public-key" }
      // RS256 (for Windows Hello and others)
    ],
    timeout: options.timeout ?? 6e4,
    authenticatorSelection: {
      userVerification: options.userVerification ?? "required",
      authenticatorAttachment: await getAuthAttachment(options.authenticatorType ?? "auto"),
      residentKey: options.discoverable ?? "preferred",
      requireResidentKey: options.discoverable === "required"
      // mainly for backwards compatibility, see https://www.w3.org/TR/webauthn/#dictionary-authenticatorSelection
    },
    attestation: "direct"
  };
  if (options.debug)
    console.debug(creationOptions);
  const credential = await navigator.credentials.create({ publicKey: creationOptions });
  if (options.debug)
    console.debug(credential);
  const response = credential.response;
  let registration = {
    username,
    credential: {
      id: credential.id,
      publicKey: toBase64url(response.getPublicKey()),
      algorithm: getAlgoName(credential.response.getPublicKeyAlgorithm())
    },
    authenticatorData: toBase64url(response.getAuthenticatorData()),
    clientData: toBase64url(response.clientDataJSON)
  };
  if (options.attestation) {
    registration.attestationData = toBase64url(response.attestationObject);
  }
  return registration;
}
async function getTransports(authType) {
  const local = ["internal"];
  const roaming = ["hybrid", "usb", "ble", "nfc"];
  if (authType === "local")
    return local;
  if (authType == "roaming" || authType === "extern")
    return roaming;
  if (authType === "both")
    return [...local, ...roaming];
  try {
    if (await isLocalAuthenticator())
      return local;
    else
      return roaming;
  } catch (e) {
    return [...local, ...roaming];
  }
}
async function authenticate(credentialIds, challenge, options) {
  options = options ?? {};
  if (!isBase64url(challenge))
    throw new Error("Provided challenge is not properly encoded in Base64url");
  const transports = await getTransports(options.authenticatorType ?? "auto");
  let authOptions = {
    challenge: parseBase64url(challenge),
    rpId: options.domain ?? window.location.hostname,
    allowCredentials: credentialIds.map((id) => {
      return {
        id: parseBase64url(id),
        type: "public-key",
        transports
      };
    }),
    userVerification: options.userVerification ?? "required",
    timeout: options.timeout ?? 6e4
  };
  if (options.debug)
    console.debug(authOptions);
  let auth = await navigator.credentials.get({ publicKey: authOptions, mediation: options.mediation });
  if (options.debug)
    console.debug(auth);
  const response = auth.response;
  const authentication = {
    credentialId: auth.id,
    authenticatorData: toBase64url(response.authenticatorData),
    clientData: toBase64url(response.clientDataJSON),
    signature: toBase64url(response.signature),
    userHandle: response.userHandle ? toBase64url(response.userHandle) : void 0
    // may not be returned by every authenticator
  };
  return authentication;
}

// node_modules/@passwordless-id/webauthn/dist/esm/parsers.js
var utf8Decoder = new TextDecoder("utf-8");

// node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/passkeys.js
function getVerificationPath() {
  return `${getThirdwebBaseUrl("inAppWallet")}/api/2024-05-05/login/passkey/callback`;
}
function getChallengePath(type, username) {
  return `${getThirdwebBaseUrl("inAppWallet")}/api/2024-05-05/login/passkey?type=${type}${username ? `&username=${username}` : ""}`;
}
async function registerPasskey(options) {
  var _a, _b, _c;
  if (!client_exports.isAvailable()) {
    throw new Error("Passkeys are not available on this device");
  }
  const storage = new LocalStorage({
    clientId: options.client.clientId,
    ecosystemId: (_a = options.ecosystem) == null ? void 0 : _a.id
  });
  const fetchWithId = getClientFetch(options.client, options.ecosystem);
  const generatedName = options.username ?? generateUsername(options.ecosystem);
  const res = await fetchWithId(getChallengePath("sign-up", generatedName));
  const challengeData = await res.json();
  if (!challengeData.challenge) {
    throw new Error("No challenge received");
  }
  const challenge = challengeData.challenge;
  const registration = await client_exports.register(generatedName, challenge, {
    authenticatorType: options.authenticatorType ?? "auto",
    userVerification: "required",
    attestation: true,
    debug: false
  });
  await storage.savePasskeyCredentialId(registration.credential.id);
  const customHeaders = {};
  if ((_b = options.ecosystem) == null ? void 0 : _b.partnerId) {
    customHeaders["x-ecosystem-partner-id"] = options.ecosystem.partnerId;
  }
  if ((_c = options.ecosystem) == null ? void 0 : _c.id) {
    customHeaders["x-ecosystem-id"] = options.ecosystem.id;
  }
  const verifRes = await fetchWithId(getVerificationPath(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...customHeaders
    },
    body: JSON.stringify({
      type: "sign-up",
      authenticatorData: registration.authenticatorData,
      credentialId: registration.credential.id,
      serverVerificationId: challengeData.serverVerificationId,
      clientData: registration.clientData,
      username: generatedName,
      credential: {
        publicKey: registration.credential.publicKey,
        algorithm: registration.credential.algorithm
      }
    })
  });
  const verifData = await verifRes.json();
  if (!verifData) {
    throw new Error("No token received");
  }
  return verifData;
}
async function loginWithPasskey(options) {
  var _a, _b, _c;
  if (!client_exports.isAvailable()) {
    throw new Error("Passkeys are not available on this device");
  }
  const storage = new LocalStorage({
    clientId: options.client.clientId,
    ecosystemId: (_a = options.ecosystem) == null ? void 0 : _a.id
  });
  const fetchWithId = getClientFetch(options.client, options.ecosystem);
  const res = await fetchWithId(getChallengePath("sign-in"));
  const challengeData = await res.json();
  if (!challengeData.challenge) {
    throw new Error("No challenge received");
  }
  const challenge = challengeData.challenge;
  const credentialId = await storage.getPasskeyCredentialId();
  const credentials = credentialId ? [credentialId] : [];
  const authentication = await client_exports.authenticate(credentials, challenge, {
    authenticatorType: options.authenticatorType ?? "auto",
    userVerification: "required"
  });
  const customHeaders = {};
  if ((_b = options.ecosystem) == null ? void 0 : _b.partnerId) {
    customHeaders["x-ecosystem-partner-id"] = options.ecosystem.partnerId;
  }
  if ((_c = options.ecosystem) == null ? void 0 : _c.id) {
    customHeaders["x-ecosystem-id"] = options.ecosystem.id;
  }
  const verifRes = await fetchWithId(getVerificationPath(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...customHeaders
    },
    body: JSON.stringify({
      type: "sign-in",
      authenticatorData: authentication.authenticatorData,
      credentialId: authentication.credentialId,
      serverVerificationId: challengeData.serverVerificationId,
      clientData: authentication.clientData,
      signature: authentication.signature
    })
  });
  await storage.savePasskeyCredentialId(authentication.credentialId);
  const verifData = await verifRes.json();
  if (!verifData) {
    throw new Error("No token received");
  }
  return verifData;
}
async function hasStoredPasskey(client, ecosystemId) {
  const storage = new LocalStorage({
    clientId: client.clientId,
    ecosystemId
  });
  const credId = await storage.getPasskeyCredentialId();
  return !!credId;
}
function generateUsername(ecosystem) {
  return `${(ecosystem == null ? void 0 : ecosystem.id) ?? "wallet"}-${(/* @__PURE__ */ new Date()).toISOString()}`;
}

export {
  registerPasskey,
  loginWithPasskey,
  hasStoredPasskey
};
//# sourceMappingURL=chunk-X3XYCUUS.js.map
