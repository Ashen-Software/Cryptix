{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/common/__generated__/IContractMetadata/read/name.ts", "../../thirdweb/src/extensions/common/read/name.ts", "../../thirdweb/src/extensions/common/__generated__/IContractMetadata/read/symbol.ts", "../../thirdweb/src/extensions/common/read/symbol.ts", "../../thirdweb/src/extensions/erc20/read/getCurrencyMetadata.ts"],
  "sourcesContent": ["import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x06fdde03\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `name` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `name` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isNameSupported } from \"thirdweb/extensions/common\";\n *\n * const supported = await isNameSupported(contract);\n * ```\n */\nexport async function isNameSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the name function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeNameResult } from \"thirdweb/extensions/common\";\n * const result = decodeNameResult(\"...\");\n * ```\n */\nexport function decodeNameResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"name\" function on the contract.\n * @param options - The options for the name function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const result = await name({\n *  contract,\n * });\n *\n * ```\n */\nexport async function name(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { name as generatedName } from \"../__generated__/IContractMetadata/read/name.js\";\n\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const contractName = await name({ contract });\n * ```\n */\nexport async function name(options: BaseTransactionOptions): Promise<string> {\n  return withCache(() => generatedName(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:name`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n", "import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x95d89b41\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `symbol` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `symbol` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isSymbolSupported } from \"thirdweb/extensions/common\";\n *\n * const supported = await isSymbolSupported(contract);\n * ```\n */\nexport async function isSymbolSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the symbol function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeSymbolResult } from \"thirdweb/extensions/common\";\n * const result = decodeSymbolResult(\"...\");\n * ```\n */\nexport function decodeSymbolResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"symbol\" function on the contract.\n * @param options - The options for the symbol function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const result = await symbol({\n *  contract,\n * });\n *\n * ```\n */\nexport async function symbol(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { symbol as generatedSymbol } from \"../__generated__/IContractMetadata/read/symbol.js\";\n\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const contractSymbol = await symbol({ contract });\n * ```\n */\nexport async function symbol(options: BaseTransactionOptions): Promise<string> {\n  return withCache(() => generatedSymbol(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:symbol`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n", "import { isNativeTokenAddress } from \"../../../constants/addresses.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { name } from \"../../common/read/name.js\";\nimport { symbol } from \"../../common/read/symbol.js\";\nimport { decimals } from \"../__generated__/IERC20/read/decimals.js\";\n\nexport type GetCurrencyMetadataResult = {\n  name: string;\n  symbol: string;\n  decimals: number;\n};\n\n/**\n * Retrieves the metadata of a currency.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to an object containing the currency metadata.\n * @extension ERC20\n * @example\n * ```ts\n * import { getCurrencyMetadata } from \"thirdweb/extensions/erc20\";\n *\n * const currencyMetadata = await getCurrencyMetadata({ contract });\n * ```\n */\nexport async function getCurrencyMetadata(\n  options: BaseTransactionOptions,\n): Promise<GetCurrencyMetadataResult> {\n  // if the contract is the native token, return the native currency metadata\n  if (isNativeTokenAddress(options.contract.address)) {\n    return {\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18,\n      // overwrite with native currency of the chain if available\n      ...options.contract.chain.nativeCurrency,\n    };\n  }\n\n  try {\n    const [name_, symbol_, decimals_] = await Promise.all([\n      name(options).catch(() => \"\"),\n      symbol(options),\n      decimals(options),\n    ]);\n\n    return {\n      name: name_,\n      symbol: symbol_,\n      decimals: decimals_,\n    };\n  } catch (e) {\n    throw new Error(\"Invalid currency token\");\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAQO,IAAM,cAAc;AAC3B,IAAM,YAAY,CAAA;AAClB,IAAM,aAAa;EACjB;IACE,MAAM;;;AAqDV,eAAsB,KAAK,SAA+B;AACxD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAAC,aAAa,WAAW,UAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACvDA,eAAsBA,MAAK,SAA+B;AACxD,SAAO,UAAU,MAAM,KAAc,OAAO,GAAG;IAC7C,UAAU,GAAG,QAAQ,SAAS,MAAM,EAAE,IAAI,QAAQ,SAAS,OAAO;;IAElE,WAAW,OAAO;GACnB;AACH;;;ACdO,IAAMC,eAAc;AAC3B,IAAMC,aAAY,CAAA;AAClB,IAAMC,cAAa;EACjB;IACE,MAAM;;;AAqDV,eAAsB,OAAO,SAA+B;AAC1D,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACvDA,eAAsBC,QAAO,SAA+B;AAC1D,SAAO,UAAU,MAAM,OAAgB,OAAO,GAAG;IAC/C,UAAU,GAAG,QAAQ,SAAS,MAAM,EAAE,IAAI,QAAQ,SAAS,OAAO;;IAElE,WAAW,OAAO;GACnB;AACH;;;ACEA,eAAsB,oBACpB,SAA+B;AAG/B,MAAI,qBAAqB,QAAQ,SAAS,OAAO,GAAG;AAClD,WAAO;MACL,MAAM;MACN,QAAQ;MACR,UAAU;;MAEV,GAAG,QAAQ,SAAS,MAAM;;EAE9B;AAEA,MAAI;AACF,UAAM,CAAC,OAAO,SAAS,SAAS,IAAI,MAAM,QAAQ,IAAI;MACpDC,MAAK,OAAO,EAAE,MAAM,MAAM,EAAE;MAC5BC,QAAO,OAAO;MACd,SAAS,OAAO;KACjB;AAED,WAAO;MACL,MAAM;MACN,QAAQ;MACR,UAAU;;EAEd,SAAS,GAAG;AACV,UAAM,IAAI,MAAM,wBAAwB;EAC1C;AACF;",
  "names": ["name", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "symbol", "name", "symbol"]
}
