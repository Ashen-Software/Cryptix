{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/bytecode/detectExtension.ts"],
  "sourcesContent": ["import type { AbiFunction } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedMethod } from \"../abi/prepare-method.js\";\n\ntype DetectExtensionOptions = {\n  contract: ThirdwebContract;\n  method: string | AbiFunction | PreparedMethod<AbiFunction>;\n};\n\n/**\n * Detects if the specified method is present in the contract bytecode.\n * @param options - The options for detecting the extension.\n * @returns A promise that resolves to a boolean indicating if the extension is detected.\n * @example\n * ```ts\n * import { detectMethod } from \"thirdweb/utils/extensions/detect.js\";\n * const hasDecimals = await detectMethod({\n *  contract,\n *  method: \"function decimals() view returns (uint8)\",\n * });\n * ```\n * @contract\n */\nexport async function detectMethod(\n  options: DetectExtensionOptions,\n): Promise<boolean> {\n  const bytecode = await getBytecode(options.contract);\n  return detectMethodInBytecode({ bytecode, method: options.method });\n}\n\ntype DetectExtensionInBytecodeOptions = {\n  bytecode: string;\n  method: string | AbiFunction | PreparedMethod<AbiFunction>;\n};\n/**\n * Detects if a specific method is present in the bytecode of a contract.\n * @param options - The options for detecting the method in the bytecode.\n * @returns A boolean indicating whether the method is present in the bytecode.\n * @internal\n */\nfunction detectMethodInBytecode(options: DetectExtensionInBytecodeOptions) {\n  // if we can't get the bytecode we know the contract is not deployed\n  if (options.bytecode === \"0x\") {\n    return false;\n  }\n  // we strip the leading `0x` from the function selector\n  const fnSelector = Array.isArray(options.method)\n    ? options.method[0]\n    : toFunctionSelector(options.method);\n\n  // indexOf is slightly faster than includes\n  return options.bytecode.indexOf(fnSelector.slice(2)) > -1;\n}\n"],
  "mappings": ";;;;;;;;AAyBA,eAAsB,aACpB,SAA+B;AAE/B,QAAM,WAAW,MAAM,YAAY,QAAQ,QAAQ;AACnD,SAAO,uBAAuB,EAAE,UAAU,QAAQ,QAAQ,OAAM,CAAE;AACpE;AAYA,SAAS,uBAAuB,SAAyC;AAEvE,MAAI,QAAQ,aAAa,MAAM;AAC7B,WAAO;EACT;AAEA,QAAM,aAAa,MAAM,QAAQ,QAAQ,MAAM,IAC3C,QAAQ,OAAO,CAAC,IAChB,mBAAmB,QAAQ,MAAM;AAGrC,SAAO,QAAQ,SAAS,QAAQ,WAAW,MAAM,CAAC,CAAC,IAAI;AACzD;",
  "names": []
}
