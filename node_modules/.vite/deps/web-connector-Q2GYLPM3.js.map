{
  "version": 3,
  "sources": ["../../thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/IframeCommunicator.ts", "../../thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/InAppWalletIframeCommunicator.ts", "../../thirdweb/src/wallets/in-app/web/lib/auth/abstract-login.ts", "../../thirdweb/src/wallets/in-app/web/lib/auth/base-login.ts", "../../thirdweb/src/wallets/in-app/web/lib/auth/iframe-auth.ts", "../../thirdweb/src/wallets/ecosystem/get-ecosystem-partner-permissions.ts", "../../thirdweb/src/wallets/in-app/web/lib/in-app-account.ts", "../../thirdweb/src/wallets/in-app/web/lib/web-connector.ts"],
  "sourcesContent": ["type IFrameCommunicatorProps = {\n  link: string;\n  baseUrl: string;\n  iframeId: string;\n  container?: HTMLElement;\n  onIframeInitialize?: () => void;\n};\n\nfunction sleep(seconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\n\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\",\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map<string, boolean>();\n\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator<T extends { [key: string]: any }> {\n  private iframe: HTMLIFrameElement;\n  private POLLING_INTERVAL_SECONDS = 1.4;\n\n  private iframeBaseUrl;\n  /**\n   * @internal\n   */\n  constructor({\n    link,\n    baseUrl,\n    iframeId,\n    container = document.body,\n    onIframeInitialize,\n  }: IFrameCommunicatorProps) {\n    this.iframeBaseUrl = baseUrl;\n\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId) as HTMLIFrameElement | null;\n    const hrefLink = new URL(link);\n\n    // TODO (ew) - bring back version tracking\n    // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n    // if (!sdkVersion) {\n    //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n    // }\n    // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n\n      iframe = document.createElement(\"iframe\");\n      const mergedIframeStyles = {\n        ...iframeBaseStyle,\n      };\n      Object.assign(iframe.style, mergedIframeStyles);\n      iframe.setAttribute(\"id\", iframeId);\n      iframe.setAttribute(\"fetchpriority\", \"high\");\n      container.appendChild(iframe);\n\n      iframe.src = hrefLink.href;\n\n      // iframe.setAttribute(\"data-version\", sdkVersion);\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      const onIframeLoaded = (event: MessageEvent<any>) => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb iFrame not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  protected async onIframeLoadedInitVariables(): Promise<Record<string, any>> {\n    return {};\n  }\n\n  /**\n   * @internal\n   */\n  onIframeLoadHandler(\n    iframe: HTMLIFrameElement,\n    onIframeInitialize?: () => void,\n  ) {\n    return async () => {\n      const channel = new MessageChannel();\n\n      const promise = new Promise((res, rej) => {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        channel.port1.onmessage = (event: any) => {\n          const { data } = event;\n          channel.port1.close();\n          if (!data.success) {\n            rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          res(true);\n        };\n      });\n\n      const INIT_IFRAME_EVENT = \"initIframe\";\n      iframe?.contentWindow?.postMessage(\n        // ? We initialise the iframe with a bunch\n        // of useful information so that we don't have to pass it\n        // through in each of the future call. This would be where we do it.\n        {\n          eventType: INIT_IFRAME_EVENT,\n          data: await this.onIframeLoadedInitVariables(),\n        },\n        this.iframeBaseUrl,\n        [channel.port2],\n      );\n\n      await promise;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async call<ReturnData>({\n    procedureName,\n    params,\n    showIframe = false,\n  }: {\n    procedureName: keyof T;\n    params: T[keyof T];\n    showIframe?: boolean;\n  }) {\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005);\n    }\n\n    const channel = new MessageChannel();\n    const promise = new Promise<ReturnData>((res, rej) => {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      channel.port1.onmessage = async (event: any) => {\n        const { data } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n    });\n\n    this.iframe.contentWindow?.postMessage(\n      { eventType: procedureName, data: params },\n      this.iframeBaseUrl,\n      [channel.port2],\n    );\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   * @internal\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n", "import { IN_APP_WALLET_PATH } from \"../../../core/constants/settings.js\";\nimport type { Ecosystem } from \"../../types.js\";\nimport { LocalStorage } from \"../Storage/LocalStorage.js\";\nimport { IframeCommunicator } from \"./IframeCommunicator.js\";\n\n/**\n * @internal\n */\nexport class InAppWalletIframeCommunicator<\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  T extends { [key: string]: any },\n> extends IframeCommunicator<T> {\n  clientId: string;\n  ecosystem?: Ecosystem;\n  /**\n   * @internal\n   */\n  constructor({\n    clientId,\n    baseUrl,\n    ecosystem,\n  }: {\n    clientId: string;\n    baseUrl: string;\n    ecosystem?: Ecosystem;\n  }) {\n    super({\n      iframeId: IN_APP_WALLET_IFRAME_ID + (ecosystem?.id || \"\"),\n      link: createInAppWalletIframeLink({\n        clientId,\n        path: IN_APP_WALLET_PATH,\n        ecosystem,\n        baseUrl,\n      }).href,\n      baseUrl,\n      container: document.body,\n    });\n    this.clientId = clientId;\n    this.ecosystem = ecosystem;\n  }\n\n  /**\n   * @internal\n   */\n  override async onIframeLoadedInitVariables() {\n    const localStorage = new LocalStorage({\n      clientId: this.clientId,\n      ecosystemId: this.ecosystem?.id,\n    });\n\n    return {\n      authCookie: await localStorage.getAuthCookie(),\n      deviceShareStored: await localStorage.getDeviceShare(),\n      walletUserId: await localStorage.getWalletUserId(),\n      clientId: this.clientId,\n      partnerId: this.ecosystem?.partnerId,\n      ecosystemId: this.ecosystem?.id,\n    };\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\n/**\n * @internal\n */\nexport function createInAppWalletIframeLink({\n  clientId,\n  baseUrl,\n  path,\n  ecosystem,\n  queryParams,\n}: {\n  clientId: string;\n  baseUrl: string;\n  path: string;\n  ecosystem?: Ecosystem;\n  queryParams?: { [key: string]: string | number };\n}) {\n  const inAppWalletUrl = new URL(`${path}`, baseUrl);\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      inAppWalletUrl.searchParams.set(\n        queryKey,\n        queryParams[queryKey]?.toString() || \"\",\n      );\n    }\n  }\n  inAppWalletUrl.searchParams.set(\"clientId\", clientId);\n  if (ecosystem?.partnerId !== undefined) {\n    inAppWalletUrl.searchParams.set(\"partnerId\", ecosystem.partnerId);\n  }\n  if (ecosystem?.id !== undefined) {\n    inAppWalletUrl.searchParams.set(\"ecosystemId\", ecosystem.id);\n  }\n  return inAppWalletUrl;\n}\nexport const IN_APP_WALLET_IFRAME_ID = \"thirdweb-in-app-wallet-iframe\";\n", "import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthProvider,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/type.js\";\nimport type { ClientIdWithQuerierType, Ecosystem } from \"../../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\nexport type LoginQuerierTypes = {\n  loginWithCustomAuthEndpoint: { payload: string; encryptionKey: string };\n  loginWithCustomJwt: { jwt: string; encryptionKey?: string };\n  loginWithThirdwebModal: undefined | { email: string };\n  sendThirdwebSmsLoginOtp: { phoneNumber: string };\n  sendThirdwebEmailLoginOtp: { email: string };\n  verifyThirdwebEmailLoginOtp: {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  verifyThirdwebSmsLoginOtp: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  injectDeveloperClientId: undefined;\n  getHeadlessOauthLoginLink: { authProvider: AuthProvider };\n};\n\ntype OauthLoginType = {\n  openedWindow?: Window | null;\n  closeOpenedWindow?: (openedWindow: Window) => void;\n};\n\n/**\n * @internal\n */\nexport abstract class AbstractLogin<\n  MODAL = void,\n  EMAIL_MODAL extends { email: string } = { email: string },\n  EMAIL_VERIFICATION extends { email: string; otp: string } = {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  },\n> {\n  protected LoginQuerier: InAppWalletIframeCommunicator<LoginQuerierTypes>;\n  protected preLogin;\n  protected postLogin: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  protected client: ThirdwebClient;\n  protected baseUrl: string;\n  protected ecosystem?: Ecosystem;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * @internal\n   */\n  constructor({\n    baseUrl,\n    querier,\n    preLogin,\n    postLogin,\n    client,\n    ecosystem,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    preLogin: () => Promise<void>;\n    postLogin: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n    ecosystem?: Ecosystem;\n  }) {\n    this.baseUrl = baseUrl;\n    this.LoginQuerier = querier;\n    this.preLogin = preLogin;\n    this.postLogin = postLogin;\n    this.client = client;\n    this.ecosystem = ecosystem;\n  }\n\n  abstract loginWithCustomJwt(args: {\n    jwt: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithCustomAuthEndpoint(args: {\n    payload: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithModal(args?: MODAL): Promise<AuthLoginReturnType>;\n  abstract loginWithEmailOtp(args: EMAIL_MODAL): Promise<AuthLoginReturnType>;\n  abstract loginWithOauth(\n    args: OauthLoginType & { oauthProvider: AuthProvider },\n  ): Promise<AuthLoginReturnType>;\n\n  /**\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: LoginQuerierTypes[\"sendThirdwebEmailLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebEmailLoginOtp\",\n      params: { email },\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: LoginQuerierTypes[\"sendThirdwebSmsLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebSmsLoginOtp\",\n      params: { phoneNumber },\n    });\n    return result;\n  }\n\n  abstract verifyEmailLoginOtp(\n    args: EMAIL_VERIFICATION,\n  ): Promise<AuthLoginReturnType>;\n\n  abstract verifySmsLoginOtp(args: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  }): Promise<AuthLoginReturnType>;\n}\n", "import {\n  type AuthAndWalletRpcReturnType,\n  type AuthLoginReturnType,\n  AuthProvider,\n  type GetHeadlessLoginLinkReturnType,\n} from \"../../../core/authentication/type.js\";\nimport { AbstractLogin, type LoginQuerierTypes } from \"./abstract-login.js\";\n\n/**\n *\n */\nexport class BaseLogin extends AbstractLogin<\n  void,\n  { email: string },\n  { email: string; otp: string; recoveryCode?: string }\n> {\n  private async getOauthLoginUrl(\n    authProvider: AuthProvider,\n  ): Promise<GetHeadlessLoginLinkReturnType> {\n    try {\n      const result =\n        await this.LoginQuerier.call<GetHeadlessLoginLinkReturnType>({\n          procedureName: \"getHeadlessOauthLoginLink\",\n          params: { authProvider },\n        });\n      return result;\n    } catch (e) {\n      console.error(e);\n      throw e;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithModal(): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: undefined,\n      showIframe: true,\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithEmailOtp({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: { email },\n      showIframe: true,\n    });\n    return this.postLogin(result);\n  }\n\n  private closeWindow = ({\n    isWindowOpenedByFn,\n    win,\n    closeOpenedWindow,\n  }: {\n    win?: Window | null;\n    isWindowOpenedByFn: boolean;\n    closeOpenedWindow?: (openedWindow: Window) => void;\n  }) => {\n    if (isWindowOpenedByFn) {\n      win?.close();\n    } else {\n      if (win && closeOpenedWindow) {\n        closeOpenedWindow(win);\n      } else if (win) {\n        win.close();\n      }\n    }\n  };\n\n  private getOauthPopUpSizing(authProvider: AuthProvider) {\n    switch (authProvider) {\n      case AuthProvider.FACEBOOK:\n        return \"width=715, height=555\";\n      default:\n        return \"width=350, height=500\";\n    }\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithOauth(args: {\n    oauthProvider: AuthProvider;\n    openedWindow?: Window | null | undefined;\n    closeOpenedWindow?: ((openedWindow: Window) => void) | undefined;\n  }): Promise<AuthLoginReturnType> {\n    let win = args?.openedWindow;\n    let isWindowOpenedByFn = false;\n    if (!win) {\n      win = window.open(\n        \"\",\n        \"Login\",\n        this.getOauthPopUpSizing(args.oauthProvider),\n      );\n      isWindowOpenedByFn = true;\n    }\n    if (!win) {\n      throw new Error(\"Something went wrong opening pop-up\");\n    }\n    // logout the user\n    // fetch the url to open the login window from iframe\n    const [{ loginLink }] = await Promise.all([\n      this.getOauthLoginUrl(args.oauthProvider),\n      this.preLogin(),\n    ]);\n    win.location.href = loginLink;\n    // listen to result from the login window\n    const result = await new Promise<AuthAndWalletRpcReturnType>(\n      (resolve, reject) => {\n        // detect when the user closes the login window\n        const pollTimer = window.setInterval(async () => {\n          if (!win) {\n            return;\n          }\n          if (win.closed) {\n            clearInterval(pollTimer);\n            window.removeEventListener(\"message\", messageListener);\n            reject(new Error(\"User closed login window\"));\n          }\n        }, 1000);\n\n        const messageListener = async (\n          event: MessageEvent<{\n            eventType: string;\n            authResult?: AuthAndWalletRpcReturnType;\n            error?: string;\n          }>,\n        ) => {\n          if (event.origin !== this.baseUrl) {\n            return;\n          }\n          if (typeof event.data !== \"object\") {\n            reject(new Error(\"Invalid event data\"));\n            return;\n          }\n\n          switch (event.data.eventType) {\n            case \"userLoginSuccess\": {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow,\n              });\n              if (event.data.authResult) {\n                resolve(event.data.authResult);\n              }\n              break;\n            }\n            case \"userLoginFailed\": {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow,\n              });\n              reject(new Error(event.data.error));\n              break;\n            }\n            case \"injectDeveloperClientId\": {\n              win?.postMessage(\n                {\n                  eventType: \"injectDeveloperClientIdResult\",\n                  developerClientId: this.client.clientId,\n                  authOption: args.oauthProvider,\n                  partnerId: this.ecosystem?.partnerId,\n                  ecosystemId: this.ecosystem?.id,\n                },\n                this.baseUrl,\n              );\n              break;\n            }\n          }\n        };\n        window.addEventListener(\"message\", messageListener);\n      },\n    );\n\n    return this.postLogin({\n      storedToken: { ...result.storedToken, shouldStoreCookieString: true },\n      walletDetails: { ...result.walletDetails, isIframeStorageEnabled: false },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomJwt({\n    encryptionKey,\n    jwt,\n  }: LoginQuerierTypes[\"loginWithCustomJwt\"]): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomJwt\",\n      params: { encryptionKey, jwt },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomAuthEndpoint({\n    encryptionKey,\n    payload,\n  }: LoginQuerierTypes[\"loginWithCustomAuthEndpoint\"]): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomAuthEndpoint\",\n      params: { encryptionKey, payload },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async verifyEmailLoginOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebEmailLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebEmailLoginOtp\",\n      params: { email, otp, recoveryCode },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async verifySmsLoginOtp({\n    phoneNumber,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebSmsLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebSmsLoginOtp\",\n      params: { phoneNumber, otp, recoveryCode },\n    });\n    return this.postLogin(result);\n  }\n}\n", "import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthStoredTokenWithCookieReturnType,\n  LogoutReturnType,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/type.js\";\nimport type { ClientIdWithQuerierType, Ecosystem } from \"../../types.js\";\nimport { LocalStorage } from \"../../utils/Storage/LocalStorage.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { BaseLogin } from \"./base-login.js\";\n\nexport type AuthQuerierTypes = {\n  logout: undefined;\n  initIframe: {\n    partnerId?: string;\n    ecosystemId?: string;\n    clientId: string;\n    authCookie: string;\n    walletUserId: string;\n    deviceShareStored: string;\n  };\n  loginWithStoredTokenDetails: {\n    storedToken: AuthStoredTokenWithCookieReturnType[\"storedToken\"];\n    recoveryCode?: string;\n  };\n};\n\n/**\n *\n */\nexport class Auth {\n  protected client: ThirdwebClient;\n  protected AuthQuerier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n  protected localStorage: LocalStorage;\n  protected onAuthSuccess: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  private BaseLogin: BaseLogin;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * @internal\n   */\n  constructor({\n    client,\n    querier,\n    onAuthSuccess,\n    ecosystem,\n    baseUrl,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    ecosystem?: Ecosystem;\n    onAuthSuccess: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n  }) {\n    this.client = client;\n\n    this.AuthQuerier = querier;\n    this.localStorage = new LocalStorage({\n      clientId: client.clientId,\n      ecosystemId: ecosystem?.id,\n    });\n    this.onAuthSuccess = onAuthSuccess;\n    this.BaseLogin = new BaseLogin({\n      postLogin: async (result) => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      ecosystem,\n      querier: querier,\n      client,\n      baseUrl,\n    });\n  }\n\n  private async preLogin() {\n    await this.logout();\n  }\n\n  private async postLogin({\n    storedToken,\n    walletDetails,\n  }: AuthAndWalletRpcReturnType): Promise<AuthLoginReturnType> {\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails,\n    });\n    return initializedUser;\n  }\n\n  async loginWithAuthToken(\n    authToken: AuthStoredTokenWithCookieReturnType,\n    recoveryCode?: string,\n  ): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithStoredTokenDetails\",\n      params: {\n        storedToken: authToken.storedToken,\n        recoveryCode,\n      },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n   * @example\n   * ```typescript\n   * const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await thirdwebInAppWallet.auth.loginWithModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   * ```\n   * @returns `{{user: InitializedUser}}` An InitializedUser object.\n   */\n  async loginWithModal(): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithModal();\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet using email OTP\n   * @example\n   * ```typescript\n   *  // Basic Flow\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await thirdwebInAppWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   * ```\n   * @param args - args.email: We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{user: InitializedUser}}` An InitializedUser object. See {@link InAppWalletSdk.getUser} for more\n   */\n  async loginWithEmailOtp(\n    args: Parameters<BaseLogin[\"loginWithEmailOtp\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithEmailOtp(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomJwt(\n    args: Parameters<BaseLogin[\"loginWithCustomJwt\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomJwt(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomAuthEndpoint(\n    args: Parameters<BaseLogin[\"loginWithCustomAuthEndpoint\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomAuthEndpoint(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithOauth(\n    args: Parameters<BaseLogin[\"loginWithOauth\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithOauth(args);\n  }\n\n  /**\n   * A headless way to send the users at the passed email an OTP code.\n   * You need to then call {@link Auth.verifyEmailLoginOtp} in order to complete the login process\n   * @example\n   * @param param0.email\n   * ```typescript\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    await thirdwebInAppWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await thirdwebInAppWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   * ```\n   * @param param0 - param0.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{ isNewUser: boolean }}` IsNewUser indicates if the user is a new user to your platform\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: Parameters<\n    BaseLogin[\"sendEmailLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendEmailLoginOtp({\n      email,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: Parameters<\n    BaseLogin[\"sendSmsLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendSmsLoginOtp({\n      phoneNumber,\n    });\n  }\n\n  /**\n   * Used to verify the otp that the user receives from thirdweb\n   *\n   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n   * @param args - props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * props.otp The code that the user received in their email\n   * @returns `{{user: InitializedUser}}` An InitializedUser object containing the user's status, wallet, authDetails, and more\n   * @internal\n   */\n  async verifyEmailLoginOtp(\n    args: Parameters<BaseLogin[\"verifyEmailLoginOtp\"]>[0],\n  ) {\n    return this.BaseLogin.verifyEmailLoginOtp(args);\n  }\n\n  /**\n   * @internal\n   */\n  async verifySmsLoginOtp(args: Parameters<BaseLogin[\"verifySmsLoginOtp\"]>[0]) {\n    return this.BaseLogin.verifySmsLoginOtp(args);\n  }\n\n  /**\n   * Logs any existing user out of their wallet.\n   * @returns `{{success: boolean}}` true if a user is successfully logged out. false if there's no user currently logged in.\n   * @internal\n   */\n  async logout(): Promise<LogoutReturnType> {\n    const { success } = await this.AuthQuerier.call<LogoutReturnType>({\n      procedureName: \"logout\",\n      params: undefined,\n    });\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n\n    return {\n      success: success || isRemoveAuthCookie || isRemoveUserId,\n    };\n  }\n}\n", "import { getThirdwebBaseUrl } from \"../../utils/domains.js\";\nimport type { EcosystemPermssions } from \"../in-app/web/types.js\";\nimport type { EcosystemWalletId } from \"../wallet-types.js\";\n\nexport const getEcosystemPartnerPermissions = async (\n  ecosystemId: EcosystemWalletId,\n  partnerId?: string,\n): Promise<EcosystemPermssions> => {\n  const res = await fetch(\n    `${getThirdwebBaseUrl(\n      \"inAppWallet\",\n    )}/api/2024-05-05/ecosystem-wallet/${ecosystemId}/partner/${partnerId}`,\n    {\n      headers: {\n        \"x-ecosystem-id\": ecosystemId,\n        \"x-ecosystem-partner-id\": partnerId || \"\",\n      },\n    },\n  );\n\n  const data = (await res.json()) as EcosystemPermssions;\n\n  return data;\n};\n", "import type * as ethers5 from \"ethers5\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { type Hex, hexToString } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parseTypedData.js\";\nimport type { Prettify } from \"../../../../utils/type-utils.js\";\nimport { getEcosystemPartnerPermissions } from \"../../../ecosystem/get-ecosystem-partner-permissions.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport {\n  type GetUser,\n  type GetUserWalletStatusRpcReturnType,\n  type SetUpWalletRpcReturnType,\n  UserWalletStatus,\n  type WalletAddressObjectType,\n} from \"../../core/authentication/type.js\";\nimport type {\n  ClientIdWithQuerierType,\n  Ecosystem,\n  GetAddressReturnType,\n  SignMessageReturnType,\n  SignTransactionReturnType,\n  SignedTypedDataReturnType,\n} from \"../types.js\";\nimport { LocalStorage } from \"../utils/Storage/LocalStorage.js\";\nimport type { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\nexport type WalletManagementTypes = {\n  createWallet: undefined;\n  setUpNewDevice: undefined;\n  getUserStatus: undefined;\n};\nexport type WalletManagementUiTypes = {\n  createWalletUi: undefined;\n  setUpNewDeviceUi: undefined;\n};\n\nexport type InAppWalletInternalHelperType = { showUi: boolean };\n\nexport type SignerProcedureTypes = {\n  getAddress: undefined;\n  signMessage: {\n    message: string | Hex;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTransaction: {\n    transaction: ethers5.ethers.providers.TransactionRequest;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTypedDataV4: {\n    domain: TypedDataDefinition[\"domain\"];\n    types: TypedDataDefinition[\"types\"];\n    message: TypedDataDefinition[\"message\"];\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  //connect: { provider: Provider };\n};\n\ntype PostWalletSetup = SetUpWalletRpcReturnType & {\n  walletUserId: string;\n};\n\n/**\n *\n */\nexport class IFrameWallet {\n  public client: ThirdwebClient;\n  public ecosystem?: Ecosystem;\n  protected walletManagerQuerier: InAppWalletIframeCommunicator<\n    WalletManagementTypes & WalletManagementUiTypes\n  >;\n  protected localStorage: LocalStorage;\n\n  /**\n   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n   * @internal\n   */\n  constructor({\n    client,\n    ecosystem,\n    querier,\n  }: Prettify<\n    ClientIdWithQuerierType & {\n      ecosystem?: Ecosystem;\n    }\n  >) {\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.walletManagerQuerier = querier;\n\n    this.localStorage = new LocalStorage({\n      clientId: client.clientId,\n      ecosystemId: ecosystem?.id,\n    });\n  }\n\n  /**\n   * Used to set-up the user device in the case that they are using incognito\n   * @returns `{walletAddress : string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp({\n    deviceShareStored,\n    walletAddress,\n    isIframeStorageEnabled,\n    walletUserId,\n  }: PostWalletSetup): Promise<WalletAddressObjectType> {\n    if (!isIframeStorageEnabled) {\n      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);\n    }\n    return { walletAddress };\n  }\n\n  /**\n   * Gets the various status states of the user\n   * @example\n   * ```typescript\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   *```\n   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n   * @internal\n   */\n  async getUserWalletStatus(): Promise<GetUser> {\n    const userStatus =\n      await this.walletManagerQuerier.call<GetUserWalletStatusRpcReturnType>({\n        procedureName: \"getUserStatus\",\n        params: undefined,\n      });\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n        ...userStatus.user,\n        account: await this.getAccount(),\n      };\n    }\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_NEW_DEVICE) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,\n        ...userStatus.user,\n      };\n    }\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,\n        ...userStatus.user,\n      };\n    }\n    // Logged out\n    return { status: userStatus.status };\n  }\n\n  /**\n   * Returns an account that communicates with the iFrame for signing operations\n   * @internal\n   */\n  async getAccount(): Promise<Account> {\n    const querier = this\n      .walletManagerQuerier as unknown as InAppWalletIframeCommunicator<SignerProcedureTypes>;\n    const client = this.client;\n    const partnerId = this.ecosystem?.partnerId;\n    const isEcosystem = !!this.ecosystem;\n\n    const permissions = this.ecosystem?.partnerId\n      ? await getEcosystemPartnerPermissions(\n          this.ecosystem.id,\n          this.ecosystem?.partnerId,\n        )\n      : undefined;\n\n    const { address } = await querier.call<GetAddressReturnType>({\n      procedureName: \"getAddress\",\n      params: undefined,\n    });\n    const _signTransaction = async (tx: SendTransactionOption) => {\n      // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n      const transaction: Record<string, any> = {\n        to: tx.to ?? undefined,\n        data: tx.data,\n        value: tx.value,\n        gasLimit: tx.gas,\n        nonce: tx.nonce,\n        chainId: tx.chainId,\n      };\n      if (tx.maxFeePerGas) {\n        // ethers (in the iframe) rejects any type 0 trasaction with unknown keys\n        // TODO remove this once iframe is upgraded to v5\n        transaction.accessList = tx.accessList;\n        transaction.maxFeePerGas = tx.maxFeePerGas;\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice;\n        transaction.type = 0;\n      }\n      const { signedTransaction } =\n        await querier.call<SignTransactionReturnType>({\n          procedureName: \"signTransaction\",\n          params: {\n            transaction,\n            chainId: tx.chainId,\n            partnerId,\n            rpcEndpoint: `https://${tx.chainId}.rpc.thirdweb.com`, // TODO (ew) shouldnt be needed\n          },\n          // Can hide the iframe if the partner has full control (no user approvals)\n          showIframe: permissions?.permissions.includes(\"FULL_CONTROL_V1\")\n            ? false\n            : isEcosystem,\n        });\n      return signedTransaction as Hex;\n    };\n    return {\n      address,\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction({\n          ...tx,\n          chainId: tx.chainId,\n        });\n      },\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          client,\n          chain: getCachedChain(tx.chainId),\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(\n          rpcRequest,\n          signedTx,\n        );\n        return {\n          transactionHash,\n        };\n      },\n      async signMessage({ message }) {\n        // in-app wallets use ethers to sign messages, which always expects a string (or bytes maybe but string is safest)\n        const messageDecoded = (() => {\n          if (typeof message === \"string\") {\n            return message;\n          }\n          if (message.raw instanceof Uint8Array) {\n            return message.raw;\n          }\n          return hexToString(message.raw);\n        })();\n\n        const { signedMessage } = await querier.call<SignMessageReturnType>({\n          procedureName: \"signMessage\",\n          params: {\n            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n            message: messageDecoded as any, // needs bytes or string\n            partnerId,\n            chainId: 1, // TODO check if we need this\n          },\n          // Can hide the iframe if the partner has full control (no user approvals)\n          showIframe: permissions?.permissions.includes(\"FULL_CONTROL_V1\")\n            ? false\n            : isEcosystem,\n        });\n        return signedMessage as Hex;\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n        // this happens when going from viem to ethers via the iframe\n        if (parsedTypedData.types?.EIP712Domain) {\n          parsedTypedData.types.EIP712Domain = undefined;\n        }\n        const domain = parsedTypedData.domain as TypedDataDefinition[\"domain\"];\n        const chainId = domain?.chainId || 1;\n\n        const { signedTypedData } =\n          await querier.call<SignedTypedDataReturnType>({\n            procedureName: \"signTypedDataV4\",\n            params: {\n              domain: {\n                chainId: chainId,\n                verifyingContract: domain?.verifyingContract,\n                name: domain?.name,\n                version: domain?.version,\n              },\n              types:\n                parsedTypedData.types as SignerProcedureTypes[\"signTypedDataV4\"][\"types\"],\n              message:\n                parsedTypedData.message as SignerProcedureTypes[\"signTypedDataV4\"][\"message\"],\n              chainId,\n              partnerId,\n              rpcEndpoint: `https://${chainId}.rpc.thirdweb.com`, // TODO (ew) shouldnt be needed\n            },\n            // Can hide the iframe if the partner has full control (no user approvals)\n            showIframe: permissions?.permissions.includes(\"FULL_CONTROL_V1\")\n              ? false\n              : isEcosystem,\n          });\n        return signedTypedData as Hex;\n      },\n    };\n  }\n}\n", "import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\nimport {\n  type AuthLoginReturnType,\n  type GetUser,\n  type LogoutReturnType,\n  type MultiStepAuthArgsType,\n  type MultiStepAuthProviderType,\n  type SendEmailOtpReturnType,\n  type SingleStepAuthArgsType,\n  UserWalletStatus,\n  oauthStrategyToAuthProvider,\n} from \"../../core/authentication/type.js\";\nimport type { InAppConnector } from \"../../core/interfaces/connector.js\";\nimport type { InAppWalletConstructorType } from \"../types.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth, type AuthQuerierTypes } from \"./auth/iframe-auth.js\";\nimport { loginWithPasskey, registerPasskey } from \"./auth/passkeys.js\";\nimport { IFrameWallet } from \"./in-app-account.js\";\n\n/**\n * @internal\n */\nexport class InAppWebConnector implements InAppConnector {\n  protected client: ThirdwebClient;\n  protected querier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n\n  private wallet: IFrameWallet;\n  /**\n   * Used to manage the Auth state of the user.\n   */\n  auth: Auth;\n\n  private isClientIdLegacyPaper(clientId: string): boolean {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @example\n   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n   * @internal\n   */\n  constructor({\n    client,\n    onAuthSuccess,\n    ecosystem,\n  }: InAppWalletConstructorType) {\n    if (this.isClientIdLegacyPaper(client.clientId)) {\n      throw new Error(\n        \"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\",\n      );\n    }\n    const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n    this.client = client;\n    this.querier = new InAppWalletIframeCommunicator({\n      clientId: client.clientId,\n      ecosystem,\n      baseUrl,\n    });\n    this.wallet = new IFrameWallet({\n      client,\n      ecosystem,\n      querier: this.querier,\n    });\n\n    this.auth = new Auth({\n      client,\n      querier: this.querier,\n      baseUrl,\n      ecosystem,\n      onAuthSuccess: async (authResult) => {\n        onAuthSuccess?.(authResult);\n        await this.wallet.postWalletSetUp({\n          ...authResult.walletDetails,\n          walletUserId: authResult.storedToken.authDetails.userWalletId,\n        });\n        await this.querier.call({\n          procedureName: \"initIframe\",\n          params: {\n            partnerId: ecosystem?.partnerId,\n            ecosystemId: ecosystem?.id,\n            deviceShareStored: authResult.walletDetails.deviceShareStored,\n            clientId: this.client.clientId,\n            walletUserId: authResult.storedToken.authDetails.userWalletId,\n            authCookie: authResult.storedToken.cookieString,\n          },\n        });\n        return {\n          user: {\n            status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n            authDetails: authResult.storedToken.authDetails,\n            account: await this.wallet.getAccount(),\n            walletAddress: authResult.walletDetails.walletAddress,\n          },\n        };\n      },\n    });\n  }\n\n  /**\n   * Gets the usr if they are logged in\n   * @example\n   * ```js\n   *  const user = await thirdwebInAppWallet.getUser();\n   *  switch (user.status) {\n   *     case UserWalletStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   * }\n   * ```\n   * @returns GetUser - an object to containing various information on the user statuses\n   */\n  async getUser(): Promise<GetUser> {\n    return this.wallet.getUserWalletStatus();\n  }\n\n  getAccount(): Promise<Account> {\n    return this.wallet.getAccount();\n  }\n\n  async preAuthenticate(\n    args: MultiStepAuthProviderType,\n  ): Promise<SendEmailOtpReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\": {\n        return this.auth.sendEmailLoginOtp({ email: args.email });\n      }\n      case \"phone\": {\n        return this.auth.sendSmsLoginOtp({ phoneNumber: args.phoneNumber });\n      }\n      default:\n        assertUnreachable(\n          strategy,\n          `Provider: ${strategy} doesn't require pre-authentication`,\n        );\n    }\n  }\n\n  async authenticate(\n    args: MultiStepAuthArgsType | SingleStepAuthArgsType,\n  ): Promise<AuthLoginReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\": {\n        return await this.auth.verifyEmailLoginOtp({\n          email: args.email,\n          otp: args.verificationCode,\n        });\n      }\n      case \"phone\": {\n        return await this.auth.verifySmsLoginOtp({\n          otp: args.verificationCode,\n          phoneNumber: args.phoneNumber,\n        });\n      }\n      case \"apple\":\n      case \"facebook\":\n      case \"google\": {\n        const oauthProvider = oauthStrategyToAuthProvider[strategy];\n        return this.auth.loginWithOauth({\n          oauthProvider,\n          closeOpenedWindow: args.closeOpenedWindow,\n          openedWindow: args.openedWindow,\n        });\n      }\n      case \"jwt\": {\n        return this.auth.loginWithCustomJwt({\n          jwt: args.jwt,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"auth_endpoint\": {\n        return this.auth.loginWithCustomAuthEndpoint({\n          payload: args.payload,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.loginWithEmailOtp({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.loginWithModal();\n      }\n      case \"passkey\": {\n        if (args.type === \"sign-up\") {\n          const authToken = await registerPasskey({\n            client: this.wallet.client,\n            ecosystem: this.wallet.ecosystem,\n            authenticatorType: args.authenticatorType,\n            username: args.passkeyName,\n          });\n          return this.auth.loginWithAuthToken(authToken);\n        }\n        const authToken = await loginWithPasskey({\n          client: this.wallet.client,\n          ecosystem: this.wallet.ecosystem,\n          authenticatorType: args.authenticatorType,\n        });\n        return this.auth.loginWithAuthToken(authToken);\n      }\n      default:\n        assertUnreachable(strategy);\n    }\n  }\n\n  async logout(): Promise<LogoutReturnType> {\n    return await this.auth.logout();\n  }\n}\n\nfunction assertUnreachable(x: never, message?: string): never {\n  throw new Error(message ?? `Invalid param: ${x}`);\n}\n"],
  "mappings": "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",
  "names": ["_a", "authToken"]
}
