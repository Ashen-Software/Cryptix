import {
  ADDRESS_ZERO
} from "./chunk-X7ZQ7JNR.js";
import {
  getContract
} from "./chunk-AOWXXJZS.js";
import {
  readContract
} from "./chunk-OEOA3HT2.js";
import "./chunk-2I6BQZFD.js";
import "./chunk-3NAETAKT.js";
import "./chunk-LW7EMTNJ.js";
import "./chunk-BSASUUNP.js";
import {
  keccak256
} from "./chunk-MQIGPFEC.js";
import {
  isHex
} from "./chunk-3JG4JMZX.js";
import "./chunk-GDDTQ4UI.js";
import "./chunk-HGWZNQ5H.js";
import {
  stringify
} from "./chunk-TRL57KBW.js";
import "./chunk-NMVKDFRL.js";
import "./chunk-MHFR2GDE.js";
import "./chunk-CVWITOXT.js";
import "./chunk-SHWHM7JY.js";
import "./chunk-EZ4JTQAA.js";
import {
  encodeAbiParameters
} from "./chunk-ZAXCNZIK.js";
import "./chunk-Z2F5LG57.js";
import "./chunk-HK3KI3RB.js";
import "./chunk-EWAXOTDC.js";
import "./chunk-TEQAYQEZ.js";
import "./chunk-SEVZ5PBP.js";

// node_modules/thirdweb/dist/esm/transaction/actions/gasless/providers/biconomy.js
var BATCH_ID = 0n;
async function prepareBiconomyTransaction({ account, serializableTransaction, transaction, gasless }) {
  const forwarderContract = getContract({
    address: gasless.relayerForwarderAddress,
    chain: transaction.chain,
    client: transaction.client
  });
  const nonce = await readContract({
    contract: forwarderContract,
    method: "function getNonce(address,uint256) view returns (uint256)",
    params: [account.address, BATCH_ID]
  });
  const deadline = Math.floor(Date.now() / 1e3) + (gasless.deadlineSeconds ?? 3600);
  const request = {
    from: account.address,
    to: serializableTransaction.to,
    token: ADDRESS_ZERO,
    txGas: serializableTransaction.gas,
    tokenGasPrice: 0n,
    batchId: BATCH_ID,
    batchNonce: nonce,
    deadline,
    data: serializableTransaction.data
  };
  if (!request.to) {
    throw new Error("Cannot send a transaction without a `to` address");
  }
  if (!request.txGas) {
    throw new Error("Cannot send a transaction without a `gas` value");
  }
  if (!request.data) {
    throw new Error("Cannot send a transaction without a `data` value");
  }
  const message = encodeAbiParameters([
    { type: "address" },
    { type: "address" },
    { type: "address" },
    { type: "uint256" },
    { type: "uint256" },
    { type: "uint256" },
    { type: "uint256" },
    { type: "bytes32" }
  ], [
    request.from,
    request.to,
    request.token,
    request.txGas,
    request.tokenGasPrice,
    request.batchId,
    request.batchNonce,
    keccak256(request.data)
  ]);
  const signature = await account.signMessage({ message });
  return [request, signature];
}
async function relayBiconomyTransaction(options) {
  var _a;
  const [request, signature] = await prepareBiconomyTransaction(options);
  const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
    method: "POST",
    body: stringify({
      apiId: options.gasless.apiId,
      params: [request, signature],
      from: request.from,
      to: request.to,
      gasLimit: request.txGas
    }),
    headers: {
      "x-api-key": options.gasless.apiKey,
      "Content-Type": "application/json;charset=utf-8"
    }
  });
  if (!response.ok) {
    (_a = response.body) == null ? void 0 : _a.cancel();
    throw new Error(`Failed to send transaction: ${await response.text()}`);
  }
  const json = await response.json();
  const transactionHash = json.txHash;
  if (isHex(transactionHash)) {
    return {
      transactionHash,
      chain: options.transaction.chain,
      client: options.transaction.client
    };
  }
  throw new Error(`Failed to send transaction: ${stringify(json)}`);
}
export {
  prepareBiconomyTransaction,
  relayBiconomyTransaction
};
//# sourceMappingURL=biconomy-GRUWBRJC.js.map
