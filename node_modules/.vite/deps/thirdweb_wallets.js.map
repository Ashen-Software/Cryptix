{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/signatures/sign.ts", "../../thirdweb/src/utils/encoding/helpers/trim.ts", "../../thirdweb/src/transaction/serialize-transaction.ts", "../../thirdweb/src/transaction/actions/sign-transaction.ts", "../../thirdweb/src/utils/signatures/signature-to-hex.ts", "../../thirdweb/src/utils/signatures/sign-message.ts", "../../thirdweb/src/utils/signatures/sign-typed-data.ts", "../../thirdweb/src/wallets/private-key.ts", "../../thirdweb/src/wallets/utils/generateAccount.ts", "../../thirdweb/src/wallets/getAllWalletsList.ts", "../../thirdweb/src/adapters/wallet-adapter.ts"],
  "sourcesContent": ["import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type { Signature } from \"viem\";\n\nimport { type Hex, toHex } from \"../encoding/hex.js\";\n\n/**\n * Options for signing a transaction hash.\n */\nexport type SignOptions = {\n  hash: Hex;\n  privateKey: Hex;\n};\n\n/**\n * Generates the signature for the provided transaction hash.\n * @param options - The options for signing.\n * @param options.hash - The hash to be signed.\n * @param options.privateKey - The private key to sign the hash with.\n * @returns The transaction signature.\n * @example\n * ```ts\n * import { sign } from \"thirdweb/utils\";\n *\n * const signature = sign({\n *   hash: \"0x\",\n *   privateKey: \"0x\",\n * });\n * ```\n * @utils\n */\nexport function sign({ hash, privateKey }: SignOptions): Signature {\n  const { r, s, recovery } = secp256k1.sign(hash.slice(2), privateKey.slice(2));\n  return {\n    r: toHex(r),\n    s: toHex(s),\n    v: recovery ? 28n : 27n,\n    yParity: recovery,\n  };\n}\n", "import type { Hex } from \"./is-hex.js\";\n\ntype TrimOptions = {\n  dir?: \"left\" | \"right\";\n};\nexport type TrimReturnType<TValue extends Uint8Array | Hex> = TValue extends Hex\n  ? Hex\n  : Uint8Array;\n\n/**\n * Trims leading or trailing zeros from a hexadecimal string or byte array.\n *\n * @param hexOrBytes - The hexadecimal string or byte array to trim.\n * @param options - The options for trimming. Default is to trim leading zeros.\n * @returns The trimmed hexadecimal string or byte array.\n * @internal\n */\nexport function trim<TValue extends Uint8Array | Hex>(\n  hexOrBytes: TValue,\n  { dir = \"left\" }: TrimOptions = {},\n): TrimReturnType<TValue> {\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  let data: any =\n    typeof hexOrBytes === \"string\" ? hexOrBytes.replace(\"0x\", \"\") : hexOrBytes;\n\n  let sliceLength = 0;\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") {\n      sliceLength++;\n    } else {\n      break;\n    }\n  }\n  data =\n    dir === \"left\"\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength);\n\n  if (typeof hexOrBytes === \"string\") {\n    if (data.length === 1 && dir === \"right\") {\n      data = `${data}0`;\n    }\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<TValue>;\n  }\n  return data as TrimReturnType<TValue>;\n}\n", "import {\n  type ExactPartial,\n  type SerializedTransactionReturnType,\n  type Signature,\n  type TransactionSerializable,\n  type TransactionSerializableEIP1559,\n  type TransactionSerializableEIP2930,\n  type TransactionSerializableEIP4844,\n  type TransactionSerializableLegacy,\n  type TransactionSerializedEIP1559,\n  type TransactionSerializedEIP2930,\n  type TransactionSerializedLegacy,\n  serializeTransaction as _serializeTransaction,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionLegacy,\n  serializeAccessList,\n  toRlp,\n} from \"viem\";\nimport { trim } from \"../utils/encoding/helpers/trim.js\";\nimport { type Hex, toHex } from \"../utils/encoding/hex.js\";\n\nexport type SerializeTransactionOptions<\n  _transaction extends TransactionSerializable,\n> = {\n  transaction: _transaction;\n};\n\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, or EIP-4844 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized, including the signature parameters if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */\nexport function serializeTransaction<\n  _transaction extends TransactionSerializable,\n>(\n  options: SerializeTransactionOptions<_transaction>,\n): SerializedTransactionReturnType<_transaction> {\n  const { transaction } = options;\n\n  if (\n    transaction.type === \"eip4844\" || // explicit type checks required for viem parity\n    typeof transaction.blobs !== \"undefined\" ||\n    typeof transaction.blobVersionedHashes !== \"undefined\" ||\n    typeof transaction.maxFeePerBlobGas !== \"undefined\" ||\n    typeof transaction.sidecars !== \"undefined\"\n  ) {\n    // default to viem's 4844 serialization until we have blob utilities\n    return _serializeTransaction<TransactionSerializableEIP4844>(\n      transaction,\n    ) as SerializedTransactionReturnType<_transaction>;\n  }\n\n  if (\n    transaction.type === \"eip1559\" ||\n    typeof transaction.maxFeePerGas !== \"undefined\" ||\n    typeof transaction.maxPriorityFeePerGas !== \"undefined\"\n  ) {\n    return serializeEIP1559Transaction({\n      transaction,\n    }) as SerializedTransactionReturnType<_transaction>;\n  }\n\n  if (\n    transaction.type === \"eip2930\" ||\n    (typeof transaction.gasPrice !== \"undefined\" &&\n      typeof transaction.accessList !== \"undefined\")\n  ) {\n    return serializeEIP2930Transaction({\n      transaction,\n    }) as SerializedTransactionReturnType<_transaction>;\n  }\n\n  if (\n    transaction.type === \"legacy\" ||\n    typeof transaction.gasPrice !== \"undefined\"\n  ) {\n    return serializeTransactionLegacy({\n      transaction: transaction as TransactionSerializableLegacy,\n    }) as SerializedTransactionReturnType<_transaction>;\n  }\n\n  throw new Error(\n    `Invalid transaction to serialize.\\n\\n${JSON.stringify(\n      transaction,\n      (_, v) => (typeof v === \"bigint\" ? `${v.toString()}n` : v),\n      2,\n    )}`,\n  );\n}\n\ntype SerializeEIP1559TransactionOptions = {\n  transaction: TransactionSerializableEIP1559;\n};\n\nfunction serializeEIP1559Transaction(\n  options: SerializeEIP1559TransactionOptions,\n): TransactionSerializedEIP1559 {\n  assertTransactionEIP1559(options.transaction);\n\n  const {\n    transaction: {\n      chainId,\n      gas,\n      nonce,\n      to,\n      value,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      accessList,\n      data,\n      r,\n      s,\n      v,\n      yParity,\n    },\n  } = options;\n\n  const serializedAccessList = serializeAccessList(accessList);\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    // To fix when migrating to our own version of TransactionSerializable (the viem type is downgraded from Address to string when importing)\n    (to ?? \"0x\") as Hex,\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x\",\n    serializedAccessList,\n    ...toYParitySignatureArray({ r, s, v, yParity }),\n  ];\n\n  return `0x02${toRlp(serializedTransaction).slice(2)}`;\n}\n\ntype SerializeEIP2930TransactionOptions = {\n  transaction: TransactionSerializableEIP2930;\n};\n\nfunction serializeEIP2930Transaction(\n  options: SerializeEIP2930TransactionOptions,\n): TransactionSerializedEIP2930 {\n  assertTransactionEIP2930(options.transaction);\n\n  const {\n    transaction: {\n      chainId,\n      gas,\n      gasPrice,\n      nonce,\n      to,\n      value,\n      accessList,\n      data,\n      r,\n      s,\n      v,\n      yParity,\n    },\n  } = options;\n\n  const serializedAccessList = serializeAccessList(accessList);\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : \"0x\",\n    gasPrice ? toHex(gasPrice) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    (to ?? \"0x\") as Hex,\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x\",\n    serializedAccessList,\n    ...toYParitySignatureArray({ r, s, v, yParity }),\n  ];\n\n  return `0x01${toRlp(serializedTransaction).slice(2)}`;\n}\n\ntype SerializeLegacyTransactionOptions = {\n  transaction: TransactionSerializableLegacy;\n};\n\nfunction serializeTransactionLegacy(\n  options: SerializeLegacyTransactionOptions,\n): TransactionSerializedLegacy {\n  assertTransactionLegacy(options.transaction);\n\n  const {\n    chainId = 0,\n    gas,\n    data,\n    nonce,\n    to,\n    value,\n    gasPrice,\n    r,\n    s,\n    v,\n  } = options.transaction;\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    gasPrice ? toHex(gasPrice) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    (to ?? \"0x\") as Hex,\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x\",\n  ];\n\n  if (typeof v !== \"undefined\") {\n    const v_ = (() => {\n      // EIP-155 (inferred chainId)\n      if (v >= 35n) {\n        const inferredChainId = (v - 35n) / 2n;\n        if (inferredChainId > 0) return v;\n        return 27n + (v === 35n ? 0n : 1n);\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0) return BigInt(chainId * 2) + BigInt(35n + v - 27n);\n\n      // Pre-EIP-155 (no chainId)\n      const v_ = 27n + (v === 27n ? 0n : 1n);\n      if (v !== v_) throw new Error(`Invalid legacy signature value v: ${v}`);\n      return v_;\n    })();\n\n    if (typeof r === \"undefined\")\n      throw new Error(`Invalid legacy signature value r: ${r}`);\n    if (typeof s === \"undefined\")\n      throw new Error(`Invalid legacy signature value s: ${s}`);\n\n    serializedTransaction = [...serializedTransaction, toHex(v_), r, s];\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      \"0x\",\n      \"0x\",\n    ];\n  }\n\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy;\n}\n\nexport function toYParitySignatureArray(\n  signature: ExactPartial<Signature>,\n): Hex[] {\n  const { r, s, v, yParity } = signature;\n  if (typeof r === \"undefined\") return [];\n  if (typeof s === \"undefined\") return [];\n  if (typeof v === \"undefined\" && typeof yParity === \"undefined\") return [];\n\n  const yParity_ = (() => {\n    if (yParity === 1 || yParity === 0) return yParity ? toHex(1) : \"0x\";\n    if (typeof yParity !== \"undefined\")\n      throw new Error(`Invalid signature value for yParity: ${yParity}`);\n\n    if (v === 0n || v === 27n) return \"0x\";\n    if (v === 1n || v === 28n) return toHex(1);\n    throw new Error(`Invalid signature value v: ${v}`);\n  })();\n  return [yParity_, trim(r), trim(s)];\n}\n", "import type { TransactionSerializable } from \"viem\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { keccak256 } from \"../../utils/hashing/keccak256.js\";\nimport { sign } from \"../../utils/signatures/sign.js\";\nimport { serializeTransaction } from \"../serialize-transaction.js\";\n\nexport type SignTransactionOptions = {\n  transaction: TransactionSerializable;\n  privateKey: Hex;\n  // TODO: Add optional custom serializer here\n};\n\n/**\n * Signs a transaction to be sent to a node.\n * @param options The options for signing.\n * @param options.transaction - The transaction object to sign\n * @param options.privateKey - The account private key\n * @returns The signed transaction as a hex string\n * @example\n * ```ts\n * import { signTransaction } from \"thirdweb\";\n * signTransaction({\n *   transaction: {\n *     ...\n *   },\n *   privateKey: \"0x...\",\n * });\n * ```\n * @transaction\n */\nexport function signTransaction({\n  transaction,\n  privateKey,\n}: SignTransactionOptions): Hex {\n  if (transaction.type === \"eip4844\") {\n    transaction = { ...transaction, sidecars: false };\n  }\n\n  const serializedTransaction = serializeTransaction({ transaction });\n\n  const signature = sign({\n    hash: keccak256(serializedTransaction),\n    privateKey: privateKey,\n  });\n  return serializeTransaction({\n    transaction: { ...transaction, ...signature },\n  });\n}\n", "import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type { Signature } from \"viem\";\nimport { type Hex, hexToBigInt } from \"../encoding/hex.js\";\n\n/**\n * Converts a signature to a hex string.\n * @param signature The signature to convert.\n * @returns The hex string representation of the signature.\n * @example\n * ```ts\n * import { signatureToHex } from \"thirdweb/utils\";\n *\n * const hex = signatureToHex({\n * r: toHex(\n * 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * ),\n * s: toHex(\n * 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * ),\n * v: 28n,\n * });\n *\n * console.log(hex);\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n * ```\n * @utils\n */\nexport function signatureToHex(signature: Signature): Hex {\n  const { r, s, v } = signature;\n  const vHex = (() => {\n    if (v === 27n) {\n      return \"1b\";\n    }\n    if (v === 28n) {\n      return \"1c\";\n    }\n    throw new Error(\"Invalid v value\");\n  })();\n\n  return `0x${new secp256k1.Signature(\n    hexToBigInt(r),\n    hexToBigInt(s),\n  ).toCompactHex()}${vHex}`;\n}\n", "import type { Hex } from \"../encoding/hex.js\";\nimport { hashMessage } from \"../hashing/hashMessage.js\";\nimport type { Prettify } from \"../type-utils.js\";\nimport { sign } from \"./sign.js\";\nimport { signatureToHex } from \"./signature-to-hex.js\";\n\nexport type SignMessageOptions = {\n  message: Prettify<\n    | string\n    | {\n        raw: Hex | Uint8Array;\n      }\n  >;\n  privateKey: Hex;\n};\n\n/**\n * Signs a string message with a given private key.\n * @param options The options for signing.\n * @param options.message The message to be signed as a string or object containing raw hex or bytes\n * @param options.privateKey The private key to be used\n * @returns The signature as a hex string\n * @example\n * ```ts\n * import { signMessage } from \"thirdweb/utils\";\n * signMessage({\n *   message: \"Hello, world!\",\n *   privateKey: \"0x...\",\n * });\n * ```\n * @utils\n */\nexport function signMessage({ message, privateKey }: SignMessageOptions): Hex {\n  const signature = sign({ hash: hashMessage(message), privateKey });\n  return signatureToHex(signature);\n}\n", "import type { TypedData } from \"abitype\";\nimport { type TypedDataDefinition, hashTypedData } from \"viem\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { parseTypedData } from \"./helpers/parseTypedData.js\";\nimport { sign } from \"./sign.js\";\nimport { signatureToHex } from \"./signature-to-hex.js\";\n\nexport type SignTypedDataOptions<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  privateKey: Hex;\n};\n\n/**\n * Signs a typed data object with a given private key according to EIP712.\n * @param options The typed data is passed within options alongside the private key\n * @param options.privateKey The private key to sign the typed data with\n * @returns The signature as a hex string\n * @example\n * ```ts\n * import { signTypedData } from \"thirdweb/utils\";\n * signTypedData({\n *   privateKey: \"0x...\",\n *   ...typedData\n * });\n * ```\n * @utils\n */\nexport function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>(options: SignTypedDataOptions<typedData, primaryType>): Hex {\n  const { privateKey, ...typedData } =\n    options as unknown as SignTypedDataOptions;\n\n  const parsedTypeData = parseTypedData(typedData);\n\n  const signature = sign({\n    hash: hashTypedData(parsedTypeData), // TODO: Implement native hashTypedData\n    privateKey,\n  });\n  return signatureToHex(signature);\n}\n", "import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type {\n  SignableMessage,\n  TransactionSerializable,\n  TypedData,\n  TypedDataDefinition,\n} from \"viem\";\nimport { publicKeyToAddress } from \"viem/utils\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_sendRawTransaction } from \"../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { signTransaction } from \"../transaction/actions/sign-transaction.js\";\nimport { type Hex, toHex } from \"../utils/encoding/hex.js\";\nimport { signMessage } from \"../utils/signatures/sign-message.js\";\nimport { signTypedData } from \"../utils/signatures/sign-typed-data.js\";\nimport type { Account } from \"./interfaces/wallet.js\";\n\nexport type PrivateKeyToAccountOptions = {\n  /**\n   * A client is the entry point to the thirdweb SDK.\n   * It is required for all other actions.\n   * You can create a client using the `createThirdwebClient` function. Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   *\n   * You must provide a `clientId` or `secretKey` in order to initialize a client. Pass `clientId` if you want for client-side usage and `secretKey` for server-side usage.\n   *\n   * ```tsx\n   * import { createThirdwebClient } from \"thirdweb\";\n   *\n   * const client = createThirdwebClient({\n   *  clientId: \"<your_client_id>\",\n   * })\n   * ```\n   */\n  client: ThirdwebClient;\n\n  /**\n   * The private key to use for the account.\n   *\n   * Do not commit private key in your code and use environment variables or other secure methods to store the private key.\n   * @example\n   * ```ts\n   * const privateKey = process.env.PRIVATE_KEY;\n   * ```\n   */\n  privateKey: string;\n};\n\n/**\n * Get an `Account` object from a private key.\n * @param options - The options for `privateKeyToAccount`\n * Refer to the type [`PrivateKeyToAccountOptions`](https://portal.thirdweb.com/references/typescript/v5/PrivateKeyToAccountOptions)\n * @returns The `Account` object that represents the private key\n * @example\n * ```ts\n * import { privateKeyToAccount } from \"thirdweb/wallets\"\n *\n * const wallet = privateKeyToAccount({\n *  client,\n *  privateKey: \"...\",\n * });\n * ```\n * @wallet\n */\nexport function privateKeyToAccount(\n  options: PrivateKeyToAccountOptions,\n): Account {\n  const { client } = options;\n  const privateKey = `0x${options.privateKey.replace(/^0x/, \"\")}` satisfies Hex;\n\n  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));\n  const address = publicKeyToAddress(publicKey); // TODO: Implement publicKeyToAddress natively (will need checksumAddress downstream)\n\n  const account = {\n    address,\n    sendTransaction: async (\n      // TODO: figure out how we would pass our \"chain\" object in here?\n      // maybe we *do* actually have to take in a tx object instead of the raw tx?\n      tx: TransactionSerializable & { chainId: number },\n    ) => {\n      const rpcRequest = getRpcClient({\n        client: client,\n        chain: getCachedChain(tx.chainId),\n      });\n      const signedTx = signTransaction({\n        transaction: tx,\n        privateKey,\n      });\n      const transactionHash = await eth_sendRawTransaction(\n        rpcRequest,\n        signedTx,\n      );\n      return {\n        transactionHash,\n      };\n    },\n    signMessage: async ({ message }: { message: SignableMessage }) => {\n      return signMessage({\n        message,\n        privateKey,\n      });\n    },\n    signTypedData: async <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      _typedData: TypedDataDefinition<typedData, primaryType>,\n    ) => {\n      return signTypedData({\n        ..._typedData,\n        privateKey,\n      });\n    },\n    signTransaction: async (tx: TransactionSerializable) => {\n      return signTransaction({\n        transaction: tx,\n        privateKey,\n      });\n    },\n  };\n\n  return account satisfies Account;\n}\n", "import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport type { Account } from \"../interfaces/wallet.js\";\nimport { privateKeyToAccount } from \"../private-key.js\";\n\nexport type GenerateAccountOptions = {\n  client: ThirdwebClient;\n};\n\n/**\n * Generates a new account with a random private key.\n * @param options - The options for generating the account.\n * @param options.client - The Thirdweb client to use for the generated account.\n * @returns A Thirdweb account.\n * @example\n * ```ts\n * import { generateAccount } from \"thirdweb/wallets\";\n * const account = await generateAccount({ client });\n * ```\n * @walletUtils\n */\nexport async function generateAccount(\n  options: GenerateAccountOptions,\n): Promise<Account> {\n  const privateKey = toHex(secp256k1.utils.randomPrivateKey());\n  return privateKeyToAccount({ privateKey, client: options.client });\n}\n", "/**\n * Hide it for documentation - but expose it because we will use this to render the list of wallets in docs website\n * Using dynamic import just to be extra safe and avoid any tree shaking issues\n * @internal\n */\nexport async function getAllWalletsList() {\n  return (await import(\"./__generated__/wallet-infos.js\")).default;\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Account, Wallet } from \"../wallets/interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../wallets/wallet-emitter.js\";\n\nexport type AdapterWalletOptions = {\n  client: ThirdwebClient;\n  adaptedAccount: Account;\n  chain: Chain;\n  onDisconnect: () => Promise<void> | void;\n  switchChain: (chain: Chain) => Promise<void> | void;\n};\n\n/**\n * Creates a wallet from the given adapted account. Use this to convert a third party library wallet into a thirdweb wallet.\n * @param options - The options for the adapter wallet.\n * @returns a wallet instance.\n *\n * @example\n * ```ts\n * import { createWalletAdapter } from \"thirdweb\";\n *\n * const wallet = createWalletAdapter({\n *  client,\n *  adaptedAccount,\n *  chain,\n *  onDisconnect: () => {\n *    // disconnect logic\n *  },\n *  switchChain: async (chain) => {\n *    // switch chain logic\n *  },\n * });\n * ```\n * @wallet\n */\nexport function createWalletAdapter(\n  options: AdapterWalletOptions,\n): Wallet<\"adapter\"> {\n  const emitter = createWalletEmitter<\"adapter\">();\n  let _chain = options.chain;\n  return {\n    id: \"adapter\",\n    subscribe: emitter.subscribe,\n    connect: async () => {\n      emitter.emit(\"onConnect\", options);\n      return options.adaptedAccount;\n    },\n    autoConnect: async () => {\n      emitter.emit(\"onConnect\", options);\n      return options.adaptedAccount;\n    },\n    disconnect: async () => {\n      await options.onDisconnect();\n      emitter.emit(\"disconnect\", undefined);\n    },\n    getAccount() {\n      return options.adaptedAccount;\n    },\n    getChain() {\n      return _chain;\n    },\n    getConfig() {\n      return options;\n    },\n    switchChain: async (chain) => {\n      await options.switchChain(chain);\n      _chain = chain;\n      emitter.emit(\"chainChanged\", chain);\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["serializeTransaction", "v_", "serializeTransaction"]
}
