import {
  getSavedConnectParamsFromStorage,
  saveConnectParamsToStorage
} from "./chunk-RMLEFI72.js";
import {
  getWalletInfo
} from "./chunk-SPFRZDZE.js";
import {
  DEFAULT_PROJECT_ID,
  NAMESPACE
} from "./chunk-67YIWUOQ.js";
import {
  getDefaultAppMetadata
} from "./chunk-P4YNF73V.js";
import {
  getValidPublicRPCUrl,
  normalizeChainId
} from "./chunk-CXUCCAWN.js";
import {
  parseTypedData
} from "./chunk-NPZ6GJMS.js";
import {
  getAddress
} from "./chunk-LW7EMTNJ.js";
import {
  getTypesForEIP712Domain,
  serializeTypedData,
  validateTypedData
} from "./chunk-BSASUUNP.js";
import {
  numberToHex,
  stringToHex,
  uint8ArrayToHex
} from "./chunk-3JG4JMZX.js";
import {
  getCachedChain,
  getChainMetadata,
  getRpcUrlForChain
} from "./chunk-NMVKDFRL.js";
import {
  SwitchChainError,
  UserRejectedRequestError
} from "./chunk-ZAXCNZIK.js";

// node_modules/thirdweb/dist/esm/utils/url.js
function isHttpUrl(url) {
  return url.startsWith("http://") || url.startsWith("https://");
}
function formatUniversalUrl(appUrl, wcUri) {
  if (!isHttpUrl(appUrl)) {
    return formatNativeUrl(appUrl, wcUri);
  }
  let safeAppUrl = appUrl;
  if (!safeAppUrl.endsWith("/")) {
    safeAppUrl = `${safeAppUrl}/`;
  }
  const encodedWcUrl = encodeURIComponent(wcUri);
  return {
    redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
    href: safeAppUrl
  };
}
function formatNativeUrl(appUrl, wcUri) {
  if (isHttpUrl(appUrl)) {
    return formatUniversalUrl(appUrl, wcUri);
  }
  let safeAppUrl = appUrl;
  if (!safeAppUrl.includes("://")) {
    safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
    safeAppUrl = `${safeAppUrl}://`;
  }
  if (!safeAppUrl.endsWith("/")) {
    safeAppUrl = `${safeAppUrl}/`;
  }
  const encodedWcUrl = encodeURIComponent(wcUri);
  return {
    redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
    href: safeAppUrl
  };
}
function formatWalletConnectUrl(appUrl, wcUri) {
  return isHttpUrl(appUrl) ? formatUniversalUrl(appUrl, wcUri) : formatNativeUrl(appUrl, wcUri);
}

// node_modules/thirdweb/dist/esm/wallets/wallet-connect/controller.js
var ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
var defaultShowQrModal = true;
var storageKeys = {
  requestedChains: "tw.wc.requestedChains",
  lastUsedChainId: "tw.wc.lastUsedChainId"
};
function isWalletConnect(wallet) {
  return wallet.id === "walletConnect";
}
async function connectWC(options, emitter, walletId, storage, sessionHandler) {
  var _a, _b, _c;
  const provider = await initProvider(options, walletId, sessionHandler);
  const wcOptions = options.walletConnect;
  let { onDisplayUri } = wcOptions || {};
  if (!onDisplayUri && sessionHandler && walletId !== "walletConnect") {
    const walletInfo = await getWalletInfo(walletId);
    const deeplinkHandler = (uri) => {
      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;
      if (!appUrl) {
        throw new Error("No app url found for wallet connect to redirect to.");
      }
      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;
      sessionHandler(fullUrl);
    };
    onDisplayUri = deeplinkHandler;
  }
  if (onDisplayUri) {
    provider.events.addListener("display_uri", onDisplayUri);
  }
  const { rpcMap, chainsToRequest } = getChainsToRequest({
    client: options.client,
    chain: options.chain,
    optionalChains: (_a = options.walletConnect) == null ? void 0 : _a.optionalChains
  });
  if (provider.session) {
    await provider.connect({
      ...(wcOptions == null ? void 0 : wcOptions.pairingTopic) ? { pairingTopic: wcOptions == null ? void 0 : wcOptions.pairingTopic } : {},
      optionalChains: chainsToRequest,
      chains: options.chain ? [options.chain.id] : chainsToRequest.length > 0 ? [chainsToRequest[0]] : [1],
      rpcMap
    });
  }
  setRequestedChainsIds(chainsToRequest, storage);
  const addresses = await provider.enable();
  const address = addresses[0];
  if (!address) {
    throw new Error("No accounts found on provider.");
  }
  const providerChainId = normalizeChainId(provider.chainId);
  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);
  if (options) {
    const savedParams = {
      optionalChains: (_b = options.walletConnect) == null ? void 0 : _b.optionalChains,
      chain: options.chain,
      pairingTopic: (_c = options.walletConnect) == null ? void 0 : _c.pairingTopic
    };
    if (storage) {
      saveConnectParamsToStorage(storage, walletId, savedParams);
    }
  }
  if (wcOptions == null ? void 0 : wcOptions.onDisplayUri) {
    provider.events.removeListener("display_uri", wcOptions.onDisplayUri);
  }
  return onConnect(address, chain, provider, emitter, storage);
}
async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {
  const savedConnectParams = storage ? await getSavedConnectParamsFromStorage(storage, walletId) : null;
  const provider = await initProvider(savedConnectParams ? {
    chain: savedConnectParams.chain,
    client: options.client,
    walletConnect: {
      pairingTopic: savedConnectParams.pairingTopic,
      optionalChains: savedConnectParams.optionalChains
    }
  } : {
    client: options.client,
    walletConnect: {}
  }, walletId, sessionHandler, true);
  const address = provider.accounts[0];
  if (!address) {
    throw new Error("No accounts found on provider.");
  }
  const providerChainId = normalizeChainId(provider.chainId);
  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);
  return onConnect(address, chain, provider, emitter, storage);
}
async function initProvider(options, walletId, sessionRequestHandler, isAutoConnect = false) {
  var _a, _b, _c, _d, _e;
  const walletInfo = await getWalletInfo(walletId);
  const wcOptions = options.walletConnect;
  const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await import("./index.es-3XSS3KYB.js");
  const { rpcMap, chainsToRequest } = getChainsToRequest({
    client: options.client,
    chain: options.chain,
    optionalChains: (_a = options.walletConnect) == null ? void 0 : _a.optionalChains
  });
  const provider = await EthereumProvider.init({
    showQrModal: (wcOptions == null ? void 0 : wcOptions.showQrModal) === void 0 ? sessionRequestHandler ? false : defaultShowQrModal : wcOptions.showQrModal,
    projectId: (wcOptions == null ? void 0 : wcOptions.projectId) || DEFAULT_PROJECT_ID,
    optionalMethods: OPTIONAL_METHODS,
    optionalEvents: OPTIONAL_EVENTS,
    optionalChains: chainsToRequest,
    chains: options.chain ? [options.chain.id] : chainsToRequest.length > 0 ? [chainsToRequest[0]] : [1],
    metadata: {
      name: ((_b = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _b.name) || getDefaultAppMetadata().name,
      description: ((_c = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _c.description) || getDefaultAppMetadata().description,
      url: ((_d = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _d.url) || getDefaultAppMetadata().url,
      icons: [
        ((_e = wcOptions == null ? void 0 : wcOptions.appMetadata) == null ? void 0 : _e.logoUrl) || getDefaultAppMetadata().logoUrl
      ]
    },
    rpcMap,
    qrModalOptions: wcOptions == null ? void 0 : wcOptions.qrModalOptions,
    disableProviderPing: true
  });
  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);
  if (!isAutoConnect) {
    if (provider.session) {
      await provider.disconnect();
    }
  }
  if (walletId !== "walletConnect") {
    let handleSessionRequest = function() {
      var _a2, _b2, _c2, _d2;
      const walletLinkToOpen = ((_d2 = (_c2 = (_b2 = (_a2 = provider.session) == null ? void 0 : _a2.peer) == null ? void 0 : _b2.metadata) == null ? void 0 : _c2.redirect) == null ? void 0 : _d2.native) || walletInfo.mobile.native || walletInfo.mobile.universal;
      if (sessionRequestHandler && walletLinkToOpen) {
        sessionRequestHandler(walletLinkToOpen);
      }
    };
    provider.signer.client.on("session_request_sent", handleSessionRequest);
    provider.events.addListener("disconnect", () => {
      provider.signer.client.off("session_request_sent", handleSessionRequest);
    });
  }
  return provider;
}
function createAccount(provider, address) {
  const account = {
    address,
    async sendTransaction(tx) {
      const transactionHash = await provider.request({
        method: "eth_sendTransaction",
        params: [
          {
            gas: tx.gas ? numberToHex(tx.gas) : void 0,
            value: tx.value ? numberToHex(tx.value) : void 0,
            from: this.address,
            to: tx.to,
            data: tx.data
          }
        ]
      });
      return {
        transactionHash
      };
    },
    async signMessage({ message }) {
      const messageToSign = (() => {
        if (typeof message === "string") {
          return stringToHex(message);
        }
        if (message.raw instanceof Uint8Array) {
          return uint8ArrayToHex(message.raw);
        }
        return message.raw;
      })();
      return provider.request({
        method: "personal_sign",
        params: [messageToSign, this.address]
      });
    },
    async signTypedData(_data) {
      const data = parseTypedData(_data);
      const { domain, message, primaryType } = data;
      const types = {
        EIP712Domain: getTypesForEIP712Domain({ domain }),
        ...data.types
      };
      validateTypedData({ domain, message, primaryType, types });
      const typedData = serializeTypedData({
        domain: domain ?? {},
        message,
        primaryType,
        types
      });
      return await provider.request({
        method: "eth_signTypedData_v4",
        params: [this.address, typedData]
      });
    }
  };
  return account;
}
function onConnect(address, chain, provider, emitter, storage) {
  const account = createAccount(provider, address);
  async function disconnect() {
    provider.removeListener("accountsChanged", onAccountsChanged);
    provider.removeListener("chainChanged", onChainChanged);
    provider.removeListener("disconnect", onDisconnect);
    await provider.disconnect();
  }
  function onDisconnect() {
    setRequestedChainsIds([], storage);
    storage == null ? void 0 : storage.removeItem(storageKeys.lastUsedChainId);
    disconnect();
    emitter.emit("disconnect", void 0);
  }
  function onAccountsChanged(accounts) {
    if (accounts[0]) {
      const newAccount = createAccount(provider, getAddress(accounts[0]));
      emitter.emit("accountChanged", newAccount);
      emitter.emit("accountsChanged", accounts);
    } else {
      onDisconnect();
    }
  }
  function onChainChanged(newChainId) {
    const newChain = getCachedChain(normalizeChainId(newChainId));
    emitter.emit("chainChanged", newChain);
    storage == null ? void 0 : storage.setItem(storageKeys.lastUsedChainId, String(newChainId));
  }
  provider.on("accountsChanged", onAccountsChanged);
  provider.on("chainChanged", onChainChanged);
  provider.on("disconnect", onDisconnect);
  provider.on("session_delete", onDisconnect);
  return [
    account,
    chain,
    disconnect,
    (newChain) => switchChainWC(provider, newChain, storage)
  ];
}
function getNamespaceMethods(provider) {
  var _a, _b;
  return ((_b = (_a = provider.session) == null ? void 0 : _a.namespaces[NAMESPACE]) == null ? void 0 : _b.methods) || [];
}
function getNamespaceChainsIds(provider) {
  var _a, _b, _c;
  const chainIds = (_c = (_b = (_a = provider.session) == null ? void 0 : _a.namespaces[NAMESPACE]) == null ? void 0 : _b.chains) == null ? void 0 : _c.map((chain) => Number.parseInt(chain.split(":")[1] || ""));
  return chainIds ?? [];
}
async function switchChainWC(provider, chain, storage) {
  var _a, _b;
  const chainId = chain.id;
  try {
    const namespaceChains = getNamespaceChainsIds(provider);
    const namespaceMethods = getNamespaceMethods(provider);
    const isChainApproved = namespaceChains.includes(chainId);
    if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
      const apiChain = await getChainMetadata(chain);
      const blockExplorerUrls = [
        .../* @__PURE__ */ new Set([
          ...((_a = chain.blockExplorers) == null ? void 0 : _a.map((x) => x.url)) || [],
          ...((_b = apiChain.explorers) == null ? void 0 : _b.map((x) => x.url)) || []
        ])
      ];
      await provider.request({
        method: ADD_ETH_CHAIN_METHOD,
        params: [
          {
            chainId: numberToHex(apiChain.chainId),
            chainName: apiChain.name,
            nativeCurrency: apiChain.nativeCurrency,
            rpcUrls: getValidPublicRPCUrl(apiChain),
            // no clientId on purpose
            blockExplorerUrls: blockExplorerUrls.length > 0 ? blockExplorerUrls : void 0
          }
        ]
      });
      const requestedChains = await getRequestedChainsIds(storage);
      requestedChains.push(chainId);
      setRequestedChainsIds(requestedChains, storage);
    }
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: numberToHex(chainId) }]
    });
  } catch (error) {
    const message = typeof error === "string" ? error : error == null ? void 0 : error.message;
    if (/user rejected request/i.test(message)) {
      throw new UserRejectedRequestError(error);
    }
    throw new SwitchChainError(error);
  }
}
function setRequestedChainsIds(chains, storage) {
  storage == null ? void 0 : storage.setItem(storageKeys.requestedChains, JSON.stringify(chains));
}
async function getRequestedChainsIds(storage) {
  const data = await storage.getItem(storageKeys.requestedChains);
  return data ? JSON.parse(data) : [];
}
function getChainsToRequest(options) {
  const rpcMap = {};
  if (options.chain) {
    rpcMap[options.chain.id] = getRpcUrlForChain({
      chain: options.chain,
      client: options.client
    });
  }
  const optionalChains = ((options == null ? void 0 : options.optionalChains) || []).slice(0, 10);
  for (const chain of optionalChains) {
    rpcMap[chain.id] = getRpcUrlForChain({
      chain,
      client: options.client
    });
  }
  const optionalChainIds = optionalChains.map((c) => c.id) || [];
  const chainsToRequest = options.chain ? [options.chain.id, ...optionalChainIds] : optionalChainIds.length > 0 ? optionalChainIds : [1];
  if (!options.chain && optionalChains.length === 0) {
    rpcMap[1] = getCachedChain(1).rpc;
  }
  return {
    rpcMap,
    chainsToRequest
  };
}

export {
  formatWalletConnectUrl,
  isWalletConnect,
  connectWC,
  autoConnectWC
};
//# sourceMappingURL=chunk-7I5HQZW4.js.map
