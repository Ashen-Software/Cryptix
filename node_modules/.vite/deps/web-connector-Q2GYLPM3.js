import {
  loginWithPasskey,
  registerPasskey
} from "./chunk-X3XYCUUS.js";
import {
  AuthProvider,
  UserWalletStatus,
  oauthStrategyToAuthProvider
} from "./chunk-2SE7FSFE.js";
import {
  IN_APP_WALLET_PATH,
  LocalStorage
} from "./chunk-M7UJHDZW.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  parseTypedData
} from "./chunk-NPZ6GJMS.js";
import {
  hexToString
} from "./chunk-3JG4JMZX.js";
import "./chunk-GDDTQ4UI.js";
import {
  getRpcClient
} from "./chunk-HGWZNQ5H.js";
import "./chunk-TRL57KBW.js";
import {
  getCachedChain
} from "./chunk-NMVKDFRL.js";
import {
  getThirdwebBaseUrl
} from "./chunk-MHFR2GDE.js";
import "./chunk-CVWITOXT.js";
import "./chunk-SHWHM7JY.js";
import "./chunk-EZ4JTQAA.js";
import "./chunk-SEVZ5PBP.js";

// node_modules/thirdweb/dist/esm/wallets/in-app/web/utils/iFrameCommunication/IframeCommunicator.js
function sleep(seconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, seconds * 1e3);
  });
}
var iframeBaseStyle = {
  height: "100%",
  width: "100%",
  border: "none",
  backgroundColor: "transparent",
  colorScheme: "light",
  position: "fixed",
  top: "0px",
  right: "0px",
  zIndex: "2147483646",
  display: "none"
};
var isIframeLoaded = /* @__PURE__ */ new Map();
var IframeCommunicator = class {
  /**
   * @internal
   */
  constructor({ link, baseUrl, iframeId, container = document.body, onIframeInitialize }) {
    Object.defineProperty(this, "iframe", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "POLLING_INTERVAL_SECONDS", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 1.4
    });
    Object.defineProperty(this, "iframeBaseUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.iframeBaseUrl = baseUrl;
    let iframe = document.getElementById(iframeId);
    const hrefLink = new URL(link);
    if (!iframe || iframe.src !== hrefLink.href) {
      iframe = document.createElement("iframe");
      const mergedIframeStyles = {
        ...iframeBaseStyle
      };
      Object.assign(iframe.style, mergedIframeStyles);
      iframe.setAttribute("id", iframeId);
      iframe.setAttribute("fetchpriority", "high");
      container.appendChild(iframe);
      iframe.src = hrefLink.href;
      const onIframeLoaded = (event) => {
        if (event.data.eventType === "ewsIframeLoaded") {
          window.removeEventListener("message", onIframeLoaded);
          if (!iframe) {
            console.warn("thirdweb iFrame not found");
            return;
          }
          this.onIframeLoadHandler(iframe, onIframeInitialize)();
        }
      };
      window.addEventListener("message", onIframeLoaded);
    }
    this.iframe = iframe;
  }
  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
  async onIframeLoadedInitVariables() {
    return {};
  }
  /**
   * @internal
   */
  onIframeLoadHandler(iframe, onIframeInitialize) {
    return async () => {
      var _a;
      const channel = new MessageChannel();
      const promise = new Promise((res, rej) => {
        channel.port1.onmessage = (event) => {
          const { data } = event;
          channel.port1.close();
          if (!data.success) {
            rej(new Error(data.error));
          }
          isIframeLoaded.set(iframe.src, true);
          if (onIframeInitialize) {
            onIframeInitialize();
          }
          res(true);
        };
      });
      const INIT_IFRAME_EVENT = "initIframe";
      (_a = iframe == null ? void 0 : iframe.contentWindow) == null ? void 0 : _a.postMessage(
        // ? We initialise the iframe with a bunch
        // of useful information so that we don't have to pass it
        // through in each of the future call. This would be where we do it.
        {
          eventType: INIT_IFRAME_EVENT,
          data: await this.onIframeLoadedInitVariables()
        },
        this.iframeBaseUrl,
        [channel.port2]
      );
      await promise;
    };
  }
  /**
   * @internal
   */
  async call({ procedureName, params, showIframe = false }) {
    var _a;
    while (!isIframeLoaded.get(this.iframe.src)) {
      await sleep(this.POLLING_INTERVAL_SECONDS);
    }
    if (showIframe) {
      this.iframe.style.display = "block";
      await sleep(5e-3);
    }
    const channel = new MessageChannel();
    const promise = new Promise((res, rej) => {
      channel.port1.onmessage = async (event) => {
        const { data } = event;
        channel.port1.close();
        if (showIframe) {
          await sleep(0.1);
          this.iframe.style.display = "none";
        }
        if (!data.success) {
          rej(new Error(data.error));
        } else {
          res(data.data);
        }
      };
    });
    (_a = this.iframe.contentWindow) == null ? void 0 : _a.postMessage({ eventType: procedureName, data: params }, this.iframeBaseUrl, [channel.port2]);
    return promise;
  }
  /**
   * This has to be called by any iframe that will be removed from the DOM.
   * Use to make sure that we reset the global loaded state of the particular iframe.src
   * @internal
   */
  destroy() {
    isIframeLoaded.delete(this.iframe.src);
  }
};

// node_modules/thirdweb/dist/esm/wallets/in-app/web/utils/iFrameCommunication/InAppWalletIframeCommunicator.js
var InAppWalletIframeCommunicator = class extends IframeCommunicator {
  /**
   * @internal
   */
  constructor({ clientId, baseUrl, ecosystem }) {
    super({
      iframeId: IN_APP_WALLET_IFRAME_ID + ((ecosystem == null ? void 0 : ecosystem.id) || ""),
      link: createInAppWalletIframeLink({
        clientId,
        path: IN_APP_WALLET_PATH,
        ecosystem,
        baseUrl
      }).href,
      baseUrl,
      container: document.body
    });
    Object.defineProperty(this, "clientId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "ecosystem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.clientId = clientId;
    this.ecosystem = ecosystem;
  }
  /**
   * @internal
   */
  async onIframeLoadedInitVariables() {
    var _a, _b, _c;
    const localStorage = new LocalStorage({
      clientId: this.clientId,
      ecosystemId: (_a = this.ecosystem) == null ? void 0 : _a.id
    });
    return {
      authCookie: await localStorage.getAuthCookie(),
      deviceShareStored: await localStorage.getDeviceShare(),
      walletUserId: await localStorage.getWalletUserId(),
      clientId: this.clientId,
      partnerId: (_b = this.ecosystem) == null ? void 0 : _b.partnerId,
      ecosystemId: (_c = this.ecosystem) == null ? void 0 : _c.id
    };
  }
};
function createInAppWalletIframeLink({ clientId, baseUrl, path, ecosystem, queryParams }) {
  var _a;
  const inAppWalletUrl = new URL(`${path}`, baseUrl);
  if (queryParams) {
    for (const queryKey of Object.keys(queryParams)) {
      inAppWalletUrl.searchParams.set(queryKey, ((_a = queryParams[queryKey]) == null ? void 0 : _a.toString()) || "");
    }
  }
  inAppWalletUrl.searchParams.set("clientId", clientId);
  if ((ecosystem == null ? void 0 : ecosystem.partnerId) !== void 0) {
    inAppWalletUrl.searchParams.set("partnerId", ecosystem.partnerId);
  }
  if ((ecosystem == null ? void 0 : ecosystem.id) !== void 0) {
    inAppWalletUrl.searchParams.set("ecosystemId", ecosystem.id);
  }
  return inAppWalletUrl;
}
var IN_APP_WALLET_IFRAME_ID = "thirdweb-in-app-wallet-iframe";

// node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/abstract-login.js
var AbstractLogin = class {
  /**
   * Used to manage the user's auth states. This should not be instantiated directly.
   * @internal
   */
  constructor({ baseUrl, querier, preLogin, postLogin, client, ecosystem }) {
    Object.defineProperty(this, "LoginQuerier", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "preLogin", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "postLogin", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "baseUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "ecosystem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.baseUrl = baseUrl;
    this.LoginQuerier = querier;
    this.preLogin = preLogin;
    this.postLogin = postLogin;
    this.client = client;
    this.ecosystem = ecosystem;
  }
  /**
   * @internal
   */
  async sendEmailLoginOtp({ email }) {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "sendThirdwebEmailLoginOtp",
      params: { email }
    });
    return result;
  }
  /**
   *
   * @internal
   */
  async sendSmsLoginOtp({ phoneNumber }) {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "sendThirdwebSmsLoginOtp",
      params: { phoneNumber }
    });
    return result;
  }
};

// node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/base-login.js
var BaseLogin = class extends AbstractLogin {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "closeWindow", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ isWindowOpenedByFn, win, closeOpenedWindow }) => {
        if (isWindowOpenedByFn) {
          win == null ? void 0 : win.close();
        } else {
          if (win && closeOpenedWindow) {
            closeOpenedWindow(win);
          } else if (win) {
            win.close();
          }
        }
      }
    });
  }
  async getOauthLoginUrl(authProvider) {
    try {
      const result = await this.LoginQuerier.call({
        procedureName: "getHeadlessOauthLoginLink",
        params: { authProvider }
      });
      return result;
    } catch (e) {
      console.error(e);
      throw e;
    }
  }
  /**
   * @internal
   */
  async loginWithModal() {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: void 0,
      showIframe: true
    });
    return this.postLogin(result);
  }
  /**
   * @internal
   */
  async loginWithEmailOtp({ email }) {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: { email },
      showIframe: true
    });
    return this.postLogin(result);
  }
  getOauthPopUpSizing(authProvider) {
    switch (authProvider) {
      case AuthProvider.FACEBOOK:
        return "width=715, height=555";
      default:
        return "width=350, height=500";
    }
  }
  /**
   * @internal
   */
  async loginWithOauth(args) {
    let win = args == null ? void 0 : args.openedWindow;
    let isWindowOpenedByFn = false;
    if (!win) {
      win = window.open("", "Login", this.getOauthPopUpSizing(args.oauthProvider));
      isWindowOpenedByFn = true;
    }
    if (!win) {
      throw new Error("Something went wrong opening pop-up");
    }
    const [{ loginLink }] = await Promise.all([
      this.getOauthLoginUrl(args.oauthProvider),
      this.preLogin()
    ]);
    win.location.href = loginLink;
    const result = await new Promise((resolve, reject) => {
      const pollTimer = window.setInterval(async () => {
        if (!win) {
          return;
        }
        if (win.closed) {
          clearInterval(pollTimer);
          window.removeEventListener("message", messageListener);
          reject(new Error("User closed login window"));
        }
      }, 1e3);
      const messageListener = async (event) => {
        var _a, _b;
        if (event.origin !== this.baseUrl) {
          return;
        }
        if (typeof event.data !== "object") {
          reject(new Error("Invalid event data"));
          return;
        }
        switch (event.data.eventType) {
          case "userLoginSuccess": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            if (event.data.authResult) {
              resolve(event.data.authResult);
            }
            break;
          }
          case "userLoginFailed": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            reject(new Error(event.data.error));
            break;
          }
          case "injectDeveloperClientId": {
            win == null ? void 0 : win.postMessage({
              eventType: "injectDeveloperClientIdResult",
              developerClientId: this.client.clientId,
              authOption: args.oauthProvider,
              partnerId: (_a = this.ecosystem) == null ? void 0 : _a.partnerId,
              ecosystemId: (_b = this.ecosystem) == null ? void 0 : _b.id
            }, this.baseUrl);
            break;
          }
        }
      };
      window.addEventListener("message", messageListener);
    });
    return this.postLogin({
      storedToken: { ...result.storedToken, shouldStoreCookieString: true },
      walletDetails: { ...result.walletDetails, isIframeStorageEnabled: false }
    });
  }
  /**
   * @internal
   */
  async loginWithCustomJwt({ encryptionKey, jwt }) {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithCustomJwt",
      params: { encryptionKey, jwt }
    });
    return this.postLogin(result);
  }
  /**
   * @internal
   */
  async loginWithCustomAuthEndpoint({ encryptionKey, payload }) {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithCustomAuthEndpoint",
      params: { encryptionKey, payload }
    });
    return this.postLogin(result);
  }
  /**
   * @internal
   */
  async verifyEmailLoginOtp({ email, otp, recoveryCode }) {
    const result = await this.LoginQuerier.call({
      procedureName: "verifyThirdwebEmailLoginOtp",
      params: { email, otp, recoveryCode }
    });
    return this.postLogin(result);
  }
  /**
   * @internal
   */
  async verifySmsLoginOtp({ phoneNumber, otp, recoveryCode }) {
    const result = await this.LoginQuerier.call({
      procedureName: "verifyThirdwebSmsLoginOtp",
      params: { phoneNumber, otp, recoveryCode }
    });
    return this.postLogin(result);
  }
};

// node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/auth/iframe-auth.js
var Auth = class {
  /**
   * Used to manage the user's auth states. This should not be instantiated directly.
   * @internal
   */
  constructor({ client, querier, onAuthSuccess, ecosystem, baseUrl }) {
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "AuthQuerier", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "localStorage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onAuthSuccess", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "BaseLogin", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.client = client;
    this.AuthQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId: client.clientId,
      ecosystemId: ecosystem == null ? void 0 : ecosystem.id
    });
    this.onAuthSuccess = onAuthSuccess;
    this.BaseLogin = new BaseLogin({
      postLogin: async (result) => {
        return this.postLogin(result);
      },
      preLogin: async () => {
        await this.preLogin();
      },
      ecosystem,
      querier,
      client,
      baseUrl
    });
  }
  async preLogin() {
    await this.logout();
  }
  async postLogin({ storedToken, walletDetails }) {
    if (storedToken.shouldStoreCookieString) {
      await this.localStorage.saveAuthCookie(storedToken.cookieString);
    }
    const initializedUser = await this.onAuthSuccess({
      storedToken,
      walletDetails
    });
    return initializedUser;
  }
  async loginWithAuthToken(authToken, recoveryCode) {
    await this.preLogin();
    const result = await this.AuthQuerier.call({
      procedureName: "loginWithStoredTokenDetails",
      params: {
        storedToken: authToken.storedToken,
        recoveryCode
      }
    });
    return this.postLogin(result);
  }
  /**
   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers
   * @example
   * ```typescript
   * const thirdwebInAppWallet = new InAppWalletSdk({clientId: "YOUR_CLIENT_ID", chain: "Polygon"})
   * try {
   *   const user = await thirdwebInAppWallet.auth.loginWithModal();
   *   // user is now logged in
   * } catch (e) {
   *   // User closed modal or something else went wrong during the authentication process
   *   console.error(e)
   * }
   * ```
   * @returns `{{user: InitializedUser}}` An InitializedUser object.
   */
  async loginWithModal() {
    return this.BaseLogin.loginWithModal();
  }
  /**
   * Used to log the user into their thirdweb wallet using email OTP
   * @example
   * ```typescript
   *  // Basic Flow
   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: "", chain: "Polygon"});
   *  try {
   *    // prompts user to enter the code they received
   *    const user = await thirdwebInAppWallet.auth.loginWithThirdwebEmailOtp({ email : "you@example.com" });
   *    // user is now logged in
   *  } catch (e) {
   *    // User closed the OTP modal or something else went wrong during the authentication process
   *    console.error(e)
   *  }
   * ```
   * @param args - args.email: We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @returns `{{user: InitializedUser}}` An InitializedUser object. See {@link InAppWalletSdk.getUser} for more
   */
  async loginWithEmailOtp(args) {
    return this.BaseLogin.loginWithEmailOtp(args);
  }
  /**
   * @internal
   */
  async loginWithCustomJwt(args) {
    return this.BaseLogin.loginWithCustomJwt(args);
  }
  /**
   * @internal
   */
  async loginWithCustomAuthEndpoint(args) {
    return this.BaseLogin.loginWithCustomAuthEndpoint(args);
  }
  /**
   * @internal
   */
  async loginWithOauth(args) {
    return this.BaseLogin.loginWithOauth(args);
  }
  /**
   * A headless way to send the users at the passed email an OTP code.
   * You need to then call {@link Auth.verifyEmailLoginOtp} in order to complete the login process
   * @example
   * @param param0.email
   * ```typescript
   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: "", chain: "Polygon"});
   *  // sends user an OTP code
   * try {
   *    await thirdwebInAppWallet.auth.sendEmailLoginOtp({ email : "you@example.com" });
   * } catch(e) {
   *    // Error Sending user's email an OTP code
   *    console.error(e);
   * }
   *
   * // Then when your user is ready to verify their OTP
   * try {
   *    const user = await thirdwebInAppWallet.auth.verifyEmailLoginOtp({ email: "you@example.com", otp: "6-DIGIT_CODE_HERE" });
   * } catch(e) {
   *    // Error verifying the OTP code
   *    console.error(e)
   * }
   * ```
   * @param param0 - param0.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * @returns `{{ isNewUser: boolean }}` IsNewUser indicates if the user is a new user to your platform
   * @internal
   */
  async sendEmailLoginOtp({ email }) {
    return this.BaseLogin.sendEmailLoginOtp({
      email
    });
  }
  /**
   * @internal
   */
  async sendSmsLoginOtp({ phoneNumber }) {
    return this.BaseLogin.sendSmsLoginOtp({
      phoneNumber
    });
  }
  /**
   * Used to verify the otp that the user receives from thirdweb
   *
   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`
   * @param args - props.email We will send the email an OTP that needs to be entered in order for them to be logged in.
   * props.otp The code that the user received in their email
   * @returns `{{user: InitializedUser}}` An InitializedUser object containing the user's status, wallet, authDetails, and more
   * @internal
   */
  async verifyEmailLoginOtp(args) {
    return this.BaseLogin.verifyEmailLoginOtp(args);
  }
  /**
   * @internal
   */
  async verifySmsLoginOtp(args) {
    return this.BaseLogin.verifySmsLoginOtp(args);
  }
  /**
   * Logs any existing user out of their wallet.
   * @returns `{{success: boolean}}` true if a user is successfully logged out. false if there's no user currently logged in.
   * @internal
   */
  async logout() {
    const { success } = await this.AuthQuerier.call({
      procedureName: "logout",
      params: void 0
    });
    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();
    const isRemoveUserId = await this.localStorage.removeWalletUserId();
    return {
      success: success || isRemoveAuthCookie || isRemoveUserId
    };
  }
};

// node_modules/thirdweb/dist/esm/wallets/ecosystem/get-ecosystem-partner-permissions.js
var getEcosystemPartnerPermissions = async (ecosystemId, partnerId) => {
  const res = await fetch(`${getThirdwebBaseUrl("inAppWallet")}/api/2024-05-05/ecosystem-wallet/${ecosystemId}/partner/${partnerId}`, {
    headers: {
      "x-ecosystem-id": ecosystemId,
      "x-ecosystem-partner-id": partnerId || ""
    }
  });
  const data = await res.json();
  return data;
};

// node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/in-app-account.js
var IFrameWallet = class {
  /**
   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance
   * @internal
   */
  constructor({ client, ecosystem, querier }) {
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "ecosystem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "walletManagerQuerier", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "localStorage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.client = client;
    this.ecosystem = ecosystem;
    this.walletManagerQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId: client.clientId,
      ecosystemId: ecosystem == null ? void 0 : ecosystem.id
    });
  }
  /**
   * Used to set-up the user device in the case that they are using incognito
   * @returns `{walletAddress : string }` The user's wallet details
   * @internal
   */
  async postWalletSetUp({ deviceShareStored, walletAddress, isIframeStorageEnabled, walletUserId }) {
    if (!isIframeStorageEnabled) {
      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);
    }
    return { walletAddress };
  }
  /**
   * Gets the various status states of the user
   * @example
   * ```typescript
   *  const userStatus = await Paper.getUserWalletStatus();
   *  switch (userStatus.status) {
   *  case UserWalletStatus.LOGGED_OUT: {
   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {
   *    // User is logged in, but does not have a wallet associated with it
   *    // you also have access to the user's details
   *    userStatus.user.authDetails;
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {
   *    // User is logged in and created a wallet already, but is missing the device shard
   *    // You have access to:
   *    userStatus.user.authDetails;
   *    userStatus.user.walletAddress;
   *    break;
   *  }
   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
   *    // user is logged in and wallet is all set up.
   *    // You have access to:
   *    userStatus.user.authDetails;
   *    userStatus.user.walletAddress;
   *    userStatus.user.wallet;
   *    break;
   *  }
   *}
   *```
   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses
   * @internal
   */
  async getUserWalletStatus() {
    const userStatus = await this.walletManagerQuerier.call({
      procedureName: "getUserStatus",
      params: void 0
    });
    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {
      return {
        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
        ...userStatus.user,
        account: await this.getAccount()
      };
    }
    if (userStatus.status === UserWalletStatus.LOGGED_IN_NEW_DEVICE) {
      return {
        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,
        ...userStatus.user
      };
    }
    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED) {
      return {
        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,
        ...userStatus.user
      };
    }
    return { status: userStatus.status };
  }
  /**
   * Returns an account that communicates with the iFrame for signing operations
   * @internal
   */
  async getAccount() {
    var _a, _b, _c;
    const querier = this.walletManagerQuerier;
    const client = this.client;
    const partnerId = (_a = this.ecosystem) == null ? void 0 : _a.partnerId;
    const isEcosystem = !!this.ecosystem;
    const permissions = ((_b = this.ecosystem) == null ? void 0 : _b.partnerId) ? await getEcosystemPartnerPermissions(this.ecosystem.id, (_c = this.ecosystem) == null ? void 0 : _c.partnerId) : void 0;
    const { address } = await querier.call({
      procedureName: "getAddress",
      params: void 0
    });
    const _signTransaction = async (tx) => {
      const transaction = {
        to: tx.to ?? void 0,
        data: tx.data,
        value: tx.value,
        gasLimit: tx.gas,
        nonce: tx.nonce,
        chainId: tx.chainId
      };
      if (tx.maxFeePerGas) {
        transaction.accessList = tx.accessList;
        transaction.maxFeePerGas = tx.maxFeePerGas;
        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
        transaction.type = 2;
      } else {
        transaction.gasPrice = tx.gasPrice;
        transaction.type = 0;
      }
      const { signedTransaction } = await querier.call({
        procedureName: "signTransaction",
        params: {
          transaction,
          chainId: tx.chainId,
          partnerId,
          rpcEndpoint: `https://${tx.chainId}.rpc.thirdweb.com`
          // TODO (ew) shouldnt be needed
        },
        // Can hide the iframe if the partner has full control (no user approvals)
        showIframe: (permissions == null ? void 0 : permissions.permissions.includes("FULL_CONTROL_V1")) ? false : isEcosystem
      });
      return signedTransaction;
    };
    return {
      address,
      async signTransaction(tx) {
        if (!tx.chainId) {
          throw new Error("chainId required in tx to sign");
        }
        return _signTransaction({
          ...tx,
          chainId: tx.chainId
        });
      },
      async sendTransaction(tx) {
        const rpcRequest = getRpcClient({
          client,
          chain: getCachedChain(tx.chainId)
        });
        const signedTx = await _signTransaction(tx);
        const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);
        return {
          transactionHash
        };
      },
      async signMessage({ message }) {
        const messageDecoded = (() => {
          if (typeof message === "string") {
            return message;
          }
          if (message.raw instanceof Uint8Array) {
            return message.raw;
          }
          return hexToString(message.raw);
        })();
        const { signedMessage } = await querier.call({
          procedureName: "signMessage",
          params: {
            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation
            message: messageDecoded,
            // needs bytes or string
            partnerId,
            chainId: 1
            // TODO check if we need this
          },
          // Can hide the iframe if the partner has full control (no user approvals)
          showIframe: (permissions == null ? void 0 : permissions.permissions.includes("FULL_CONTROL_V1")) ? false : isEcosystem
        });
        return signedMessage;
      },
      async signTypedData(_typedData) {
        var _a2;
        const parsedTypedData = parseTypedData(_typedData);
        if ((_a2 = parsedTypedData.types) == null ? void 0 : _a2.EIP712Domain) {
          parsedTypedData.types.EIP712Domain = void 0;
        }
        const domain = parsedTypedData.domain;
        const chainId = (domain == null ? void 0 : domain.chainId) || 1;
        const { signedTypedData } = await querier.call({
          procedureName: "signTypedDataV4",
          params: {
            domain: {
              chainId,
              verifyingContract: domain == null ? void 0 : domain.verifyingContract,
              name: domain == null ? void 0 : domain.name,
              version: domain == null ? void 0 : domain.version
            },
            types: parsedTypedData.types,
            message: parsedTypedData.message,
            chainId,
            partnerId,
            rpcEndpoint: `https://${chainId}.rpc.thirdweb.com`
            // TODO (ew) shouldnt be needed
          },
          // Can hide the iframe if the partner has full control (no user approvals)
          showIframe: (permissions == null ? void 0 : permissions.permissions.includes("FULL_CONTROL_V1")) ? false : isEcosystem
        });
        return signedTypedData;
      }
    };
  }
};

// node_modules/thirdweb/dist/esm/wallets/in-app/web/lib/web-connector.js
var InAppWebConnector = class {
  isClientIdLegacyPaper(clientId) {
    if (clientId.indexOf("-") > 0 && clientId.length === 36) {
      return true;
    }
    return false;
  }
  /**
   * @example
   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: "", chain: "Goerli" });`
   * @internal
   */
  constructor({ client, onAuthSuccess, ecosystem }) {
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "querier", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "wallet", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "auth", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (this.isClientIdLegacyPaper(client.clientId)) {
      throw new Error("You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page");
    }
    const baseUrl = getThirdwebBaseUrl("inAppWallet");
    this.client = client;
    this.querier = new InAppWalletIframeCommunicator({
      clientId: client.clientId,
      ecosystem,
      baseUrl
    });
    this.wallet = new IFrameWallet({
      client,
      ecosystem,
      querier: this.querier
    });
    this.auth = new Auth({
      client,
      querier: this.querier,
      baseUrl,
      ecosystem,
      onAuthSuccess: async (authResult) => {
        onAuthSuccess == null ? void 0 : onAuthSuccess(authResult);
        await this.wallet.postWalletSetUp({
          ...authResult.walletDetails,
          walletUserId: authResult.storedToken.authDetails.userWalletId
        });
        await this.querier.call({
          procedureName: "initIframe",
          params: {
            partnerId: ecosystem == null ? void 0 : ecosystem.partnerId,
            ecosystemId: ecosystem == null ? void 0 : ecosystem.id,
            deviceShareStored: authResult.walletDetails.deviceShareStored,
            clientId: this.client.clientId,
            walletUserId: authResult.storedToken.authDetails.userWalletId,
            authCookie: authResult.storedToken.cookieString
          }
        });
        return {
          user: {
            status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
            authDetails: authResult.storedToken.authDetails,
            account: await this.wallet.getAccount(),
            walletAddress: authResult.walletDetails.walletAddress
          }
        };
      }
    });
  }
  /**
   * Gets the usr if they are logged in
   * @example
   * ```js
   *  const user = await thirdwebInAppWallet.getUser();
   *  switch (user.status) {
   *     case UserWalletStatus.LOGGED_OUT: {
   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user
   *       break;
   *     }
   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
   *       // user is logged in and wallet is all set up.
   *       // You have access to:
   *       user.status;
   *       user.authDetails;
   *       user.walletAddress;
   *       user.wallet;
   *       break;
   *     }
   * }
   * ```
   * @returns GetUser - an object to containing various information on the user statuses
   */
  async getUser() {
    return this.wallet.getUserWalletStatus();
  }
  getAccount() {
    return this.wallet.getAccount();
  }
  async preAuthenticate(args) {
    const strategy = args.strategy;
    switch (strategy) {
      case "email": {
        return this.auth.sendEmailLoginOtp({ email: args.email });
      }
      case "phone": {
        return this.auth.sendSmsLoginOtp({ phoneNumber: args.phoneNumber });
      }
      default:
        assertUnreachable(strategy, `Provider: ${strategy} doesn't require pre-authentication`);
    }
  }
  async authenticate(args) {
    const strategy = args.strategy;
    switch (strategy) {
      case "email": {
        return await this.auth.verifyEmailLoginOtp({
          email: args.email,
          otp: args.verificationCode
        });
      }
      case "phone": {
        return await this.auth.verifySmsLoginOtp({
          otp: args.verificationCode,
          phoneNumber: args.phoneNumber
        });
      }
      case "apple":
      case "facebook":
      case "google": {
        const oauthProvider = oauthStrategyToAuthProvider[strategy];
        return this.auth.loginWithOauth({
          oauthProvider,
          closeOpenedWindow: args.closeOpenedWindow,
          openedWindow: args.openedWindow
        });
      }
      case "jwt": {
        return this.auth.loginWithCustomJwt({
          jwt: args.jwt,
          encryptionKey: args.encryptionKey
        });
      }
      case "auth_endpoint": {
        return this.auth.loginWithCustomAuthEndpoint({
          payload: args.payload,
          encryptionKey: args.encryptionKey
        });
      }
      case "iframe_email_verification": {
        return this.auth.loginWithEmailOtp({
          email: args.email
        });
      }
      case "iframe": {
        return this.auth.loginWithModal();
      }
      case "passkey": {
        if (args.type === "sign-up") {
          const authToken2 = await registerPasskey({
            client: this.wallet.client,
            ecosystem: this.wallet.ecosystem,
            authenticatorType: args.authenticatorType,
            username: args.passkeyName
          });
          return this.auth.loginWithAuthToken(authToken2);
        }
        const authToken = await loginWithPasskey({
          client: this.wallet.client,
          ecosystem: this.wallet.ecosystem,
          authenticatorType: args.authenticatorType
        });
        return this.auth.loginWithAuthToken(authToken);
      }
      default:
        assertUnreachable(strategy);
    }
  }
  async logout() {
    return await this.auth.logout();
  }
};
function assertUnreachable(x, message) {
  throw new Error(message ?? `Invalid param: ${x}`);
}
export {
  InAppWebConnector
};
//# sourceMappingURL=web-connector-Q2GYLPM3.js.map
