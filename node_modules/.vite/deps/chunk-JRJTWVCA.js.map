{
  "version": 3,
  "sources": ["../../thirdweb/src/rpc/actions/eth_getBlockByNumber.ts", "../../thirdweb/src/rpc/actions/eth_maxPriorityFeePerGas.ts", "../../thirdweb/src/utils/promise/resolve-promised-value.ts", "../../thirdweb/src/rpc/actions/eth_gasPrice.ts", "../../thirdweb/src/gas/get-gas-price.ts", "../../thirdweb/src/gas/op-gas-fee-reducer.ts", "../../thirdweb/src/gas/fee-data.ts", "../../thirdweb/src/extensions/modular/__generated__/ModularCore/read/getInstalledExtensions.ts", "../../thirdweb/src/utils/base58/alphabet.ts", "../../thirdweb/src/utils/base58/encode.ts", "../../thirdweb/src/utils/bytecode/cbor-decode.ts", "../../thirdweb/src/utils/bytecode/prefix.ts", "../../thirdweb/src/utils/bytecode/extractIPFS.ts", "../../thirdweb/src/contract/actions/resolve-abi.ts", "../../thirdweb/src/transaction/extract-error.ts", "../../thirdweb/src/transaction/actions/estimate-gas.ts", "../../thirdweb/src/transaction/actions/to-serializable-transaction.ts"],
  "sourcesContent": ["import {\n  type BlockTag,\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type GetBlockReturnType,\n  formatBlock,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype GetBlockParameters<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = \"latest\",\n> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint;\n      blockTag?: never;\n    }\n  | {\n      blockNumber?: never;\n      /**\n       * The block tag.\n       * default: 'latest'\n       */\n      blockTag?: TBlockTag | BlockTag;\n    }\n);\n\n/**\n * Retrieves a block by its number or tag from the Ethereum blockchain.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the block.\n * @returns A promise that resolves to the requested block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByNumber } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByNumber(rpcRequest, {\n *  blockNumber: 123456,\n *  includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByNumber<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = \"latest\",\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockParameters<TIncludeTransactions, TBlockTag>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions, TBlockTag>> {\n  const blockTag = params.blockTag ?? \"latest\";\n  const includeTransactions = params.includeTransactions ?? false;\n  const blockNumberHex =\n    params.blockNumber !== undefined\n      ? numberToHex(params.blockNumber)\n      : undefined;\n\n  const block = await request({\n    method: \"eth_getBlockByNumber\",\n    params: [blockNumberHex || blockTag, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions,\n    TBlockTag\n  >;\n}\n", "import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the maximum priority fee per gas from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to a bigint representing the maximum priority fee per gas.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_maxPriorityFeePerGas } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const maxPriorityFeePerGas = await eth_maxPriorityFeePerGas(rpcRequest);\n * ```\n */\nexport async function eth_maxPriorityFeePerGas(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_maxPriorityFeePerGas\",\n  });\n  return hexToBigInt(result);\n}\n", "/**\n * Resolves a possibly asynchronous value.\n * If the value is a function that returns a promise, it will be awaited and the resolved value will be returned.\n * Otherwise, the value itself will be returned.\n *\n * @param value - The value to resolve.\n * @returns A promise that resolves to the resolved value.\n * @internal\n */\nexport async function resolvePromisedValue<V>(\n  value: V,\n): Promise<V extends () => Promise<infer R> ? R : V> {\n  return typeof value === \"function\" ? await value() : value;\n}\n\nexport type PromisedValue<T> = T | (() => Promise<T>);\n\nexport type PromisedObject<T> = {\n  [K in keyof T]: PromisedValue<T[K]>;\n};\n", "import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current gas price from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the gas price as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_gasPrice } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const gasPrice = await eth_gasPrice(rpcRequest);\n * ```\n */\nexport async function eth_gasPrice(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_gasPrice\",\n  });\n  return hexToBigInt(result);\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_gasPrice } from \"../rpc/actions/eth_gasPrice.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\n\nexport type GetGasPriceOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  percentMultiplier?: number;\n};\n\n/**\n * Retrieves the gas price for a transaction on a specific chain.\n * @param client - The Thirdweb client.\n * @param chain - The ID of the chain.\n * @returns A promise that resolves to the gas price as a bigint.\n * @example\n * ```ts\n * import { getGasPrice } from \"thirdweb\";\n *\n * const gasPrice = await getGasPrice({ client, chain });\n * ```\n * @utils\n */\nexport async function getGasPrice(\n  options: GetGasPriceOptions,\n): Promise<bigint> {\n  const { client, chain, percentMultiplier } = options;\n  const rpcClient = getRpcClient({ client, chain });\n  const gasPrice_ = await eth_gasPrice(rpcClient);\n  const extraTip = percentMultiplier\n    ? (gasPrice_ / BigInt(100)) * BigInt(percentMultiplier)\n    : 0n;\n  const txGasPrice = gasPrice_ + extraTip;\n  return txGasPrice;\n}\n", "/**\n * Via: https://twitter.com/0xjustadev/status/1758973668011434062\n *\n * Increases the gas fee value to the nearest power of 2.\n * If the value is already a power of 2 or 0, it returns the value as is.\n * Otherwise, it finds the highest power of 2 that is bigger than the given value.\n * @param value - The gas fee value to be \"rounded up\".\n * @returns The *increased* gas value which will result in a lower L1 gas fee, overall reducing the gas fee.\n * @internal\n */\nexport function roundUpGas(value: bigint): bigint {\n  if (value === 0n || (value & (value - 1n)) === 0n) {\n    return value;\n  }\n\n  // Find the highest set bit by shifting until the value is 0.\n  let highestBit = 1n;\n  while (value > 0n) {\n    // biome-ignore lint/style/noParameterAssign: the whole point is that we modify the value in palce\n    value >>= 1n;\n    highestBit <<= 1n;\n  }\n\n  return highestBit;\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_getBlockByNumber } from \"../rpc/actions/eth_getBlockByNumber.js\";\nimport { eth_maxPriorityFeePerGas } from \"../rpc/actions/eth_maxPriorityFeePerGas.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport { toUnits } from \"../utils/units.js\";\nimport { getGasPrice } from \"./get-gas-price.js\";\nimport { roundUpGas } from \"./op-gas-fee-reducer.js\";\n\ntype FeeData = {\n  maxFeePerGas: null | bigint;\n  maxPriorityFeePerGas: null | bigint;\n};\n\ntype FeeDataParams =\n  | {\n      gasPrice?: never;\n      maxFeePerGas?: bigint;\n      maxPriorityFeePerGas?: bigint;\n    }\n  | {\n      gasPrice?: bigint;\n      maxFeePerGas?: never;\n      maxPriorityFeePerGas?: never;\n    };\n\n/**\n *\n * @internal\n */\nexport async function getGasOverridesForTransaction(\n  transaction: PreparedTransaction,\n): Promise<FeeDataParams> {\n  // first check for explicit values\n  const [maxFeePerGas, maxPriorityFeePerGas, gasPrice] = await Promise.all([\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.gasPrice),\n  ]);\n\n  // Exit early if the user explicitly provided enough options\n  if (maxFeePerGas !== undefined && maxPriorityFeePerGas !== undefined) {\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n  if (gasPrice) {\n    return { gasPrice };\n  }\n\n  // If we don't have enough explicit values, get defaults\n  const defaultGasOverrides = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n  );\n\n  if (transaction.chain.experimental?.increaseZeroByteCount) {\n    // otherwise adjust each value\n    if (defaultGasOverrides.gasPrice) {\n      return { gasPrice: roundUpGas(defaultGasOverrides.gasPrice) };\n    }\n\n    return {\n      maxFeePerGas:\n        maxFeePerGas ?? roundUpGas(defaultGasOverrides.maxFeePerGas ?? 0n),\n      maxPriorityFeePerGas:\n        maxPriorityFeePerGas ??\n        roundUpGas(defaultGasOverrides.maxPriorityFeePerGas ?? 0n),\n    };\n  }\n\n  // return as is\n  if (defaultGasOverrides.gasPrice) {\n    return defaultGasOverrides;\n  }\n\n  // Still check for explicit values in case one is provided and not the other\n  return {\n    maxFeePerGas: maxFeePerGas ?? defaultGasOverrides.maxFeePerGas,\n    maxPriorityFeePerGas:\n      maxPriorityFeePerGas ?? defaultGasOverrides.maxPriorityFeePerGas,\n  };\n}\n\n/**\n * Retrieves the default gas overrides for a given client and chain ID.\n * If the fee data contains both maxFeePerGas and maxPriorityFeePerGas, it returns an object with those values.\n * Otherwise, it returns an object with the gasPrice obtained from the client and chain ID.\n * @param client - The ThirdwebClient instance.\n * @param chain - The chain ID.\n * @returns An object containing the default gas overrides.\n * @internal\n */\nexport async function getDefaultGasOverrides(\n  client: ThirdwebClient,\n  chain: Chain,\n) {\n  const feeData = await getDynamicFeeData(client, chain);\n  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {\n    return {\n      maxFeePerGas: feeData.maxFeePerGas,\n      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,\n    };\n  }\n  return {\n    gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 }),\n  };\n}\n\n/**\n * Retrieves dynamic fee data for a given chain.\n * @param client - The Thirdweb client.\n * @param chain - The chain ID.\n * @returns A promise that resolves to the fee data.\n * @internal\n */\nasync function getDynamicFeeData(\n  client: ThirdwebClient,\n  chain: Chain,\n): Promise<FeeData> {\n  let maxFeePerGas: null | bigint = null;\n  let maxPriorityFeePerGas_: null | bigint = null;\n\n  const rpcRequest = getRpcClient({ client, chain });\n\n  const [block, maxPriorityFeePerGas] = await Promise.all([\n    eth_getBlockByNumber(rpcRequest, { blockTag: \"latest\" }),\n    eth_maxPriorityFeePerGas(rpcRequest).catch(() => null),\n  ]);\n\n  const baseBlockFee = block?.baseFeePerGas ? block.baseFeePerGas : 100n;\n\n  const chainId = chain.id;\n  // flag chain testnet & flag chain\n  if (chainId === 220 || chainId === 1220) {\n    // these does not support eip-1559, for some reason even though `eth_maxPriorityFeePerGas` is available?!?\n    // return null because otherwise TX break\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n    // mumbai & polygon\n  }\n  if (chainId === 80001 || chainId === 137) {\n    // for polygon, get fee data from gas station\n    maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);\n  } else if (maxPriorityFeePerGas) {\n    // prioritize fee from eth_maxPriorityFeePerGas\n    maxPriorityFeePerGas_ = maxPriorityFeePerGas;\n  }\n\n  if (!maxPriorityFeePerGas_) {\n    // chain does not support eip-1559, return null for both\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n  }\n\n  // add 10% tip to maxPriorityFeePerGas for faster processing\n  maxPriorityFeePerGas_ = getPreferredPriorityFee(maxPriorityFeePerGas_);\n  // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is\n  // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees\n  maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;\n\n  // special cased for Celo gas fees\n  if (chainId === 42220 || chainId === 44787 || chainId === 62320) {\n    maxPriorityFeePerGas_ = maxFeePerGas;\n  }\n\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas_,\n  };\n}\n\n/**\n * Calculates the preferred priority fee based on the default priority fee per gas and a percent multiplier.\n * @param defaultPriorityFeePerGas - The default priority fee per gas.\n * @param percentMultiplier - The percent multiplier to calculate the extra tip. Default is 10.\n * @returns The total priority fee including the extra tip.\n * @internal\n */\nfunction getPreferredPriorityFee(\n  defaultPriorityFeePerGas: bigint,\n  percentMultiplier = 10,\n): bigint {\n  const extraTip =\n    (defaultPriorityFeePerGas / BigInt(100)) * BigInt(percentMultiplier);\n  const totalPriorityFee = defaultPriorityFeePerGas + extraTip;\n  return totalPriorityFee;\n}\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId: 137 | 80001): string {\n  switch (chainId) {\n    case 137:\n      return \"https://gasstation.polygon.technology/v2\";\n    case 80001:\n      return \"https://gasstation-testnet.polygon.technology/v2\";\n  }\n}\n\nconst MIN_POLYGON_GAS_PRICE = 31n; // 31 gwei\n\nconst MIN_MUMBAI_GAS_PRICE = 1n; // 1 gwei\n\n/**\n * @internal\n */\nfunction getDefaultGasFee(chainId: 137 | 80001): bigint {\n  switch (chainId) {\n    case 137:\n      return MIN_POLYGON_GAS_PRICE;\n    case 80001:\n      return MIN_MUMBAI_GAS_PRICE;\n  }\n}\n\n/**\n *\n * @returns The gas price\n * @internal\n */\nasync function getPolygonGasPriorityFee(chainId: 137 | 80001): Promise<bigint> {\n  const gasStationUrl = getGasStationUrl(chainId);\n  try {\n    const data = await (await fetch(gasStationUrl)).json();\n    // take the standard speed here, SDK options will define the extra tip\n    const priorityFee = data.fast.maxPriorityFee;\n    if (priorityFee > 0) {\n      const fixedFee = Number.parseFloat(priorityFee).toFixed(9);\n      return toUnits(fixedFee, 9);\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return getDefaultGasFee(chainId);\n}\n", "import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x5357aa5e\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"_installedExtensions\",\n    type: \"tuple[]\",\n    internalType: \"struct IModularCore.InstalledExtension[]\",\n    components: [\n      {\n        name: \"implementation\",\n        type: \"address\",\n        internalType: \"address\",\n      },\n      {\n        name: \"config\",\n        type: \"tuple\",\n        internalType: \"struct IExtensionConfig.ExtensionConfig\",\n        components: [\n          {\n            name: \"registerInstallationCallback\",\n            type: \"bool\",\n            internalType: \"bool\",\n          },\n          {\n            name: \"requiredInterfaces\",\n            type: \"bytes4[]\",\n            internalType: \"bytes4[]\",\n          },\n          {\n            name: \"supportedInterfaces\",\n            type: \"bytes4[]\",\n            internalType: \"bytes4[]\",\n          },\n          {\n            name: \"callbackFunctions\",\n            type: \"tuple[]\",\n            internalType: \"struct IExtensionConfig.CallbackFunction[]\",\n            components: [\n              {\n                name: \"selector\",\n                type: \"bytes4\",\n                internalType: \"bytes4\",\n              },\n            ],\n          },\n          {\n            name: \"fallbackFunctions\",\n            type: \"tuple[]\",\n            internalType: \"struct IExtensionConfig.FallbackFunction[]\",\n            components: [\n              {\n                name: \"selector\",\n                type: \"bytes4\",\n                internalType: \"bytes4\",\n              },\n              {\n                name: \"permissionBits\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  },\n] as const;\n\n/**\n * Checks if the `getInstalledExtensions` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `getInstalledExtensions` method is supported.\n * @extension MODULAR\n * @example\n * ```ts\n * import { isGetInstalledExtensionsSupported } from \"thirdweb/extensions/modular\";\n *\n * const supported = await isGetInstalledExtensionsSupported(contract);\n * ```\n */\nexport async function isGetInstalledExtensionsSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the getInstalledExtensions function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension MODULAR\n * @example\n * ```ts\n * import { decodeGetInstalledExtensionsResult } from \"thirdweb/extensions/modular\";\n * const result = decodeGetInstalledExtensionsResult(\"...\");\n * ```\n */\nexport function decodeGetInstalledExtensionsResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getInstalledExtensions\" function on the contract.\n * @param options - The options for the getInstalledExtensions function.\n * @returns The parsed result of the function call.\n * @extension MODULAR\n * @example\n * ```ts\n * import { getInstalledExtensions } from \"thirdweb/extensions/modular\";\n *\n * const result = await getInstalledExtensions({\n *  contract,\n * });\n *\n * ```\n */\nexport async function getInstalledExtensions(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "export const ALPHABET =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" as const;\n", "import { ALPHABET } from \"./alphabet.js\";\n\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source: Uint8Array): string {\n  if (!(source instanceof Uint8Array)) {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n  if (source.length === 0) {\n    return \"\";\n  }\n  // Skip & count leading zeroes.\n  let zeroes = 0;\n  let length = 0;\n  let pbegin = 0;\n  const pend = source.length;\n  while (pbegin !== pend && source[pbegin] === 0) {\n    pbegin++;\n    zeroes++;\n  }\n  // Allocate enough space in big-endian base58 representation.\n  const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n  const b58 = new Uint8Array(size);\n  // Process the bytes.\n  while (pbegin !== pend) {\n    let carry = source[pbegin] || 0;\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (\n      let it1 = size - 1;\n      (carry !== 0 || i < length) && it1 !== -1;\n      it1--, i++\n    ) {\n      carry += (256 * (b58[it1] || 0)) >>> 0;\n      b58[it1] = (carry % BASE) >>> 0;\n      carry = (carry / BASE) >>> 0;\n    }\n    if (carry !== 0) {\n      throw new Error(\"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n  // Skip leading zeroes in base58 result.\n  let it2 = size - length;\n  while (it2 !== size && b58[it2] === 0) {\n    it2++;\n  }\n  // Translate the result into a string.\n  let str = LEADER.repeat(zeroes);\n  for (; it2 < size; ++it2) {\n    str += ALPHABET.charAt(b58[it2] || 0);\n  }\n  return str;\n}\n", "// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n\n// TODO: re-enable typescript and properly type this\n\n// @ts-nocheck\n\nlet src;\nlet srcEnd;\nlet position = 0;\n\nconst EMPTY_ARRAY = [];\n\nlet strings = EMPTY_ARRAY;\n\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\n\nlet packedValues;\n\nlet dataView;\n\nconst defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true,\n};\n\nclass Decoder {\n  constructor() {\n    Object.assign(this, defaultOptions);\n  }\n\n  decodeKey(key) {\n    return key;\n  }\n\n  decode(source, end? = -1) {\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView =\n        source.dataView ||\n        (source.dataView = new DataView(\n          source.buffer,\n          source.byteOffset,\n          source.byteLength,\n        ));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\n        `Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n            ? source.constructor.name\n            : typeof source}`,\n      );\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues =\n        this.sharedValues &&\n        (this.pack\n          ? new Array(this.maxPrivatePackedValues || 16).concat(\n              this.sharedValues,\n            )\n          : this.sharedValues);\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\n\nfunction checkedRead() {\n  try {\n    const result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (\n      error instanceof RangeError ||\n      error.message.startsWith(\"Unexpected end of buffer\")\n    ) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\n\nfunction read() {\n  let token = src[position++];\n  const majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n\n      default:\n        throw new Error(`Unknown token ${token}`);\n    }\n  }\n  switch (majorType) {\n    case 0: // positive int\n      return token;\n    case 1: // negative int\n      return ~token;\n    case 2: // buffer\n      return readBin(token);\n    case 3: // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(\n          position - srcStringStart,\n          (position += token) - srcStringStart,\n        );\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string =\n          token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string !== null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4: { // array\n      const array = new Array(token);\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    }\n\n    case 5: { // map\n      const object = {};\n      for (let i = 0; i < token; i++) {\n        object[safeKey(read())] = read();\n      }\n      return object;\n    }\n    default: // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(`Unknown CBOR token ${token}`);\n  }\n}\n\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === \"string\") {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  }\n  if (typeof key !== \"object\") {\n    return key.toString();\n  }\n  // protect against expensive (DoS) string conversions\n  throw new Error(`Invalid property name type ${typeof key}`);\n}\n\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  const start = position;\n  const bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      }\n        const a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n    }\n      const a = src[position++];\n      const b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) {\n        return fromCharCode(a, b);\n      }\n      const c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n  }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) {\n        return fromCharCode(a, b, c, d);\n      }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }if (length < 8) {\n      const e = src[position++];\n      const f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) {\n        return fromCharCode(a, b, c, d, e, f);\n      }\n      const g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    }\n      const e = src[position++];\n      const f = src[position++];\n      const g = src[position++];\n      const h = src[position++];\n      if (\n        (e & 0x80) > 0 ||\n        (f & 0x80) > 0 ||\n        (g & 0x80) > 0 ||\n        (h & 0x80) > 0\n      ) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) {\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n          const i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n      }if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) {\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      }\n        const i = src[position++];\n        const j = src[position++];\n        const k = src[position++];\n        const l = src[position++];\n        if (\n          (i & 0x80) > 0 ||\n          (j & 0x80) > 0 ||\n          (k & 0x80) > 0 ||\n          (l & 0x80) > 0\n        ) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          }\n            const m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n        }\n          const m = src[position++];\n          const n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          }\n          const o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\n\nfunction readBin(length) {\n  return currentDecoder.copyBuffers\n    ? // specifically use the copying slice (not the node one)\n      Uint8Array.prototype.slice.call(src, position, (position += length))\n    : src.subarray(position, (position += length));\n}\n\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n  if (src[position++] !== 0x84) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    if (src.length < position) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n  const newPackedValues = read_(); // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues\n    ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n    : newPackedValues;\n  packedValues.prefixes = read_();\n  packedValues.suffixes = read_();\n  return read_(); // read the rump\n};\npackedTable.handlesRead = true;\n\ncurrentExtensions[28] = (read_) => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  const id = referenceMap.id++;\n  const token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n\n  const refEntry = { target }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  const targetProperties = read_(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\n\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = /* @__PURE__ */ (() =>\n    Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;\n", "import { type Hex, isHex } from \"../encoding/hex.js\";\n\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nexport function ensureBytecodePrefix(bytecode: string): Hex {\n  if (isHex(bytecode, { strict: false })) {\n    return bytecode;\n  }\n  return `0x${bytecode}`;\n}\n", "import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode: string): string | undefined {\n  const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n\n  const cborLength =\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 1];\n  const cborStart = numericBytecode.length - 2 - cborLength;\n  // if the cborStart is invalid, return undefined\n  if (cborStart < 0 || cborStart > numericBytecode.length) {\n    return undefined;\n  }\n  const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData) {\n    return `ipfs://${base58Encode(cborData.ipfs)}`;\n  }\n\n  return undefined;\n}\n", "import { type Abi, formatAbi, parseAbi } from \"abitype\";\nimport { getInstalledExtensions } from \"../../extensions/modular/__generated__/ModularCore/read/getInstalledExtensions.js\";\nimport { download } from \"../../storage/download.js\";\nimport { extractIPFSUri } from \"../../utils/bytecode/extractIPFS.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport type { ThirdwebContract } from \"../contract.js\";\nimport { getBytecode } from \"./get-bytecode.js\";\n\nconst ABI_RESOLUTION_CACHE = new WeakMap<ThirdwebContract<Abi>, Promise<Abi>>();\n\n/**\n * Resolves the ABI (Application Binary Interface) for a given contract.\n * If the ABI is already cached, it returns the cached value.\n * Otherwise, it tries to resolve the ABI from the contract's API.\n * If that fails, it resolves the ABI from the contract's bytecode.\n * @param contract The contract for which to resolve the ABI.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveContractAbi } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveContractAbi(myContract);\n * ```\n * @contract\n */\nexport function resolveContractAbi<abi extends Abi>(\n  contract: ThirdwebContract<abi>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<abi> {\n  if (ABI_RESOLUTION_CACHE.has(contract)) {\n    return ABI_RESOLUTION_CACHE.get(contract) as Promise<abi>;\n  }\n\n  const prom = (async () => {\n    // if the contract already HAS a user defined we always use that!\n    if (contract.abi) {\n      return contract.abi as abi;\n    }\n    // try to get it from the api\n    try {\n      return await resolveAbiFromContractApi(contract, contractApiBaseUrl);\n    } catch (e) {\n      // if that fails, try to resolve it from the bytecode\n      return await resolveCompositeAbi(contract as ThirdwebContract);\n    }\n  })();\n  ABI_RESOLUTION_CACHE.set(contract, prom);\n  return prom as Promise<abi>;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) for a contract from the contract API.\n * @param contract The ThirdwebContract instance representing the contract.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromContractApi } from \"thirdweb/contract\"\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromContractApi(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromContractApi(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<Abi> {\n  const response = await getClientFetch(contract.client)(\n    `${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`,\n  );\n  const json = await response.json();\n  if (!json || json.error) {\n    throw new Error(\n      `Failed to resolve ABI from contract API. ${json.error || \"\"}`,\n    );\n  }\n  return json;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.\n * @param contract The ThirdwebContract instance.\n * @returns The resolved ABI as a generic type.\n * @throws Error if no IPFS URI is found in the bytecode.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromBytecode(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n): Promise<Abi> {\n  const bytecode = await getBytecode(contract);\n  if (bytecode === \"0x\") {\n    const { id, name } = contract.chain;\n    throw new Error(\n      `Failed to load contract bytecode. Make sure the contract [${\n        contract.address\n      }] exists on the chain [${name || \"Unknown Chain\"} (chain id: ${id})]`,\n    );\n  }\n  const ipfsUri = extractIPFSUri(bytecode);\n  if (!ipfsUri) {\n    // just early exit if we can't find an IPFS URI\n    return [];\n  }\n  try {\n    const res = await download({ uri: ipfsUri, client: contract.client });\n    const json = await res.json();\n    // ABI is at `json.output.abi`\n    return json.output.abi;\n  } catch {\n    // if we can't resolve the ABI from the IPFS URI, return an empty array\n    return [];\n  }\n}\n\nconst PLUGINS_ABI = {\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"bytes4\",\n          name: \"functionSelector\",\n          type: \"bytes4\",\n        },\n        {\n          internalType: \"string\",\n          name: \"functionSignature\",\n          type: \"string\",\n        },\n        {\n          internalType: \"address\",\n          name: \"pluginAddress\",\n          type: \"address\",\n        },\n      ],\n      internalType: \"struct IPluginMap.Plugin[]\",\n      name: \"registered\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst BASE_ROUTER_ABI = {\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [\n    {\n      components: [\n        {\n          components: [\n            {\n              internalType: \"string\",\n              name: \"name\",\n              type: \"string\",\n            },\n            {\n              internalType: \"string\",\n              name: \"metadataURI\",\n              type: \"string\",\n            },\n            {\n              internalType: \"address\",\n              name: \"implementation\",\n              type: \"address\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionMetadata\",\n          name: \"metadata\",\n          type: \"tuple\",\n        },\n        {\n          components: [\n            {\n              internalType: \"bytes4\",\n              name: \"functionSelector\",\n              type: \"bytes4\",\n            },\n            {\n              internalType: \"string\",\n              name: \"functionSignature\",\n              type: \"string\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionFunction[]\",\n          name: \"functions\",\n          type: \"tuple[]\",\n        },\n      ],\n      internalType: \"struct IExtension.Extension[]\",\n      name: \"allExtensions\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst DIAMOND_ABI = {\n  inputs: [],\n  name: \"facets\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"address\",\n          name: \"facetAddress\",\n          type: \"address\",\n        },\n        {\n          internalType: \"bytes4[]\",\n          name: \"functionSelectors\",\n          type: \"bytes4[]\",\n        },\n      ],\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\n/**\n * Resolves the ABI for a contract based on its bytecode.\n * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.\n * @param contract The contract for which to resolve the ABI.\n * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.\n * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.\n * @returns The resolved ABI for the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveCompositeAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveCompositeAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveCompositeAbi(\n  contract: ThirdwebContract,\n  rootAbi?: Abi,\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>,\n) {\n  const [\n    rootAbi_,\n    pluginPatternAddresses,\n    baseRouterAddresses,\n    modularExtensionAddresses,\n    diamondFacetAddresses,\n  ] = await Promise.all([\n    rootAbi ? rootAbi : resolveAbiFromBytecode(contract),\n    // check these all at the same time\n    resolvePluginPatternAddresses(contract),\n    resolveBaseRouterAddresses(contract),\n    resolveModularExtensionAddresses(contract),\n    resolveDiamondFacetAddresses(contract),\n  ]);\n\n  const mergedPlugins = [\n    ...new Set([\n      ...pluginPatternAddresses,\n      ...baseRouterAddresses,\n      ...modularExtensionAddresses,\n      ...diamondFacetAddresses,\n    ]),\n  ];\n\n  // no plugins\n  if (!mergedPlugins.length) {\n    return rootAbi_;\n  }\n  // get all the abis for the plugins\n  const pluginAbis = await getAbisForPlugins({\n    contract,\n    plugins: mergedPlugins,\n    resolveSubAbi,\n  });\n\n  // join them together\n  return joinAbis({ rootAbi: rootAbi_, pluginAbis });\n}\n\nasync function resolvePluginPatternAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: PLUGINS_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.pluginAddress))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveBaseRouterAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: BASE_ROUTER_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.metadata.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveModularExtensionAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const extensions = await getInstalledExtensions({ contract });\n    // if there are no plugins, return the root ABI\n    if (!extensions.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(extensions.map((item) => item.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveDiamondFacetAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const facets = await readContract({ contract, method: DIAMOND_ABI });\n    // if there are no facets, return the root ABI\n    if (!facets.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return facets.map((item) => item.facetAddress);\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\ntype GetAbisForPluginsOptions = {\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>;\n  plugins: string[];\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>;\n};\n\nasync function getAbisForPlugins(\n  options: GetAbisForPluginsOptions,\n): Promise<Abi[]> {\n  return Promise.all(\n    options.plugins.map((pluginAddress) => {\n      const newContract = {\n        ...options.contract,\n        address: pluginAddress,\n      };\n      // if we have a method passed in that tells us how to resove the sub-api, use that\n      if (options.resolveSubAbi) {\n        return options.resolveSubAbi(newContract);\n      }\n      // otherwise default logic\n      return resolveAbiFromBytecode(newContract);\n    }),\n  );\n}\n\ntype JoinAbisOptions = {\n  pluginAbis: Abi[];\n  rootAbi?: Abi;\n};\n\nfunction joinAbis(options: JoinAbisOptions): Abi {\n  let mergedPlugins: Abi = options.pluginAbis\n    .flat()\n    .filter((item) => item.type !== \"constructor\");\n\n  if (options.rootAbi) {\n    mergedPlugins = [...(options.rootAbi || []), ...mergedPlugins].filter(\n      Boolean,\n    );\n  }\n\n  // unique by formatting every abi and then throwing them in a set\n  // TODO: this may not be super efficient...\n  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];\n  // finally parse it back out\n  return parseAbi(humanReadableAbi);\n}\n", "import type { Abi } from \"abitype\";\nimport { type Hex, decodeErrorResult } from \"viem\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\n\n/**\n * @internal\n */\nexport async function extractError<abi extends Abi>(args: {\n  error: unknown;\n  contract?: ThirdwebContract<abi>;\n}) {\n  const { error, contract } = args;\n  if (typeof error === \"object\") {\n    // try to parse RPC error\n    const errorObj = error as {\n      message?: string;\n      code?: number;\n      data?: Hex;\n    };\n    if (errorObj.data) {\n      if (errorObj.data !== \"0x\") {\n        let abi = contract?.abi;\n        if (contract && !abi) {\n          abi = await resolveContractAbi(contract).catch(() => undefined);\n        }\n        const parsedError = decodeErrorResult({\n          data: errorObj.data,\n          abi,\n        });\n        return new TransactionError(\n          `${parsedError.errorName}${\n            parsedError.args ? ` - ${parsedError.args}` : \"\"\n          }`,\n          contract,\n        );\n      }\n      return new TransactionError(\"Execution Reverted\", contract);\n    }\n  }\n  return error;\n}\n\nexport const __DEV__ = process.env.NODE_ENV !== \"production\";\n\nclass TransactionError<abi extends Abi> extends Error {\n  public contractAddress: string | undefined;\n  public chainId: number | undefined;\n\n  constructor(reason: string, contract?: ThirdwebContract<abi>) {\n    super();\n    this.name = \"TransactionError\";\n    this.contractAddress = contract?.address;\n    this.chainId = contract?.chain?.id;\n    if (__DEV__ && contract) {\n      // show more infor in dev\n      this.message = [\n        reason,\n        \"\",\n        `contract: ${this.contractAddress}`,\n        `chainId: ${this.chainId}`,\n      ].join(\"\\n\");\n    } else {\n      this.message = reason;\n    }\n  }\n}\n", "import { formatTransactionRequest } from \"viem\";\nimport { roundUpGas } from \"../../gas/op-gas-fee-reducer.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError as parseEstimationError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nexport type EstimateGasOptions = Prettify<\n  {\n    /**\n     * The prepared transaction to estimate the gas for.\n     */\n    // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n    // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n    transaction: PreparedTransaction<any>;\n  } & (\n    | {\n        /**\n         * The account the transaction would be sent from.\n         */\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        /**\n         * The address the transaction would be sent from.\n         */\n        from?: string;\n      }\n  )\n>;\n\nexport type EstimateGasResult = bigint;\n\nconst cache = new WeakMap<\n  PreparedTransaction & { from: string | undefined },\n  Promise<EstimateGasResult>\n>();\n\n/**\n * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.\n * @param options - The options for estimating gas.\n * @returns A promise that resolves to the estimated gas as a bigint.\n * @transaction\n * @example\n * ```ts\n * import { estimateGas } from \"thirdweb\";\n * const gas = await estimateGas({\n *  transaction,\n * });\n * ```\n */\nexport async function estimateGas(\n  options: EstimateGasOptions,\n): Promise<EstimateGasResult> {\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = options.from ?? options.account?.address ?? undefined;\n  const txWithFrom = { ...options.transaction, from };\n  if (cache.has(txWithFrom)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return cache.get(txWithFrom)!;\n  }\n  const { account } = options;\n  const promise = (async () => {\n    const predefinedGas = await resolvePromisedValue(options.transaction.gas);\n    // if we have a predefined gas value in the TX -> always use that\n    if (predefinedGas) {\n      return predefinedGas;\n    }\n\n    // if the wallet itself overrides the estimateGas function, use that\n    if (account?.estimateGas) {\n      try {\n        let gas = await account.estimateGas(options.transaction);\n        if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n          gas = roundUpGas(gas);\n        }\n        return gas;\n      } catch (error) {\n        throw await parseEstimationError({\n          error,\n          contract: options.transaction.__contract,\n        });\n      }\n    }\n\n    // load up encode function if we need it\n    const { encode } = await import(\"./encode.js\");\n    const [encodedData, toAddress, value] = await Promise.all([\n      encode(options.transaction),\n      resolvePromisedValue(options.transaction.to),\n      resolvePromisedValue(options.transaction.value),\n    ]);\n\n    // load up the rpc client and the estimateGas function if we need it\n    const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([\n      import(\"../../rpc/rpc.js\"),\n      import(\"../../rpc/actions/eth_estimateGas.js\"),\n    ]);\n\n    const rpcRequest = getRpcClient(options.transaction);\n    try {\n      let gas = await eth_estimateGas(\n        rpcRequest,\n        formatTransactionRequest({\n          to: toAddress,\n          data: encodedData,\n          from,\n          value,\n        }),\n      );\n      if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n        gas = roundUpGas(gas);\n      }\n      return gas;\n    } catch (error) {\n      throw await parseEstimationError({\n        error,\n        contract: options.transaction.__contract,\n      });\n    }\n  })();\n  cache.set(txWithFrom, promise);\n  return promise;\n}\n", "import type { TransactionSerializable } from \"viem\";\nimport { getGasOverridesForTransaction } from \"../../gas/fee-data.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport { encode } from \"./encode.js\";\nimport { estimateGas } from \"./estimate-gas.js\";\n\nexport type ToSerializableTransactionOptions = {\n  /**\n   * The transaction to convert to a serializable transaction.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  transaction: PreparedTransaction<any>;\n  /**\n   * The from address to use for gas estimation.\n   */\n  from?: string;\n};\n\n/**\n * Converts a prepared transaction to a transaction with populated options.\n * @param options - The transaction and additional options for conversion\n * @returns A serializable transaction for inspection or submission to an account.\n *\n * @note For easier transaction sending, {@see sendTransaction}\n * @example\n * ```ts\n * import { prepareTransaction, toSerializableTransaction } from \"thirdweb\";\n *\n * const transaction = await prepareTransaction({\n *   transaction: {\n *     to: \"0x...\",\n *     value: 100,\n *   },\n * });\n * const finalTx = await toSerializableTransaction({\n *   transaction,\n * });\n *\n * account.sendTransaction(finalTx);\n * ```\n * @transaction\n */\nexport async function toSerializableTransaction(\n  options: ToSerializableTransactionOptions,\n) {\n  const rpcRequest = getRpcClient(options.transaction);\n  const chainId = options.transaction.chain.id;\n  const from = options.from;\n  let [data, nonce, gas, feeData, to, accessList, value] = await Promise.all([\n    encode(options.transaction),\n    (async () => {\n      // if the user has specified a nonce, use that\n      const resolvedNonce = await resolvePromisedValue(\n        options.transaction.nonce,\n      );\n      if (resolvedNonce !== undefined) {\n        return resolvedNonce;\n      }\n\n      return from // otherwise get the next nonce (import the method to do so)\n        ? await import(\"../../rpc/actions/eth_getTransactionCount.js\").then(\n            ({ eth_getTransactionCount }) =>\n              eth_getTransactionCount(rpcRequest, {\n                address: from,\n                blockTag: \"pending\",\n              }),\n          )\n        : undefined;\n    })(),\n    // takes the same options as the sendTransaction function thankfully!\n    estimateGas(options),\n    getGasOverridesForTransaction(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n  ]);\n\n  const extraGas = await resolvePromisedValue(options.transaction.extraGas);\n  if (extraGas) {\n    gas += extraGas;\n  }\n\n  return {\n    to,\n    chainId,\n    data,\n    gas,\n    nonce,\n    accessList,\n    value,\n    ...feeData,\n  } satisfies TransactionSerializable;\n}\n"],
  "mappings": "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",
  "names": ["a", "b", "c", "e", "f", "g", "i", "j", "k", "m", "readContract", "_a", "encode", "getRpcClient"]
}
