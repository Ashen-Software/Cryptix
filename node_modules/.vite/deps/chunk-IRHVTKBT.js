import {
  getLastAuthProvider
} from "./chunk-5TSRSVIC.js";
import {
  useActiveWallet,
  useWalletBalance
} from "./chunk-EGTGOWTN.js";
import {
  Img,
  appleIconUri,
  emailIcon,
  facebookIconUri,
  genericWalletIcon,
  getStoredActiveWalletId,
  googleIconUri,
  passkeyIcon,
  phoneIcon,
  radius,
  useQuery
} from "./chunk-TS42ER4K.js";
import {
  ethereum
} from "./chunk-F7DA37ES.js";
import {
  require_jsx_runtime
} from "./chunk-PQVTKVEJ.js";
import {
  require_react
} from "./chunk-A4STD2P3.js";
import {
  webLocalStorage
} from "./chunk-57DFWRZ3.js";
import {
  getWalletInfo
} from "./chunk-SPFRZDZE.js";
import {
  getInstalledWalletProviders
} from "./chunk-X54FPRZI.js";
import {
  getContract
} from "./chunk-AOWXXJZS.js";
import {
  readContract
} from "./chunk-OEOA3HT2.js";
import {
  labelhash
} from "./chunk-2I6BQZFD.js";
import {
  encodeAbiParameters
} from "./chunk-3NAETAKT.js";
import {
  isAddress
} from "./chunk-LW7EMTNJ.js";
import {
  keccak256,
  stringToBytes,
  toBytes
} from "./chunk-MQIGPFEC.js";
import {
  resolveScheme
} from "./chunk-PZWOPBWI.js";
import {
  isHex,
  toHex
} from "./chunk-3JG4JMZX.js";
import {
  getCachedChain,
  withCache
} from "./chunk-NMVKDFRL.js";
import {
  getClientFetch
} from "./chunk-CVWITOXT.js";
import {
  bytesToHex,
  concat,
  decodeAbiParameters
} from "./chunk-ZAXCNZIK.js";
import {
  __toESM
} from "./chunk-SEVZ5PBP.js";

// node_modules/thirdweb/dist/esm/utils/ens/avatar.js
async function parseAvatarRecord(options) {
  let uri = options.uri;
  if (/eip155:/i.test(options.uri)) {
    uri = await parseNftUri(options);
  }
  if (!uri) {
    return null;
  }
  const resolvedScheme = resolveScheme({
    client: options.client,
    uri
  });
  if (await isImageUri({ client: options.client, uri: resolvedScheme })) {
    return resolvedScheme;
  }
  return null;
}
async function parseNftUri(options) {
  let uri = options.uri;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference = "", asset_namespace = "", tokenID = ""] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155") {
    throw new Error(`Invalid EIP namespace, expected EIP155, got: "${eip_namespace}"`);
  }
  if (!chainID) {
    throw new Error("Chain ID not found");
  }
  if (!contractAddress || !isAddress(contractAddress)) {
    throw new Error("Contract address not found");
  }
  if (!tokenID) {
    throw new Error("Token ID not found");
  }
  const chain = getCachedChain(Number(chainID));
  const contract = getContract({
    client: options.client,
    chain,
    address: contractAddress
  });
  switch (erc_namespace) {
    case "erc721": {
      const { getNFT } = await import("./getNFT-4A74YM7N.js");
      const nft = await getNFT({
        contract,
        tokenId: BigInt(tokenID)
      });
      return nft.metadata.image ?? null;
    }
    case "erc1155": {
      const { getNFT } = await import("./getNFT-7YAJ3GMR.js");
      const nft = await getNFT({
        contract,
        tokenId: BigInt(tokenID)
      });
      return nft.metadata.image ?? null;
    }
    default: {
      throw new Error(`Invalid ERC namespace, expected ERC721 or ERC1155, got: "${erc_namespace}"`);
    }
  }
}
async function isImageUri(options) {
  try {
    const res = await getClientFetch(options.client)(options.uri, {
      method: "HEAD"
    });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return !!(contentType == null ? void 0 : contentType.startsWith("image/"));
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (Object.hasOwn(globalThis, "Image")) {
      return false;
    }
    return new Promise((resolve2) => {
      const img = new Image();
      img.onload = () => {
        resolve2(true);
      };
      img.onerror = () => {
        resolve2(false);
      };
      img.src = options.uri;
    });
  }
}

// node_modules/thirdweb/dist/esm/utils/ens/encodeLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66) {
    return null;
  }
  if (label.indexOf("[") !== 0) {
    return null;
  }
  if (label.indexOf("]") !== 65) {
    return null;
  }
  const hash = `0x${label.slice(1, 65)}`;
  if (!isHex(hash)) {
    return null;
  }
  return hash;
}

// node_modules/thirdweb/dist/esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name) {
    return bytesToHex(result);
  }
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const item = labels[i];
    const hashFromEncodedLabel = encodedLabelToLabelhash(item);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(item), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// node_modules/thirdweb/dist/esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash) {
  return `[${hash.slice(2)}]`;
}

// node_modules/thirdweb/dist/esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0) {
    return new Uint8Array(1);
  }
  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    let encoded = stringToBytes(item);
    if (encoded.byteLength > 255) {
      encoded = stringToBytes(encodeLabelhash(labelhash(item)));
    }
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes.byteLength !== offset + 1) {
    return bytes.slice(0, offset + 1);
  }
  return bytes;
}

// node_modules/thirdweb/dist/esm/extensions/ens/__generated__/AddressResolver/read/text.js
var FN_SELECTOR = "0x59d1d43c";
var FN_INPUTS = [
  {
    type: "bytes32",
    name: "name"
  },
  {
    type: "string",
    name: "key"
  }
];
var FN_OUTPUTS = [
  {
    type: "string"
  }
];
function encodeTextParams(options) {
  return encodeAbiParameters(FN_INPUTS, [options.name, options.key]);
}
function encodeText(options) {
  return FN_SELECTOR + encodeTextParams(options).slice(2);
}
function decodeTextResult(result) {
  return decodeAbiParameters(FN_OUTPUTS, result)[0];
}

// node_modules/thirdweb/dist/esm/extensions/ens/__generated__/UniversalResolver/read/resolve.js
var FN_SELECTOR2 = "0x9061b923";
var FN_INPUTS2 = [
  {
    type: "bytes",
    name: "name"
  },
  {
    type: "bytes",
    name: "data"
  }
];
var FN_OUTPUTS2 = [
  {
    type: "bytes"
  },
  {
    type: "address"
  }
];
async function resolve(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2],
    params: [options.name, options.data]
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/constants.js
var UNIVERSAL_RESOLVER_ADDRESS = "0xce01f8eee7E479C928F8919abD53E553a36CeF67";

// node_modules/thirdweb/dist/esm/extensions/ens/resolve-text.js
async function resolveText(options) {
  const { client, name, key, resolverAddress, resolverChain } = options;
  return withCache(async () => {
    const contract = getContract({
      client,
      chain: resolverChain || ethereum,
      address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS
    });
    const data = encodeText({ name: namehash(name), key });
    const result = await resolve({
      contract,
      name: toHex(packetToBytes(name)),
      data
    });
    if (result[0] === "0x") {
      return null;
    }
    const record = decodeTextResult(result[0]);
    return record === "" ? null : record;
  }, {
    cacheKey: `ens:text:${name}:${key}`,
    // 1min cache
    cacheTime: 60 * 1e3
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/resolve-avatar.js
async function resolveAvatar(options) {
  const { client, name, resolverAddress, resolverChain } = options;
  return withCache(async () => {
    const record = await resolveText({
      client,
      key: "avatar",
      name,
      resolverAddress,
      resolverChain
    });
    if (!record) {
      return null;
    }
    try {
      return parseAvatarRecord({ uri: record, client });
    } catch (e) {
      console.error("Error parsing avatar record", e);
      return null;
    }
  }, {
    cacheKey: `ens:avatar:${name}`,
    // 1min cache
    cacheTime: 60 * 1e3
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/__generated__/UniversalResolver/read/reverse.js
var FN_SELECTOR3 = "0xec11c823";
var FN_INPUTS3 = [
  {
    type: "bytes",
    name: "reverseName"
  }
];
var FN_OUTPUTS3 = [
  {
    type: "string"
  },
  {
    type: "address"
  },
  {
    type: "address"
  },
  {
    type: "address"
  }
];
async function reverse(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR3, FN_INPUTS3, FN_OUTPUTS3],
    params: [options.reverseName]
  });
}

// node_modules/thirdweb/dist/esm/extensions/ens/resolve-name.js
async function resolveName(options) {
  const { client, address, resolverAddress, resolverChain } = options;
  return withCache(async () => {
    const contract = getContract({
      client,
      chain: resolverChain || ethereum,
      address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS
    });
    const reverseName = toHex(packetToBytes(`${address.toLowerCase().substring(2)}.addr.reverse`));
    const [name, resolvedAddress] = await reverse({
      contract,
      reverseName
    }).catch((e) => {
      if ("data" in e && e.data === "0x7199966d") {
        return [null, address];
      }
      throw e;
    });
    if (address.toLowerCase() !== resolvedAddress.toLowerCase()) {
      return null;
    }
    return name;
  }, {
    cacheKey: `ens:name:${address}`,
    // 1min cache
    cacheTime: 60 * 1e3
  });
}

// node_modules/thirdweb/dist/esm/react/core/utils/addresses.js
function shortenString(str, extraShort = true) {
  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(str.length - (extraShort ? 3 : 4))}`;
}

// node_modules/thirdweb/dist/esm/react/core/utils/wallet.js
function useConnectedWalletDetails(client, walletChain, activeAccount, displayBalanceToken) {
  const tokenAddress = walletChain && displayBalanceToken ? displayBalanceToken[Number(walletChain.id)] : void 0;
  const ensNameQuery = useQuery({
    queryKey: ["ens-name", activeAccount == null ? void 0 : activeAccount.address],
    enabled: !!(activeAccount == null ? void 0 : activeAccount.address),
    queryFn: () => resolveName({
      client,
      address: (activeAccount == null ? void 0 : activeAccount.address) || "",
      resolverChain: ethereum
    })
  });
  const ensAvatarQuery = useQuery({
    queryKey: ["ens-avatar", ensNameQuery.data],
    enabled: !!ensNameQuery.data,
    queryFn: async () => resolveAvatar({
      client,
      name: ensNameQuery.data || ""
    })
  });
  const shortAddress = (activeAccount == null ? void 0 : activeAccount.address) ? shortenString(activeAccount.address, false) : "";
  const balanceQuery = useWalletBalance({
    chain: walletChain ? walletChain : void 0,
    tokenAddress,
    address: activeAccount == null ? void 0 : activeAccount.address,
    client
  });
  const addressOrENS = ensNameQuery.data || shortAddress;
  return {
    ensNameQuery,
    ensAvatarQuery,
    addressOrENS,
    shortAddress,
    balanceQuery
  };
}
function useWalletInfo(id) {
  return useQuery({
    queryKey: ["wallet-info", id],
    queryFn: () => {
      return getWalletInfo(id, false);
    },
    retry: false,
    refetchOnWindowFocus: false,
    refetchOnMount: false
  });
}
function useWalletImage(id) {
  return useQuery({
    queryKey: ["wallet-image", id],
    queryFn: () => {
      return getWalletInfo(id, true);
    },
    retry: false,
    refetchOnWindowFocus: false,
    refetchOnMount: false
  });
}

// node_modules/thirdweb/dist/esm/react/web/ui/components/WalletImage.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
function WalletImage(props) {
  const [image, setImage] = (0, import_react.useState)(void 0);
  const activeWallet = useActiveWallet();
  (0, import_react.useEffect)(() => {
    async function fetchImage() {
      var _a;
      const storage = webLocalStorage;
      let activeEOAId = props.id;
      if (props.id === "smart") {
        const storedId = await getStoredActiveWalletId(storage);
        if (storedId) {
          activeEOAId = storedId;
        }
      }
      let image2;
      if (activeEOAId === "inApp" && activeWallet && (activeWallet.id === "inApp" || activeWallet.id === "smart")) {
        const lastAuthProvider = await getLastAuthProvider(storage);
        switch (lastAuthProvider) {
          case "google":
            image2 = googleIconUri;
            break;
          case "apple":
            image2 = appleIconUri;
            break;
          case "facebook":
            image2 = facebookIconUri;
            break;
          case "phone":
            image2 = phoneIcon;
            break;
          case "email":
            image2 = emailIcon;
            break;
          case "passkey":
            image2 = passkeyIcon;
            break;
        }
      } else {
        const mipdImage = (_a = getInstalledWalletProviders().find((x) => x.info.rdns === activeEOAId)) == null ? void 0 : _a.info.icon;
        if (mipdImage) {
          image2 = mipdImage;
        } else {
          image2 = await getWalletInfo(activeEOAId, true);
        }
      }
      setImage(image2);
    }
    fetchImage();
  }, [props.id, activeWallet]);
  if (image) {
    return (0, import_jsx_runtime.jsx)(Img, { src: image, width: props.size, height: props.size, loading: "eager", client: props.client, style: {
      borderRadius: radius.md
    } });
  }
  return (0, import_jsx_runtime.jsx)(WalletImageQuery, { id: props.id, size: props.size, client: props.client });
}
function WalletImageQuery(props) {
  const walletImage = useWalletImage(props.id);
  if (walletImage.isFetched && !walletImage.data) {
    return (0, import_jsx_runtime.jsx)(Img, { client: props.client, src: genericWalletIcon, width: props.size, height: props.size });
  }
  return (0, import_jsx_runtime.jsx)(Img, { client: props.client, src: walletImage.isLoading ? void 0 : walletImage.data, fallbackImage: genericWalletIcon, width: props.size, height: props.size, loading: "eager", style: {
    borderRadius: radius.md
  } });
}

export {
  namehash,
  packetToBytes,
  resolve,
  UNIVERSAL_RESOLVER_ADDRESS,
  shortenString,
  useConnectedWalletDetails,
  useWalletInfo,
  useWalletImage,
  WalletImage
};
//# sourceMappingURL=chunk-IRHVTKBT.js.map
